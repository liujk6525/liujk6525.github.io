{
    "version": "https://jsonfeed.org/version/1",
    "title": "你不是单打独斗 • All posts by \"路径规划\" category",
    "description": "",
    "home_page_url": "https://liujk6525.github.io",
    "items": [
        {
            "id": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "url": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "title": "基于智能算法的路径规划",
            "date_published": "2023-05-15T00:38:42.000Z",
            "content_html": "<h1 id=\"基础知识\">基础知识</h1>\r\n<h2 id=\"遗传算法\">遗传算法</h2>\r\n<p>遗传算法(Genetic Algorithm,<a href=\"https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95\"><code>GA</code></a>)是一种智能优化算法，主要用来解决优化问题，其主要步骤为种群初始化、适应度函数计算、选择、交叉和变异。应用于移动机器人路径规划时其主要步骤相同。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"算法步骤\">算法步骤</h2>\r\n<p>选择初始生命种群</p>\r\n<ol type=\"1\">\r\n<li>每行选择一个栅格</li>\r\n<li>判断相邻栅格是否连续</li>\r\n<li>不连续时选择栅格进行插入，直到连续</li>\r\n</ol>\r\n<p>循环</p>\r\n<ul>\r\n<li><p>评价种群中的个体适应度fitness</p></li>\r\n<li><p>以比例原则(分数高的挑中几率也较高)选择产生下一个种群(轮盘法、竞争法及等级轮盘法)。</p>\r\n<p><strong>选择</strong></p>\r\n<p>是按照轮盘法来选择的个体 <span class=\"math display\">\\[\r\nd =\\sum_{i=1}^{end-1}{\\sqrt{(x_{i+1}-x{i})^{2}+(y_{i+1}-y_{i})^{2}}}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nfit_1=1/d\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nfit_2=acrccos(\\frac{(b^2+c^2-a^2)}{2bc})\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nfit=fit_1+fit_2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\np_i=\\frac{fit_i}{\\sum_{i=1}^{end}fit_i}\r\n\\]</span></p></li>\r\n<li><p>改变该种群(选择、交叉和变异)</p>\r\n<p><strong>交叉</strong></p>\r\n<p>如下图所示，当两个个体{0|6|7|13|19|24}和{0|1|2|3|8|13|18|24}在栅格13处交叉，经过交叉操作后会生成新的个体{0|6|7|13|18|24}和{0|1|2|3|8|13|19|24}</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515103232016.png\"  style=\"zoom:80%;\" /></p>\r\n<p><strong>变异</strong></p>\r\n<p>如下图所示，当个体{0|1|2|3|8|13|18|24}经过变异操作后会随机生成新的个体{0|1|7|13|18|24}</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515103809856.png\"  style=\"zoom:80%;\" /></p></li>\r\n<li><p>直到停止循环的条件满足</p></li>\r\n</ul>\r\n<h1 id=\"代码实现\">代码实现</h1>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515104419609.png\"  style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=8&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>机器人路径规划、轨迹优化课程</code></a></p>\r\n",
            "tags": [
                "Matlab"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E9%87%87%E6%A0%B7%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "url": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E9%87%87%E6%A0%B7%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "title": "基于采样的路径规划",
            "date_published": "2023-05-13T13:41:15.000Z",
            "content_html": "<h1 id=\"基础知识\">基础知识</h1>\r\n<p>虽然<code>基于图搜索的路径规划算法</code>能够给出一个<strong>全局范围内的最优解</strong>，但是当地图过大，空间维度过高时，它的搜索效率就会变得很慢。主要用于低维空间的路径规划问题。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"概率路图算法probabilistic-road-map-prm\">概率路图算法(Probabilistic Road Map, <a href=\"https://en.wikipedia.org/wiki/Probabilistic_roadmap\"><code>PRM</code></a>)</h2>\r\n<p><code>PRM</code>算法首先使用随机采样的方式在环境中建立路径网络图，将连续的空间转换为离散的空间，然后在路径网络图上进行路径规划，解决在高维空间中搜索效率低的问题</p>\r\n<p>算法流程</p>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/prm.png\"  style=\"zoom: 80%;\" /></p>\r\n<p><strong>采样点的数量</strong>和<strong>采样点间存在通道的最大距离</strong>是关键参数，具体的</p>\r\n<p>采样点的数量太少，可能会导致路径规划失败，因为生成的概率路线少了。</p>\r\n<p>随着采样点数量增加，结果会越来越接近最短路径，但同时搜索效率会降低</p>\r\n<h2 id=\"快速扩展随机树rapidly-exploring-random-tree-rrt算法\">快速扩展随机树(Rapidly-exploring Random Tree, <a href=\"https://en.wikipedia.org/wiki/Rapidly-exploring_random_tree\"><code>RRT</code></a>)算法</h2>\r\n<p><code>RRT</code>算法是一种单查询(single-query)算法，搜索过程就像一棵树不断向周围扩展生长。它的复杂度不受地图的离散程度影响，在高维空间中具有很高的搜索效率。</p>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/RRT.png\"  style=\"zoom:80%;\" /></p>\r\n<p>缺点：只管尽快地找到可行路径，所以最终路径并不是最优的，甚至会非常“绕”。</p>\r\n<h2 id=\"双向快速扩展随机树rrt-connect算法\">双向快速扩展随机树(<a href=\"https://ieeexplore.ieee.org/document/844730\"><code>RRT-Connect</code></a>)算法</h2>\r\n<p>在<code>RRT</code>的基础上引入了双向扩展环节，分别以起点和目标点为根节点生成两棵树进行双向扩展，<strong>加快了搜索速度</strong>，当两棵树建立连接时被认为路径规划成功。</p>\r\n<p>缺点：但是<code>RRT-Connect</code>和<code>RRT</code>一样，都是单查询算法，最终路径并不是最优的。</p>\r\n<h2 id=\"rrt算法\"><a href=\"https://arxiv.org/abs/1105.1186\"><code>RRT*</code></a>算法</h2>\r\n<p><code>RRT*</code>算法是一种渐近最优算法。在<code>RRT</code>算法的基础上，增加了将<span class=\"math inline\">\\(X_{rand}\\)</span>加入搜索树 T 时<strong>父节点的选择策略</strong>。</p>\r\n<p><code>RRT*</code>算法在选择父节点时会有一个<strong>重连(Rewire)</strong>过程，也就是在以<span class=\"math inline\">\\(X_{rand}\\)</span>为圆心、半径为<span class=\"math inline\">\\(r\\)</span>的邻域内，找到与<span class=\"math inline\">\\(X_{new}\\)</span>连接后移动代价(从起点移动到<span class=\"math inline\">\\(X_{new}\\)</span>的路径长度)最小的节点，并重新选择<span class=\"math inline\">\\(X_{min}\\)</span>作为<span class=\"math inline\">\\(X_{new}\\)</span>的父节点，而不是<span class=\"math inline\">\\(X_{near}\\)</span>。</p>\r\n<p>简单理解就是<span class=\"math inline\">\\(Xnear\\)</span>产生了<span class=\"math inline\">\\(Xnew\\)</span>,然而<span class=\"math inline\">\\(Xnew\\)</span>抛弃了<span class=\"math inline\">\\(Xnear\\)</span>，选择了移动代价最小的<span class=\"math inline\">\\(Xmin\\)</span>作为父节点。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/v2-1b532a8161587f211b6a7a3c9e239589_720w.webp\"  style=\"zoom: 67%;\" /></p>\r\n<p>缺点：<code>RRT*</code>*是对自由空间进行均匀采样，搜索树上会生成很多冗余的分支，所以<code>RRT*</code>的收敛速度很慢。</p>\r\n<h2 id=\"informed-rrt算法\"><a href=\"https://arxiv.org/abs/1404.2334\"><code>Informed-RRT*</code></a>算法</h2>\r\n<p>对<code>RRT*</code>的改进策略：采用椭圆采样来代替全局均匀采样</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230514175249529.png\"  style=\"zoom: 50%;\" /></p>\r\n<p>以起点 <span class=\"math inline\">\\(X_{start}\\)</span>和终点<span class=\"math inline\">\\(X_{goal}\\)</span>作为椭圆的焦点，令<span class=\"math inline\">\\(a\\)</span>等于初始路径长度<span class=\"math inline\">\\(c_{best}\\)</span>的一半，即<span class=\"math inline\">\\(a=\\frac{c_{best}}{2}\\)</span>，则$ c=<span class=\"math inline\">\\(，\\)</span>b=$，这样就可以得到椭圆方程的所有参数。</p>\r\n<p>在之后的迭代中，如果没找到更短的路径，就用<span class=\"math inline\">\\(c_{min}\\)</span>作为新的<span class=\"math inline\">\\(c_{best}\\)</span>，然后在新的椭圆区域进行采样。</p>\r\n<h1 id=\"代码实现\">代码实现</h1>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230514234320378.png\"  style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230514234432119.png\"  style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230514234602917.png\"  style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230514234911888.png\"  style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/349074802\"><code>路径规划 | 随机采样算法：PRM、RRT、RRT-Connect、RRT*</code></a></p>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/372315811\"><code>路径规划 | 随机采样算法：Informed-RRT*</code></a></p>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=5\"><code>机器人路径规划、轨迹优化系列课程</code></a></p>\r\n<p>[1] Lavalle S M . Rapidly-Exploring Random Trees: A New Tool for Path Planning[J]. Research Report, 1999.</p>\r\n<p>[2] Jr J , Lavalle S M . RRT-Connect: An Efficient Approach to Single-Query Path Planning[C]// Proceedings of the 2000 IEEE International Conference on Robotics and Automation, ICRA 2000, April 24-28, 2000, San Francisco, CA, USA. IEEE, 2000.</p>\r\n<p>[3] Karaman S , Frazzoli E . Sampling-based Algorithms for Optimal Motion Planning[J]. The International Journal of Robotics Research, 2011, 30(7):846-894.</p>\r\n<p>[4] Gammell J D , Srinivasa S S , Barfoot T D . Informed RRT*: Optimal Sampling-based Path Planning Focused via Direct Sampling of an Admissible Ellipsoidal Heuristic[J]. IEEE, 2014.</p>\r\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "url": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "title": "基于搜索的路径规划",
            "date_published": "2023-05-12T03:36:41.000Z",
            "content_html": "<h1 id=\"基础知识\">基础知识</h1>\r\n<p><strong>图搜索法</strong>是通过利用已有的环境地图和障碍物等数据信息，建立由起点至目标点的可行路线。</p>\r\n<p><strong>配置空间(Configuration Space)</strong> 在实际环境，要将工作空间转换到配置空间中，即将机器人转化为一个<strong>质点</strong>，同时将障碍物按照机器人的体积进行膨胀</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"基本流程\">基本流程</h2>\r\n<ul>\r\n<li>在容器<code>open list</code>中存放将要访问的节点</li>\r\n<li>将起点加入容器</li>\r\n<li>While True：</li>\r\n<li>弹出：从容器中取出一个节点</li>\r\n<li>扩展：将该节点周围的其他节点放入<code>open list</code></li>\r\n</ul>\r\n<h2 id=\"深度优先搜索depth-first-search-dfs-算法\">深度优先搜索(Depth First Search, <a href=\"https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\"><code>DFS</code></a> )算法</h2>\r\n<ul>\r\n<li>优先扩展搜索深度较大的节点，从起点开始，按照某个顺序一条路走下去，直至不能再继续为止，然后回到上一节点，再换另一条路走下去；</li>\r\n<li>深度优先搜索的过程是一条路走到底后，最后访问的节点最先拿来处理，整个过程可以用<code>栈(stack)</code>来表示——<strong>后进先出</strong>。</li>\r\n<li>深度优先算法优先扩展搜索深度较大的节点，因此能够更迅速的获得下一个可行路径，不过深度优先算法获取的第一个路径通常是比较长的路径。</li>\r\n</ul>\r\n<p>在<strong>无权图</strong>中找到从节点<code>a</code>到节点<code>j</code>的路径为例</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/dfs.png\"  style=\"zoom:80%;\" /></p>\r\n<p>按照<code>DFS</code>的基本流程搜索<code>a</code>到<code>j</code>的路径：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/dfs-1683872034517-4.png\"  style=\"zoom:80%;\" /></p>\r\n<p>从目标点开始回溯：<code>a-&gt;b-&gt;f-&gt;j</code></p>\r\n<h2 id=\"广度优先搜索breadth-first-search-bfs算法\">广度优先搜索(Breadth First Search, <a href=\"https://zh.wikipedia.org/zh-hans/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\"><code>BFS</code></a>)算法</h2>\r\n<ul>\r\n<li><p>每一步都扩展同一层的所有可能节点，一层一层扩展下去，直到某一层搜索到终点为止。</p></li>\r\n<li><p>广度优先搜索的过程是一层中先访问的节点拿来处理，可以用<code>队列(queue)</code>来表示——<strong>先进先出</strong>。</p></li>\r\n<li><p>广度优先算法优先扩展深入较小的节点，呈<strong>波状推进</strong>的形式搜索。因此广度优先算法检索到的第一个路径通常是最短路径。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/bfs.png\"   style=\"zoom:80%;\" /></p></li>\r\n</ul>\r\n<h2 id=\"贪婪最佳优先搜索greedy-best-first-searchgbfs-算法\">贪婪最佳优先搜索(Greedy Best First Search,<a href=\"https://www.codecademy.com/resources/docs/ai/search-algorithms/greedy-best-first-search\"><code>GBFS</code></a> )算法</h2>\r\n<p>使用的是<strong>优先队列(Priority Queue)</strong>，普通队列是一种<strong>先进先出</strong>的数据结构，而在优先队列中元素被赋予了优先级，最高优先级元素优先删除，也就是<code>first in</code>, <code>largest out</code></p>\r\n<p>在图搜索算法中，优先级判断的标准是代价函数 <span class=\"math inline\">\\(f(n)\\)</span> ， <span class=\"math inline\">\\(f(n)\\)</span> 越小，优先级越高。</p>\r\n<p><span class=\"math display\">\\[\r\nf(n)=h(n)\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(h(n)\\)</span>是启发式函数，为节点<span class=\"math inline\">\\(n\\)</span>到目标节点之间所形成路径的最小代价值。一般为<a href=\"https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB\"><code>欧氏距离</code></a>或者<a href=\"https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%93%88%E9%A0%93%E8%B7%9D%E9%9B%A2\"><code>曼哈顿距离</code></a></p>\r\n<p>遇到障碍物时，它很容易陷入局部最优的陷阱。</p>\r\n<h1 id=\"dijkstra算法\"><a href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\"><code>Dijkstra</code></a>算法</h1>\r\n<p>Dijkstra算法是从一个顶点到其余各顶点的最短路径算法，其流程仍然与上述算法基本一致，它也是用优先队列作为<code>open list</code>的数据结构，它和<code>GBFS</code>的区别在于代价函数 <span class=\"math inline\">\\(f(n)\\)</span>的定义:</p>\r\n<p><span class=\"math display\">\\[\r\nf(n)=g(n)\r\n\\]</span> <span class=\"math inline\">\\(g(n)\\)</span>表示从起始节点到当前节点<span class=\"math inline\">\\(n\\)</span>的移动代价函数。</p>\r\n<p>计算起点<code>v1</code>到终点<code>v6</code>的最短路径，箭头上的数值表示<strong>两个节点间的距离</strong></p>\r\n<ol type=\"1\">\r\n<li><p>首先扩展第一个节点，计算其余邻近节点与第一个节点的距离，从未扩展的节点中选择代价函数最小的节点进行扩展，并更新其余节点的代价函数</p></li>\r\n<li><p>重复进行上面的步骤，直到所有节点都已扩展。</p></li>\r\n<li><p>最后标出起点到终点的最短路径</p>\r\n<p>找到一条从<code>1</code>到<code>6</code>的最短路径</p></li>\r\n</ol>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/image-20230512205640371.png\"  style=\"zoom:80%;\" /></p>\r\n<p><code>open list</code>: 4(1) 2(2) # 存储已经被搜索过但没有被访问过的节点，并对其进行排序</p>\r\n<p><code>closed list</code>:1(0) # 存储已经被访问过的节点</p>\r\n<p>从<code>open list</code>中的节点中选择距离最小的节点作为扩展节点，显然是节点4。</p>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/image-20230512210430685.png\"  style=\"zoom:80%;\" /></p>\r\n<p><code>open list</code>: 2(2) 3(3) 7(5) 6(9) # 遍历邻接节点，更新距离</p>\r\n<p><code>closed list</code>: 1(0) 4(1)</p>\r\n<p>重复上述操作。选择新的扩展节点，即节点2</p>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/image-20230512211350445.png\" style=\"zoom:80%;\" /></p>\r\n<p><code>open list</code>: 3(3) 7(5) <strong>6(9)</strong> 5(13)</p>\r\n<p><code>closed list</code>: 1(0) 4(1) 2(2)</p>\r\n<p>选择新的扩展节点，即节点3</p>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/image-20230512212316556.png\" style=\"zoom:80%;\" /></p>\r\n<p><code>open list</code>: 7(5) <strong>6(8)</strong> 5(13) # 注意这里访问节点3，对它的领接节点6的距离进行了更新</p>\r\n<p><code>closed list</code>: 1(0) 4(1) 2(2) 3(3)</p>\r\n<p>选择新的扩展节点，即节点7</p>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/image-20230512213110030.png\"  style=\"zoom:80%;\" /></p>\r\n<p><code>open list</code>: <strong>6(6)</strong> 5(13) # 注意这里访问节点7，对它的领接节点6的距离进行了更新</p>\r\n<p><code>closed list</code>: 1(0) 4(1) 2(2) 3(3) 7(5)</p>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/image-20230512214147752.png\"  style=\"zoom:80%;\" /></p>\r\n<p><code>closed list</code>: 1(0) 4(1) 2(2) 3(3) 7(5) 6(6)</p>\r\n<h1 id=\"a搜索a-search算法\"><code>A*</code>搜索(<a href=\"https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95\"><code>A* search</code></a>)算法</h1>\r\n<p><code>GBFS</code>用节点到目标点的距离作为代价函数，将搜索方向引向目标点，搜索效率高。</p>\r\n<p><code>Dijkstra</code>算法采用起点到当前扩展节点的移动代价作为代价函数，能够确保路径最优。</p>\r\n<p><code>A*</code>搜索算法在<code>Dijkstra</code>算法的基础上增加启发式函数<span class=\"math inline\">\\(h(n)\\)</span>，规定其代价函数为 <span class=\"math display\">\\[\r\nf(n)=g(n)+h(n)\r\n\\]</span></p>\r\n<h1 id=\"代码实现\">代码实现</h1>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/Astart.png\" alt=\"Astart\" style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/dijkstra.png\" alt=\"dijkstra\" style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://zhuanlan.zhihu.com/p/346666812\"><code>路径规划 | 图搜索算法：DFS、BFS、GBFS、Dijkstra、A*</code></a></p>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=2\">机器人路径规划、轨迹优化系列课程</a></p>\r\n",
            "tags": [
                "Python"
            ]
        }
    ]
}