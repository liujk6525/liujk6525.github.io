{
    "version": "https://jsonfeed.org/version/1",
    "title": "你不是单打独斗 • All posts by \"轨迹优化\" category",
    "description": "",
    "home_page_url": "https://liujk6525.github.io",
    "items": [
        {
            "id": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-%E9%97%AD%E5%BC%8F%E6%B1%82%E8%A7%A3/",
            "url": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-%E9%97%AD%E5%BC%8F%E6%B1%82%E8%A7%A3/",
            "title": "轨迹优化-闭式求解",
            "date_published": "2023-05-16T02:20:21.000Z",
            "content_html": "<p>如果<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/4269159\"><code>QP</code></a>问题只有等式约束，没有不等式约束，可以采用<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A7%A3\"><code>闭式求解</code></a>的方式。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"构建等式约束方程\">构建等式约束方程</h1>\r\n<p>还是一段复杂的轨迹按照时间划分成<span class=\"math inline\">\\(m\\)</span>段，一共有<span class=\"math inline\">\\(m+1\\)</span>个点，其中<span class=\"math inline\">\\(0\\)</span>是起点，<span class=\"math inline\">\\(m\\)</span>是目标点，<span class=\"math inline\">\\(m-1\\)</span>个中间点。每段多项式轨迹都构成 <span class=\"math display\">\\[\r\nA_ip_i=d_i,\\quad \r\nA_i=\\left[\\begin{matrix}\r\nA_0\\\\A_T\r\n\\end{matrix}\\right]_i,\\quad\r\nd_i=\\left[\\begin{matrix}\r\nd_0\\\\d_T\r\n\\end{matrix}\\right]_i\r\n\\]</span></p>\r\n<p>其中，<span class=\"math inline\">\\(d_o,d_T\\)</span>是第<span class=\"math inline\">\\(i\\)</span>段多项式轨迹的起点和终点的各阶导数组成的向量。这里只考虑了位置速度和加速度。 <span class=\"math display\">\\[\r\n\\underbrace{A_{total}}_{6m \\times m(n+1)}\r\n\\underbrace{\r\n\\left[ \\begin{matrix}\r\np_1 \\\\\r\n\\vdots \\\\\r\np_m \\\\\r\n\\end{matrix} \\right]}_{m(n+1) \\times 1} \r\n= \\left[ \\begin{matrix}\r\nd_1 \\\\\r\n\\vdots \\\\\r\nd_m \\\\\r\n\\end{matrix} \\right]\r\n=\\underbrace{\r\n\\left[ \\begin{matrix}\r\np_1(t_0)\\\\\r\nv_1(t_0)\\\\\r\na_1(t_0)\\\\\r\np_1(t_1)\\\\\r\nv_1(t_1)\\\\\r\na_1(t_1)\\\\\r\n\\vdots \\\\\r\np_m(t_{m-1})\\\\\r\nv_m(t_{m-1})\\\\\r\na_m(t_{m-1})\\\\\r\np_m(t_m)\\\\\r\nv_m(t_m)\\\\\r\na_m(t_m)\\\\\r\n\\end{matrix} \\right]}_{6m \\times 1}\r\n\\]</span> 目标是要求解参数<span class=\"math inline\">\\(p\\)</span> <span class=\"math display\">\\[\r\np=A^{-1}d\r\n\\]</span></p>\r\n<h2 id=\"消除重复变量\">消除重复变量</h2>\r\n<p>考虑到连续性(这里假设P、V、A连续)，向量中很多变量重复了 <span class=\"math display\">\\[\r\np_i(t_i)=p_{i+1}(t_i),~~v_i(t_i)=v_{i+1}(t_i),~~a_i(t_i)=a_{i+1}(t_i)\r\n\\]</span> 连续性约束不是直接加到等式约束方程中。而是通过一个映射矩阵<span class=\"math inline\">\\(M\\)</span>将一个变量映射到两个重复的变量上。 <span class=\"math display\">\\[\r\n\\underbrace{\r\n\\left[ \\begin{matrix}\r\nd_1 \\\\\r\n\\vdots \\\\\r\nd_k \\\\\r\n\\end{matrix} \\right]}_{6m\\times1}=\r\n\\underbrace{\r\n\\left[ \\begin{matrix}\r\n1\\\\\r\n&amp;1\\\\\r\n&amp;&amp;1\\\\\r\n&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\ddots\r\n\\end{matrix} \\right]}_{M}\r\n\\underbrace{\r\n\\left[\\begin{matrix} \r\np(t_0)\\\\\r\nv(t_0)\\\\\r\na(t_0)\\\\\r\np(t_1)\\\\\r\nv(t_1)\\\\\r\na(t_1)\\\\\r\np(t_2)\\\\\r\nv(t_2)\\\\\r\na(t_2)\\\\\r\n\\vdots\\\\\r\np(t_m)\\\\\r\nv(t_m)\\\\\r\na(t_m)\\\\\r\n\\end{matrix} \\right]}_{3(m+1)\\times 1}\r\n\\]</span> 即<span class=\"math inline\">\\(d=Md&#39;\\)</span></p>\r\n<h2 id=\"向量元素置换\">向量元素置换</h2>\r\n<p>接着把已知参数 <span class=\"math inline\">\\(d_F\\)</span>和未知参数<span class=\"math inline\">\\(d_P\\)</span>重新排列，可以左乘一个置换矩阵<span class=\"math inline\">\\(C\\)</span>，使得<span class=\"math inline\">\\(d&#39;=C\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\\)</span></p>\r\n<h2 id=\"转成无约束优化问题\">转成无约束优化问题</h2>\r\n<p>所以 <span class=\"math inline\">\\(d=MC\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\\)</span> <span class=\"math display\">\\[\r\np=A^{-1}d=\\underbrace{A^{-1}MC}_K\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right] = K\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\r\n\\]</span> 将<span class=\"math inline\">\\(p\\)</span>代入优化函数 <span class=\"math display\">\\[\r\n\\min p^TQp\\\\\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]^T\\underbrace{K^TQK}_R\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]^T\r\n\\left[\\begin{matrix}R_{FF} &amp; R_{FP}\\\\R_{PF}&amp;R_{PP}\\end{matrix}\\right]\r\n\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=d_F^TR_{FF}d_F+d_F^TR_{FP}d_P+d_P^TR_{PF}d_F+d_P^TR_{PP}d_P\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=d_F^TR_{FF}d_F+2d_F^TR_{FP}d_P+d_P^TR_{PP}d_P\r\n\\]</span></p>\r\n<p>令优化函数<span class=\"math inline\">\\(mibn\\)</span>对<span class=\"math inline\">\\(d_P\\)</span>求导，并且令其导数等于0 <span class=\"math display\">\\[\r\n\\rightarrow 2d_F^TR_{FP}+2R_{PP}d_P=0\\quad(R_{PP}^T=R_{PP})\\\\\r\n\\rightarrow d^*_p = -R_{PP}^{-1}R_{FP}^Td_F\r\n\\]</span></p>\r\n<h1 id=\"总结\">总结</h1>\r\n<ol type=\"1\">\r\n<li><p>先确定轨迹阶数(这里是用的5阶，因为A矩阵要为方形阵，所以<span class=\"math inline\">\\(6m=m(n+1)\\rightarrow n=5\\)</span>)，再确定<span class=\"math inline\">\\(d\\)</span>中的约束量(p、v、a)，进而根据各段的时间分配求得<span class=\"math inline\">\\(A_{total}\\)</span></p></li>\r\n<li><p>根据连续性约束构造映射矩阵<span class=\"math inline\">\\(M\\)</span>，并确定<span class=\"math inline\">\\(d\\)</span>中哪些量是已知的(fix/specified)，哪些量是未知的(free/unspecified)，进而构造置换矩阵<span class=\"math inline\">\\(C\\)</span>，并求得<span class=\"math inline\">\\(K=A^{-1}MC\\)</span>。</p></li>\r\n<li><p>计算目标函数中的Q矩阵，并计算<span class=\"math inline\">\\(R=K^TQK\\)</span>，根据已知参数(fix)的长度将<span class=\"math inline\">\\(R\\)</span>拆分成<span class=\"math inline\">\\(R_{FF},R_{FR},R_{FR},R_{PP}\\)</span>四小块。</p></li>\r\n<li><p>根据<span class=\"math inline\">\\(d^*_p = -R_{PP}^{-1}R_{FP}^Td_F\\)</span>计算<span class=\"math inline\">\\(d^*_p\\)</span></p></li>\r\n<li><p>根据<span class=\"math inline\">\\(p=K\\left[\\begin{matrix}d_F\\\\d_p\\end{matrix}\\right]\\)</span>计算得到轨迹参数<span class=\"math inline\">\\(p\\)</span></p></li>\r\n</ol>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230516211818087.png\" style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230516211938320.png\"  style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p>Richter C, Bry A, Roy N. Polynomial trajectory planning for aggressive quadrotor flight in dense indoor environments[C]//Robotics Research: The 16th International Symposium ISRR. Springer International Publishing, 2016: 649-666.</p>\r\n<p><a href=\"https://blog.csdn.net/q597967420/article/details/79031791?spm=1001.2014.3001.5502\"><code>Minimum Snap轨迹规划详解（3）闭式求解</code></a></p>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=12&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>机器人路径规划、轨迹优化系列课程</code></a></p>\r\n",
            "tags": [
                "Matlab"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-MinimumSnap/",
            "url": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-MinimumSnap/",
            "title": "轨迹优化-MinimumSnap",
            "date_published": "2023-05-15T06:16:00.000Z",
            "content_html": "<h1 id=\"基础知识\">基础知识</h1>\r\n<h2 id=\"二次型\">二次型</h2>\r\n<p>含有n个变量<span class=\"math inline\">\\(x=x_1,x_2,\\cdots,x_{n-1},x_{n}\\)</span>的二次齐次函数 <span class=\"math display\">\\[\r\nf(x_1,x_2,...,x_n)=a11x_1^2+a22x_2^2+\\cdots+a_{nn}x_n^2\r\n\\]</span> 称为二次型。取<span class=\"math inline\">\\(a_{ij}=a_{ji}\\)</span>，则有<span class=\"math inline\">\\(2a_{ij}x_ix_j=a_{ij}x_ix_j+a_{ji}x_jx_i\\)</span>，上式可表示为<span class=\"math inline\">\\(f(x)=\\sum_{i,j=1}^{n}a_{ij}x_ix_j\\)</span>。矩阵表示为<span class=\"math inline\">\\(f=x^TAx\\)</span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"二次规划quadratic-programming-qp\">二次规划(Quadratic Programming, <a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92\"><code>QP</code></a>)</h2>\r\n<p>当目标函数<span class=\"math inline\">\\(f\\)</span>为二次型，且约束为线性约束时，该优化问题就是二次规划问题，一般形式表述如下： <span class=\"math display\">\\[\r\n\\underset {x}{min}f(x)=\\frac{x^TQx}{2}+q^Tx\r\n\\]</span> <span class=\"math display\">\\[\r\ns.t.Ax=b\r\n\\]</span> <span class=\"math display\">\\[\r\nGx\\leq h\r\n\\]</span></p>\r\n<p>二次规划是一类凸优化问题，目前有很多商业或者开源的求解器来求解这类问题。</p>\r\n<h1 id=\"多项式轨迹\">多项式轨迹</h1>\r\n<p>使用路径规划可以得到一系列的路径点，但这些路径点是不带时间<span class=\"math inline\">\\(t\\)</span>的，轨迹函数是以自变量为时间<span class=\"math inline\">\\(t\\)</span>的函数，一般用<span class=\"math inline\">\\(n\\)</span>阶多项式表示 <span class=\"math display\">\\[\r\np(t)=p_0t^0+p_1t^1+p_2t^2+\\cdots+p_nt^n=\\sum_{i=0}^{n}p_it^i\r\n\\]</span> 向量形式 <span class=\"math display\">\\[\r\np(t)=\\left[\\begin{matrix}\r\n1&amp;t&amp;\\cdots&amp;t^n \r\n\\end{matrix}\\right]\r\n\\left[\\begin{matrix}\r\np_0\\\\p_1\\\\\\vdots\\\\p_n \r\n\\end{matrix}\\right]\r\n\\]</span> 其中<span class=\"math inline\">\\(p_0,p_1,\\cdots,p_n\\)</span>是轨迹参数(n次多项式，有n+1个参数)，也是我们的优化参数。</p>\r\n<p>对轨迹函数进行求导，可以写出它的速度<span class=\"math inline\">\\(v\\)</span>、加速度<span class=\"math inline\">\\(a\\)</span>、jerk、snap等参数随时间变化的函数 <span class=\"math display\">\\[\r\nv(t)=p^{1}(t)=\\left[\\begin{matrix}\r\n0&amp;1&amp;2t&amp;3t^2&amp;4t^3\\cdots&amp;\\frac{n!}{(n-1)!}t^{n-1} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\na(t)=p^{(2)}(t)=\\left[\\begin{matrix}\r\n0&amp;0&amp;2&amp;6t&amp;12t^2&amp;\\cdots&amp;\\frac{n!}{(n-2)!}t^{n-2} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\njerk(t)=p^{(3)}(t)=\\left[\\begin{matrix}\r\n0&amp;0&amp;0&amp;6&amp;24t&amp;\\cdots&amp;\\frac{n!}{(n-3)!}t^{n-3} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nsnap(t)=p^{(4)}(t)=\\left[\\begin{matrix}\r\n0&amp;0&amp;0&amp;0&amp;24&amp;\\cdots&amp;\\frac{n!}{(n-4)!}t^{n-4} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(p=\\left[\\begin{matrix} p_0&amp;p_1&amp;\\cdots&amp;p_n \\end{matrix}\\right]^T\\)</span>，轨迹函数<span class=\"math inline\">\\(p(t)\\)</span>的导数通式为 <span class=\"math display\">\\[\r\np^{(k)}(t)=\\left[\\begin{matrix}\r\n\\overset{k}{\\overbrace{0\\cdots0}}&amp;\\overset{n-k+1}{\\overbrace{\\frac{(k+0)!}{(0)!}t^{0}\\quad\r\n\\frac{(k+1)!}{(1)!}t^{1}\\quad\\cdots\\quad\r\n\\frac{n!}{(n-k)!}t^{n-k}\r\n}} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span> 我们将一段复杂的轨迹按时间划分成<span class=\"math inline\">\\(m\\)</span>段，<span class=\"math inline\">\\(p_i=[p_{i_0},p_{i_1},\\cdots,p_{i_n}]^T\\)</span>为第<span class=\"math inline\">\\(i\\)</span>段轨迹的参数向量。</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{equation}\r\np(t) = \r\n\\begin{cases}\r\n[1,t,t^2,...,t^n]\\cdot p_1~~~t_0\\leq t&lt;t_1\\\\\r\n[1,t,t^2,...,t^n]\\cdot p_2~~~t_1\\leq t&lt;t_2\\\\\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\vdots\\\\\r\n[1,t,t^2,...,t^n]\\cdot p_m~~~t_{m-1}\\leq t&lt;t_m\\\\\r\n\\end{cases}\r\n\\end{equation}\r\n\\]</span></p>\r\n<h1 id=\"minimum-snap轨迹规划\">Minimum Snap轨迹规划</h1>\r\n<p>轨迹规划的目的：求轨迹的多项式参数<span class=\"math inline\">\\(p_1,\\cdots,p_m\\)</span></p>\r\n<h2 id=\"约束条件\">约束条件</h2>\r\n<p>基本要求：</p>\r\n<ol type=\"1\">\r\n<li>两段轨迹之间连续</li>\r\n<li>轨迹经过固定点</li>\r\n<li>轨迹无碰撞</li>\r\n</ol>\r\n<p>高级要求： 轨迹最顺滑、能量最优等</p>\r\n<h2 id=\"构建优化函数\">构建优化函数</h2>\r\n<p>通常满足约束条件的轨迹有无数条，而实际问题中，往往只需要特定的一条轨迹，所以还需要构建一个最优函数，方便在可行的轨迹中找出最优的轨迹。</p>\r\n<p>这是一个约束优化问题，形如： <span class=\"math display\">\\[\r\n\\min f(p)\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\ns.t.~~A_{eq}p = b_{eq},\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nA_{ieq}p \\leq b_{ieq}\r\n\\]</span></p>\r\n<p><code>Minimum Snap</code>顾名思义，最小化目标函数是<span class=\"math inline\">\\(Snap\\)</span>，当然也可以最小化Acceleration(加速度)或者Jerk，一般不会最小化速度。 <span class=\"math display\">\\[\r\nminimum~snap:~\\min f(p)=\\min (p^{(4)}(t))^2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nminimum~jerk:~\\min f(p)=\\min (p^{(3)}(t))^2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nminimum~a:~\\min f(p)=\\min (p^{(2)}(t))^2 \\\\\r\n\\]</span></p>\r\n<p><strong>Minimum Snap的优化函数为</strong> <span class=\"math display\">\\[\r\n\\min \\int _0^T(p^{(4)}(t))^2 {\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m \\int _{t_{i-1}}^{t_i}(p^{(4)}(t))^2 {\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m \\int _{t_{i-1}}^{t_i}   ([0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]\\cdot p)^T[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]\\cdot p~{\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m p^T\\int _{t_{i-1}}^{t_i}[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]^T[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]~{\\rm d}t~p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m p^TQ_ip\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min  p^TQp\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nQ_i = \\int _{t_{i-1}}^{t_i}[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]^T[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]~{\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\left[\\begin{matrix}\r\n0_{4\\times 4} &amp; 0_{4\\times (n-3)}\\\\\r\n0_{(n-3) \\times 4} &amp; \\frac{r!}{(r-4)!}\\frac{c!}{(c-4)!}\\frac{1}{(r-4)+(c-4)+1}(t_{i}^{(r+c-7)}-t_{i-1}^{(r+c-7)})\r\n\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><strong>注意：r,c为矩阵的行索引和列索引， 索引从0开始，即第一行r=0。这个Q<sub>i</sub>矩阵计算可太厉害了</strong> <span class=\"math display\">\\[\r\nQ = \\left[\\begin{matrix}\r\n        Q_1 &amp;&amp;&amp;\\\\\r\n        &amp;Q_2&amp;&amp;\\\\\r\n        &amp;&amp;\\ddots &amp;\\\\\r\n        &amp;&amp;&amp;Q_m\r\n    \\end{matrix}\\right]\r\n\\]</span></p>\r\n<h2 id=\"构建等式约束方程\">构建等式约束方程</h2>\r\n<p>1、设定某一个点的位置、速度、加速度为一个特定的值,可以构成一个等式约束。</p>\r\n<p>位置约束： <span class=\"math inline\">\\([1,t_0,t_0^2,\\cdots,t_0^n,\\underbrace{0\\cdots0}_{(m-1)(n+1)}]\\cdot p = p_0\\)</span></p>\r\n<p>速度约束： <span class=\"math inline\">\\([0,1,2t_0,\\cdots,nt_0^{n-1},\\underbrace{0\\cdots0}_{(m-1)(n+1)}]\\cdot p = v_0\\)</span></p>\r\n<p>加速度约束：<span class=\"math inline\">\\([0,0,2,\\cdots,n(n-1)t_0^{n-2},\\underbrace{0\\cdots0}_{(m-1)(n+1)}]\\cdot p = a_0\\)</span></p>\r\n<p>2、相邻段之间的位置、速度、加速度连续可以构成一个等式约束。对于有m+1个路径点的轨迹，一共有m段多项式轨迹，</p>\r\n<p>连续性约束：<span class=\"math inline\">\\([\\underbrace{0\\cdots0}_{(i-1)(n+1)},1,t_i,t_i^2,\\cdots,t_i^n,-1,-t_i,-t_i^2,\\cdots,-t_i^n,\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}]\\cdot p=0\\)</span></p>\r\n<p>3、合并所有等式约束， <span class=\"math display\">\\[\r\n\\begin{equation}\r\n\\left[\\begin{matrix}\r\n1,t_0,t_0^2,\\cdots,t_0^n,\\underbrace{0\\cdots0}_{(m-1)(n+1)}\\\\\r\n0,1,2t_0,\\cdots,nt_0^{n-1},\\underbrace{0\\cdots0}_{(m-1)(n+1)}\\\\\r\n0,0,2,\\cdots,n(n-1)t_0^{n-2},\\underbrace{0\\cdots0}_{(m-1)(n+1)}\\\\\r\n\\vdots\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,1,t_i,t_i^2,\\cdots,t_i^n,\\underbrace{0\\cdots0}_{(m-i)(n+1)}\\\\\r\n\\vdots\\\\\r\n\\underbrace{0\\cdots0}_{(m-1)(n+1)},1,t_m,t_m^2,\\cdots,t_m^n\\\\\r\n\\underbrace{0\\cdots0}_{(m-1)(n+1)},0,1,2t_m,\\cdots,nt_m^{n-1}\\\\\r\n\\underbrace{0\\cdots0}_{(m-1)(n+1)},0,0,2,\\cdots,n(n-1)t_m^{n-2}\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,1,t_i,t_i^2,\\cdots,t_i^n,-1,-t_i,-t_i^2,\\cdots,-t_i^n,\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,0,1,2t_i,\\cdots,nt_i^{n-1},-0,-1,-2t_i,\\cdots,-nt_i^{n-1},\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,0,0,2,\\cdots,\\frac{n!}{(n-2)!}t_i^{n-2},-0,-0,-2,\\cdots,-\\frac{n!}{(n-2)!}t_i^{n-2},\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}\\\\\r\n\\end{matrix}\\right]_{(4m+2)\\times (n+1)m}\r\n\\end{equation}p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\r\n\\left[\\begin{matrix}\r\np_0\\\\\r\nv_0\\\\\r\na_0\\\\\r\n\\vdots\\\\\r\np_i\\\\\r\n\\vdots\\\\\r\np_m\\\\\r\nv_m\\\\\r\na_m\\\\\r\n0\\\\\r\n\\vdots\\\\\r\n0\r\n\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><strong>等式约束个数=3{起点p<sub>0</sub>、v<sub>0</sub>、a<sub>0</sub>}+m-1{中间点的p<sub>i</sub>}+3{目标点p<sub>m</sub>、v<sub>m</sub>、a<sub>m</sub>}+3(m-1){中间点p<sub>i</sub>、v<sub>i</sub>、a<sub>i</sub>连续=0}=4m+2</strong></p>\r\n<h1 id=\"代码实现\">代码实现</h1>\r\n<p>生成x、y两个维度的轨迹，合并后如下图所示。包含起始终止共7个点，用6段多项式轨迹来描述，中间点也就是多项式轨迹之间的交界点。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515212657627.png\"  style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515212839998.png\"  style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p>Mellinger D, Kumar V. Minimum snap trajectory generation and control for quadrotors[C]//2011 IEEE international conference on robotics and automation. IEEE, 2011: 2520-2525.</p>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=10&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>机器人路径规划、轨迹优化系列课程</code></a></p>\r\n<p><a href=\"https://blog.csdn.net/q597967420/article/details/76099491\"><code>Minimum Snap轨迹规划详解（1）轨迹规划入门</code></a></p>\r\n",
            "tags": [
                "Matlab"
            ]
        }
    ]
}