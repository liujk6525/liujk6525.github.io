{
    "version": "https://jsonfeed.org/version/1",
    "title": "你不是单打独斗 • All posts by \"matlab\" tag",
    "description": "",
    "home_page_url": "https://liujk6525.github.io",
    "items": [
        {
            "id": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-%E9%97%AD%E5%BC%8F%E6%B1%82%E8%A7%A3/",
            "url": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-%E9%97%AD%E5%BC%8F%E6%B1%82%E8%A7%A3/",
            "title": "轨迹优化-闭式求解",
            "date_published": "2023-05-16T02:20:21.000Z",
            "content_html": "<p>如果<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/4269159\"><code>QP</code></a>问题只有等式约束，没有不等式约束，可以采用<a href=\"https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A7%A3\"><code>闭式求解</code></a>的方式。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"构建等式约束方程\">构建等式约束方程</h1>\r\n<p>还是一段复杂的轨迹按照时间划分成<span class=\"math inline\">\\(m\\)</span>段，一共有<span class=\"math inline\">\\(m+1\\)</span>个点，其中<span class=\"math inline\">\\(0\\)</span>是起点，<span class=\"math inline\">\\(m\\)</span>是目标点，<span class=\"math inline\">\\(m-1\\)</span>个中间点。每段多项式轨迹都构成 <span class=\"math display\">\\[\r\nA_ip_i=d_i,\\quad \r\nA_i=\\left[\\begin{matrix}\r\nA_0\\\\A_T\r\n\\end{matrix}\\right]_i,\\quad\r\nd_i=\\left[\\begin{matrix}\r\nd_0\\\\d_T\r\n\\end{matrix}\\right]_i\r\n\\]</span></p>\r\n<p>其中，<span class=\"math inline\">\\(d_o,d_T\\)</span>是第<span class=\"math inline\">\\(i\\)</span>段多项式轨迹的起点和终点的各阶导数组成的向量。这里只考虑了位置速度和加速度。 <span class=\"math display\">\\[\r\n\\underbrace{A_{total}}_{6m \\times m(n+1)}\r\n\\underbrace{\r\n\\left[ \\begin{matrix}\r\np_1 \\\\\r\n\\vdots \\\\\r\np_m \\\\\r\n\\end{matrix} \\right]}_{m(n+1) \\times 1} \r\n= \\left[ \\begin{matrix}\r\nd_1 \\\\\r\n\\vdots \\\\\r\nd_m \\\\\r\n\\end{matrix} \\right]\r\n=\\underbrace{\r\n\\left[ \\begin{matrix}\r\np_1(t_0)\\\\\r\nv_1(t_0)\\\\\r\na_1(t_0)\\\\\r\np_1(t_1)\\\\\r\nv_1(t_1)\\\\\r\na_1(t_1)\\\\\r\n\\vdots \\\\\r\np_m(t_{m-1})\\\\\r\nv_m(t_{m-1})\\\\\r\na_m(t_{m-1})\\\\\r\np_m(t_m)\\\\\r\nv_m(t_m)\\\\\r\na_m(t_m)\\\\\r\n\\end{matrix} \\right]}_{6m \\times 1}\r\n\\]</span> 目标是要求解参数<span class=\"math inline\">\\(p\\)</span> <span class=\"math display\">\\[\r\np=A^{-1}d\r\n\\]</span></p>\r\n<h2 id=\"消除重复变量\">消除重复变量</h2>\r\n<p>考虑到连续性(这里假设P、V、A连续)，向量中很多变量重复了 <span class=\"math display\">\\[\r\np_i(t_i)=p_{i+1}(t_i),~~v_i(t_i)=v_{i+1}(t_i),~~a_i(t_i)=a_{i+1}(t_i)\r\n\\]</span> 连续性约束不是直接加到等式约束方程中。而是通过一个映射矩阵<span class=\"math inline\">\\(M\\)</span>将一个变量映射到两个重复的变量上。 <span class=\"math display\">\\[\r\n\\underbrace{\r\n\\left[ \\begin{matrix}\r\nd_1 \\\\\r\n\\vdots \\\\\r\nd_k \\\\\r\n\\end{matrix} \\right]}_{6m\\times1}=\r\n\\underbrace{\r\n\\left[ \\begin{matrix}\r\n1\\\\\r\n&amp;1\\\\\r\n&amp;&amp;1\\\\\r\n&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;1\\\\\r\n&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\ddots\r\n\\end{matrix} \\right]}_{M}\r\n\\underbrace{\r\n\\left[\\begin{matrix} \r\np(t_0)\\\\\r\nv(t_0)\\\\\r\na(t_0)\\\\\r\np(t_1)\\\\\r\nv(t_1)\\\\\r\na(t_1)\\\\\r\np(t_2)\\\\\r\nv(t_2)\\\\\r\na(t_2)\\\\\r\n\\vdots\\\\\r\np(t_m)\\\\\r\nv(t_m)\\\\\r\na(t_m)\\\\\r\n\\end{matrix} \\right]}_{3(m+1)\\times 1}\r\n\\]</span> 即<span class=\"math inline\">\\(d=Md&#39;\\)</span></p>\r\n<h2 id=\"向量元素置换\">向量元素置换</h2>\r\n<p>接着把已知参数 <span class=\"math inline\">\\(d_F\\)</span>和未知参数<span class=\"math inline\">\\(d_P\\)</span>重新排列，可以左乘一个置换矩阵<span class=\"math inline\">\\(C\\)</span>，使得<span class=\"math inline\">\\(d&#39;=C\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\\)</span></p>\r\n<h2 id=\"转成无约束优化问题\">转成无约束优化问题</h2>\r\n<p>所以 <span class=\"math inline\">\\(d=MC\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\\)</span> <span class=\"math display\">\\[\r\np=A^{-1}d=\\underbrace{A^{-1}MC}_K\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right] = K\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\r\n\\]</span> 将<span class=\"math inline\">\\(p\\)</span>代入优化函数 <span class=\"math display\">\\[\r\n\\min p^TQp\\\\\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]^T\\underbrace{K^TQK}_R\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]^T\r\n\\left[\\begin{matrix}R_{FF} &amp; R_{FP}\\\\R_{PF}&amp;R_{PP}\\end{matrix}\\right]\r\n\\left[\\begin{matrix}d_F\\\\d_P\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=d_F^TR_{FF}d_F+d_F^TR_{FP}d_P+d_P^TR_{PF}d_F+d_P^TR_{PP}d_P\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=d_F^TR_{FF}d_F+2d_F^TR_{FP}d_P+d_P^TR_{PP}d_P\r\n\\]</span></p>\r\n<p>令优化函数<span class=\"math inline\">\\(mibn\\)</span>对<span class=\"math inline\">\\(d_P\\)</span>求导，并且令其导数等于0 <span class=\"math display\">\\[\r\n\\rightarrow 2d_F^TR_{FP}+2R_{PP}d_P=0\\quad(R_{PP}^T=R_{PP})\\\\\r\n\\rightarrow d^*_p = -R_{PP}^{-1}R_{FP}^Td_F\r\n\\]</span></p>\r\n<h1 id=\"总结\">总结</h1>\r\n<ol type=\"1\">\r\n<li><p>先确定轨迹阶数(这里是用的5阶，因为A矩阵要为方形阵，所以<span class=\"math inline\">\\(6m=m(n+1)\\rightarrow n=5\\)</span>)，再确定<span class=\"math inline\">\\(d\\)</span>中的约束量(p、v、a)，进而根据各段的时间分配求得<span class=\"math inline\">\\(A_{total}\\)</span></p></li>\r\n<li><p>根据连续性约束构造映射矩阵<span class=\"math inline\">\\(M\\)</span>，并确定<span class=\"math inline\">\\(d\\)</span>中哪些量是已知的(fix/specified)，哪些量是未知的(free/unspecified)，进而构造置换矩阵<span class=\"math inline\">\\(C\\)</span>，并求得<span class=\"math inline\">\\(K=A^{-1}MC\\)</span>。</p></li>\r\n<li><p>计算目标函数中的Q矩阵，并计算<span class=\"math inline\">\\(R=K^TQK\\)</span>，根据已知参数(fix)的长度将<span class=\"math inline\">\\(R\\)</span>拆分成<span class=\"math inline\">\\(R_{FF},R_{FR},R_{FR},R_{PP}\\)</span>四小块。</p></li>\r\n<li><p>根据<span class=\"math inline\">\\(d^*_p = -R_{PP}^{-1}R_{FP}^Td_F\\)</span>计算<span class=\"math inline\">\\(d^*_p\\)</span></p></li>\r\n<li><p>根据<span class=\"math inline\">\\(p=K\\left[\\begin{matrix}d_F\\\\d_p\\end{matrix}\\right]\\)</span>计算得到轨迹参数<span class=\"math inline\">\\(p\\)</span></p></li>\r\n</ol>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230516211818087.png\" style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230516211938320.png\"  style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p>Richter C, Bry A, Roy N. Polynomial trajectory planning for aggressive quadrotor flight in dense indoor environments[C]//Robotics Research: The 16th International Symposium ISRR. Springer International Publishing, 2016: 649-666.</p>\r\n<p><a href=\"https://blog.csdn.net/q597967420/article/details/79031791?spm=1001.2014.3001.5502\"><code>Minimum Snap轨迹规划详解（3）闭式求解</code></a></p>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=12&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>机器人路径规划、轨迹优化系列课程</code></a></p>\r\n",
            "tags": [
                "Matlab"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-MinimumSnap/",
            "url": "https://liujk6525.github.io/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-MinimumSnap/",
            "title": "轨迹优化-MinimumSnap",
            "date_published": "2023-05-15T06:16:00.000Z",
            "content_html": "<h1 id=\"基础知识\">基础知识</h1>\r\n<h2 id=\"二次型\">二次型</h2>\r\n<p>含有n个变量<span class=\"math inline\">\\(x=x_1,x_2,\\cdots,x_{n-1},x_{n}\\)</span>的二次齐次函数 <span class=\"math display\">\\[\r\nf(x_1,x_2,...,x_n)=a11x_1^2+a22x_2^2+\\cdots+a_{nn}x_n^2\r\n\\]</span> 称为二次型。取<span class=\"math inline\">\\(a_{ij}=a_{ji}\\)</span>，则有<span class=\"math inline\">\\(2a_{ij}x_ix_j=a_{ij}x_ix_j+a_{ji}x_jx_i\\)</span>，上式可表示为<span class=\"math inline\">\\(f(x)=\\sum_{i,j=1}^{n}a_{ij}x_ix_j\\)</span>。矩阵表示为<span class=\"math inline\">\\(f=x^TAx\\)</span></p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"二次规划quadratic-programming-qp\">二次规划(Quadratic Programming, <a href=\"https://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92\"><code>QP</code></a>)</h2>\r\n<p>当目标函数<span class=\"math inline\">\\(f\\)</span>为二次型，且约束为线性约束时，该优化问题就是二次规划问题，一般形式表述如下： <span class=\"math display\">\\[\r\n\\underset {x}{min}f(x)=\\frac{x^TQx}{2}+q^Tx\r\n\\]</span> <span class=\"math display\">\\[\r\ns.t.Ax=b\r\n\\]</span> <span class=\"math display\">\\[\r\nGx\\leq h\r\n\\]</span></p>\r\n<p>二次规划是一类凸优化问题，目前有很多商业或者开源的求解器来求解这类问题。</p>\r\n<h1 id=\"多项式轨迹\">多项式轨迹</h1>\r\n<p>使用路径规划可以得到一系列的路径点，但这些路径点是不带时间<span class=\"math inline\">\\(t\\)</span>的，轨迹函数是以自变量为时间<span class=\"math inline\">\\(t\\)</span>的函数，一般用<span class=\"math inline\">\\(n\\)</span>阶多项式表示 <span class=\"math display\">\\[\r\np(t)=p_0t^0+p_1t^1+p_2t^2+\\cdots+p_nt^n=\\sum_{i=0}^{n}p_it^i\r\n\\]</span> 向量形式 <span class=\"math display\">\\[\r\np(t)=\\left[\\begin{matrix}\r\n1&amp;t&amp;\\cdots&amp;t^n \r\n\\end{matrix}\\right]\r\n\\left[\\begin{matrix}\r\np_0\\\\p_1\\\\\\vdots\\\\p_n \r\n\\end{matrix}\\right]\r\n\\]</span> 其中<span class=\"math inline\">\\(p_0,p_1,\\cdots,p_n\\)</span>是轨迹参数(n次多项式，有n+1个参数)，也是我们的优化参数。</p>\r\n<p>对轨迹函数进行求导，可以写出它的速度<span class=\"math inline\">\\(v\\)</span>、加速度<span class=\"math inline\">\\(a\\)</span>、jerk、snap等参数随时间变化的函数 <span class=\"math display\">\\[\r\nv(t)=p^{1}(t)=\\left[\\begin{matrix}\r\n0&amp;1&amp;2t&amp;3t^2&amp;4t^3\\cdots&amp;\\frac{n!}{(n-1)!}t^{n-1} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\na(t)=p^{(2)}(t)=\\left[\\begin{matrix}\r\n0&amp;0&amp;2&amp;6t&amp;12t^2&amp;\\cdots&amp;\\frac{n!}{(n-2)!}t^{n-2} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\njerk(t)=p^{(3)}(t)=\\left[\\begin{matrix}\r\n0&amp;0&amp;0&amp;6&amp;24t&amp;\\cdots&amp;\\frac{n!}{(n-3)!}t^{n-3} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nsnap(t)=p^{(4)}(t)=\\left[\\begin{matrix}\r\n0&amp;0&amp;0&amp;0&amp;24&amp;\\cdots&amp;\\frac{n!}{(n-4)!}t^{n-4} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span></p>\r\n<p>其中<span class=\"math inline\">\\(p=\\left[\\begin{matrix} p_0&amp;p_1&amp;\\cdots&amp;p_n \\end{matrix}\\right]^T\\)</span>，轨迹函数<span class=\"math inline\">\\(p(t)\\)</span>的导数通式为 <span class=\"math display\">\\[\r\np^{(k)}(t)=\\left[\\begin{matrix}\r\n\\overset{k}{\\overbrace{0\\cdots0}}&amp;\\overset{n-k+1}{\\overbrace{\\frac{(k+0)!}{(0)!}t^{0}\\quad\r\n\\frac{(k+1)!}{(1)!}t^{1}\\quad\\cdots\\quad\r\n\\frac{n!}{(n-k)!}t^{n-k}\r\n}} \r\n\\end{matrix}\\right]\\cdot p\r\n\\]</span> 我们将一段复杂的轨迹按时间划分成<span class=\"math inline\">\\(m\\)</span>段，<span class=\"math inline\">\\(p_i=[p_{i_0},p_{i_1},\\cdots,p_{i_n}]^T\\)</span>为第<span class=\"math inline\">\\(i\\)</span>段轨迹的参数向量。</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{equation}\r\np(t) = \r\n\\begin{cases}\r\n[1,t,t^2,...,t^n]\\cdot p_1~~~t_0\\leq t&lt;t_1\\\\\r\n[1,t,t^2,...,t^n]\\cdot p_2~~~t_1\\leq t&lt;t_2\\\\\r\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\vdots\\\\\r\n[1,t,t^2,...,t^n]\\cdot p_m~~~t_{m-1}\\leq t&lt;t_m\\\\\r\n\\end{cases}\r\n\\end{equation}\r\n\\]</span></p>\r\n<h1 id=\"minimum-snap轨迹规划\">Minimum Snap轨迹规划</h1>\r\n<p>轨迹规划的目的：求轨迹的多项式参数<span class=\"math inline\">\\(p_1,\\cdots,p_m\\)</span></p>\r\n<h2 id=\"约束条件\">约束条件</h2>\r\n<p>基本要求：</p>\r\n<ol type=\"1\">\r\n<li>两段轨迹之间连续</li>\r\n<li>轨迹经过固定点</li>\r\n<li>轨迹无碰撞</li>\r\n</ol>\r\n<p>高级要求： 轨迹最顺滑、能量最优等</p>\r\n<h2 id=\"构建优化函数\">构建优化函数</h2>\r\n<p>通常满足约束条件的轨迹有无数条，而实际问题中，往往只需要特定的一条轨迹，所以还需要构建一个最优函数，方便在可行的轨迹中找出最优的轨迹。</p>\r\n<p>这是一个约束优化问题，形如： <span class=\"math display\">\\[\r\n\\min f(p)\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\ns.t.~~A_{eq}p = b_{eq},\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nA_{ieq}p \\leq b_{ieq}\r\n\\]</span></p>\r\n<p><code>Minimum Snap</code>顾名思义，最小化目标函数是<span class=\"math inline\">\\(Snap\\)</span>，当然也可以最小化Acceleration(加速度)或者Jerk，一般不会最小化速度。 <span class=\"math display\">\\[\r\nminimum~snap:~\\min f(p)=\\min (p^{(4)}(t))^2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nminimum~jerk:~\\min f(p)=\\min (p^{(3)}(t))^2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nminimum~a:~\\min f(p)=\\min (p^{(2)}(t))^2 \\\\\r\n\\]</span></p>\r\n<p><strong>Minimum Snap的优化函数为</strong> <span class=\"math display\">\\[\r\n\\min \\int _0^T(p^{(4)}(t))^2 {\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m \\int _{t_{i-1}}^{t_i}(p^{(4)}(t))^2 {\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m \\int _{t_{i-1}}^{t_i}   ([0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]\\cdot p)^T[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]\\cdot p~{\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m p^T\\int _{t_{i-1}}^{t_i}[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]^T[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]~{\\rm d}t~p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min \\sum_{i=1}^m p^TQ_ip\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\min  p^TQp\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nQ_i = \\int _{t_{i-1}}^{t_i}[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]^T[0,0,0,0,24,\\cdots,\\frac{n!}{(n-4!)}t^{n-4}]~{\\rm d}t\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\left[\\begin{matrix}\r\n0_{4\\times 4} &amp; 0_{4\\times (n-3)}\\\\\r\n0_{(n-3) \\times 4} &amp; \\frac{r!}{(r-4)!}\\frac{c!}{(c-4)!}\\frac{1}{(r-4)+(c-4)+1}(t_{i}^{(r+c-7)}-t_{i-1}^{(r+c-7)})\r\n\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><strong>注意：r,c为矩阵的行索引和列索引， 索引从0开始，即第一行r=0。这个Q<sub>i</sub>矩阵计算可太厉害了</strong> <span class=\"math display\">\\[\r\nQ = \\left[\\begin{matrix}\r\n        Q_1 &amp;&amp;&amp;\\\\\r\n        &amp;Q_2&amp;&amp;\\\\\r\n        &amp;&amp;\\ddots &amp;\\\\\r\n        &amp;&amp;&amp;Q_m\r\n    \\end{matrix}\\right]\r\n\\]</span></p>\r\n<h2 id=\"构建等式约束方程\">构建等式约束方程</h2>\r\n<p>1、设定某一个点的位置、速度、加速度为一个特定的值,可以构成一个等式约束。</p>\r\n<p>位置约束： <span class=\"math inline\">\\([1,t_0,t_0^2,\\cdots,t_0^n,\\underbrace{0\\cdots0}_{(m-1)(n+1)}]\\cdot p = p_0\\)</span></p>\r\n<p>速度约束： <span class=\"math inline\">\\([0,1,2t_0,\\cdots,nt_0^{n-1},\\underbrace{0\\cdots0}_{(m-1)(n+1)}]\\cdot p = v_0\\)</span></p>\r\n<p>加速度约束：<span class=\"math inline\">\\([0,0,2,\\cdots,n(n-1)t_0^{n-2},\\underbrace{0\\cdots0}_{(m-1)(n+1)}]\\cdot p = a_0\\)</span></p>\r\n<p>2、相邻段之间的位置、速度、加速度连续可以构成一个等式约束。对于有m+1个路径点的轨迹，一共有m段多项式轨迹，</p>\r\n<p>连续性约束：<span class=\"math inline\">\\([\\underbrace{0\\cdots0}_{(i-1)(n+1)},1,t_i,t_i^2,\\cdots,t_i^n,-1,-t_i,-t_i^2,\\cdots,-t_i^n,\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}]\\cdot p=0\\)</span></p>\r\n<p>3、合并所有等式约束， <span class=\"math display\">\\[\r\n\\begin{equation}\r\n\\left[\\begin{matrix}\r\n1,t_0,t_0^2,\\cdots,t_0^n,\\underbrace{0\\cdots0}_{(m-1)(n+1)}\\\\\r\n0,1,2t_0,\\cdots,nt_0^{n-1},\\underbrace{0\\cdots0}_{(m-1)(n+1)}\\\\\r\n0,0,2,\\cdots,n(n-1)t_0^{n-2},\\underbrace{0\\cdots0}_{(m-1)(n+1)}\\\\\r\n\\vdots\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,1,t_i,t_i^2,\\cdots,t_i^n,\\underbrace{0\\cdots0}_{(m-i)(n+1)}\\\\\r\n\\vdots\\\\\r\n\\underbrace{0\\cdots0}_{(m-1)(n+1)},1,t_m,t_m^2,\\cdots,t_m^n\\\\\r\n\\underbrace{0\\cdots0}_{(m-1)(n+1)},0,1,2t_m,\\cdots,nt_m^{n-1}\\\\\r\n\\underbrace{0\\cdots0}_{(m-1)(n+1)},0,0,2,\\cdots,n(n-1)t_m^{n-2}\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,1,t_i,t_i^2,\\cdots,t_i^n,-1,-t_i,-t_i^2,\\cdots,-t_i^n,\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,0,1,2t_i,\\cdots,nt_i^{n-1},-0,-1,-2t_i,\\cdots,-nt_i^{n-1},\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}\\\\\r\n\\underbrace{0\\cdots0}_{(i-1)(n+1)} ,0,0,2,\\cdots,\\frac{n!}{(n-2)!}t_i^{n-2},-0,-0,-2,\\cdots,-\\frac{n!}{(n-2)!}t_i^{n-2},\\underbrace{0\\cdots0}_{(m-i-1)(n+1)}\\\\\r\n\\end{matrix}\\right]_{(4m+2)\\times (n+1)m}\r\n\\end{equation}p\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\r\n\\left[\\begin{matrix}\r\np_0\\\\\r\nv_0\\\\\r\na_0\\\\\r\n\\vdots\\\\\r\np_i\\\\\r\n\\vdots\\\\\r\np_m\\\\\r\nv_m\\\\\r\na_m\\\\\r\n0\\\\\r\n\\vdots\\\\\r\n0\r\n\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><strong>等式约束个数=3{起点p<sub>0</sub>、v<sub>0</sub>、a<sub>0</sub>}+m-1{中间点的p<sub>i</sub>}+3{目标点p<sub>m</sub>、v<sub>m</sub>、a<sub>m</sub>}+3(m-1){中间点p<sub>i</sub>、v<sub>i</sub>、a<sub>i</sub>连续=0}=4m+2</strong></p>\r\n<h1 id=\"代码实现\">代码实现</h1>\r\n<p>生成x、y两个维度的轨迹，合并后如下图所示。包含起始终止共7个点，用6段多项式轨迹来描述，中间点也就是多项式轨迹之间的交界点。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515212657627.png\"  style=\"zoom:80%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515212839998.png\"  style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p>Mellinger D, Kumar V. Minimum snap trajectory generation and control for quadrotors[C]//2011 IEEE international conference on robotics and automation. IEEE, 2011: 2520-2525.</p>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=10&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>机器人路径规划、轨迹优化系列课程</code></a></p>\r\n<p><a href=\"https://blog.csdn.net/q597967420/article/details/76099491\"><code>Minimum Snap轨迹规划详解（1）轨迹规划入门</code></a></p>\r\n",
            "tags": [
                "Matlab"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "url": "https://liujk6525.github.io/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/",
            "title": "基于智能算法的路径规划",
            "date_published": "2023-05-15T00:38:42.000Z",
            "content_html": "<h1 id=\"基础知识\">基础知识</h1>\r\n<h2 id=\"遗传算法\">遗传算法</h2>\r\n<p>遗传算法(Genetic Algorithm,<a href=\"https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95\"><code>GA</code></a>)是一种智能优化算法，主要用来解决优化问题，其主要步骤为种群初始化、适应度函数计算、选择、交叉和变异。应用于移动机器人路径规划时其主要步骤相同。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"算法步骤\">算法步骤</h2>\r\n<p>选择初始生命种群</p>\r\n<ol type=\"1\">\r\n<li>每行选择一个栅格</li>\r\n<li>判断相邻栅格是否连续</li>\r\n<li>不连续时选择栅格进行插入，直到连续</li>\r\n</ol>\r\n<p>循环</p>\r\n<ul>\r\n<li><p>评价种群中的个体适应度fitness</p></li>\r\n<li><p>以比例原则(分数高的挑中几率也较高)选择产生下一个种群(轮盘法、竞争法及等级轮盘法)。</p>\r\n<p><strong>选择</strong></p>\r\n<p>是按照轮盘法来选择的个体 <span class=\"math display\">\\[\r\nd =\\sum_{i=1}^{end-1}{\\sqrt{(x_{i+1}-x{i})^{2}+(y_{i+1}-y_{i})^{2}}}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nfit_1=1/d\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nfit_2=acrccos(\\frac{(b^2+c^2-a^2)}{2bc})\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nfit=fit_1+fit_2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\np_i=\\frac{fit_i}{\\sum_{i=1}^{end}fit_i}\r\n\\]</span></p></li>\r\n<li><p>改变该种群(选择、交叉和变异)</p>\r\n<p><strong>交叉</strong></p>\r\n<p>如下图所示，当两个个体{0|6|7|13|19|24}和{0|1|2|3|8|13|18|24}在栅格13处交叉，经过交叉操作后会生成新的个体{0|6|7|13|18|24}和{0|1|2|3|8|13|19|24}</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515103232016.png\"  style=\"zoom:80%;\" /></p>\r\n<p><strong>变异</strong></p>\r\n<p>如下图所示，当个体{0|1|2|3|8|13|18|24}经过变异操作后会随机生成新的个体{0|1|7|13|18|24}</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515103809856.png\"  style=\"zoom:80%;\" /></p></li>\r\n<li><p>直到停止循环的条件满足</p></li>\r\n</ul>\r\n<h1 id=\"代码实现\">代码实现</h1>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230515104419609.png\"  style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1yT4y1T7Eb?p=8&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>机器人路径规划、轨迹优化课程</code></a></p>\r\n",
            "tags": [
                "Matlab"
            ]
        },
        {
            "id": "https://liujk6525.github.io/TSP%E9%97%AE%E9%A2%98/%E5%9F%BA%E4%BA%8E%E6%B7%B7%E5%90%88%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95%E7%9A%84TSP%E7%AE%97%E6%B3%95/",
            "url": "https://liujk6525.github.io/TSP%E9%97%AE%E9%A2%98/%E5%9F%BA%E4%BA%8E%E6%B7%B7%E5%90%88%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95%E7%9A%84TSP%E7%AE%97%E6%B3%95/",
            "title": "基于混合粒子群算法的TSP算法",
            "date_published": "2023-05-10T13:10:59.000Z",
            "content_html": "<h1 id=\"理论基础\">理论基础</h1>\r\n<h2 id=\"基本粒子群算法\">基本粒子群算法</h2>\r\n<p>粒子群算法，也称粒子群优化算法或鸟群觅食算法（Particle Swarm Optimization，PSO），它通过追随当前搜索到的最优值来寻找全局最优。这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"基本原理\">基本原理</h3>\r\n<p>PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值(fitness value)，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。</p>\r\n<p>粒子位置的更新方式如下所示</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511062229130.png\" alt=\"粒子位置额更新方式\" style=\"zoom: 67%;\" /></p>\r\n<p><span class=\"math inline\">\\(PSO\\)</span>初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次迭代中，粒子通过跟踪两个“极值”来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值P<sub>best</sub>。另一个极值是整个种群目前找到的最优解，这个极值是全局极值g<sub>best</sub>。另外也可以不用整个种群而只是用其中一部分作为粒子的邻居，那么在所有邻居中的极值就是局部极值。</p>\r\n<p>假设在一个D维的目标搜索空间中，有N个粒子组成一个种群，其中</p>\r\n<p>第i个粒子为一个D维的向量 <span class=\"math display\">\\[\r\nX_i = (x_{i1},x_{i2},x_{i3},...x_{iD}),\\quad i=1,2,3,...,N\r\n\\]</span> 第i个粒子的“飞行”速度也是一个D维的向量 <span class=\"math display\">\\[\r\nV_i = (v_{i1},v_{i2},v_{i3},...v_{iD}),\\quad i=1,2,3,...,N\r\n\\]</span> 第i个粒子迄今为止搜索到的最优位置称为个体极值 <span class=\"math display\">\\[\r\nP_{best}=(p_{i1},p_{i2},p_{i3},...p_{iD}),\\quad i=1,2,3,...,N\r\n\\]</span> 整个粒子群迄今为止搜索到的最优位置称为全局极值 <span class=\"math display\">\\[\r\ng_{best}=(p_{g1},p_{g2},p_{g3},...p_{gD})\r\n\\]</span> 在找到这两个最优值时，粒子根据如下公式更新自己的速度和位置 <span class=\"math display\">\\[\r\nv_{id}=w*v_{id}+c_1r_1(p_{id}-x_{id})+c_2r_2(p_{gd}-x_{id})\\\\\r\nx_{id}=x_{id}+v_{id}\r\n\\]</span></p>\r\n<p>式中，w为惯性权重(inertia weight)，c<sub>1</sub>,c<sub>2</sub>为学习因子，也称为加速常量(acceleration constants)，r<sub>1</sub>r<sub>2</sub>为[0,1]范围内的均匀随机数</p>\r\n<p>w*v<sub>id</sub> 为“惯性”或者”动量“部分，反映了粒子的运动习惯，代表粒子有维持自己先前速度的趋势。</p>\r\n<p>c<sub>1</sub>r<sub>1</sub>(p<sub>id</sub>-x<sub>id</sub>)为“认知”部分，反映了粒子对自身历史经验的记忆或回忆，代表了粒子有向自身历史最佳位置逼近的趋势。</p>\r\n<p>c<sub>2</sub>r<sub>2</sub>(p<sub>gd</sub>-x<sub>id</sub>)为“社会”部分，反映了粒子间协同合作与知识共享的群体历史经验，代表了粒子有向群体或邻域历史最佳位置逼近的趋势。</p>\r\n<h3 id=\"pso算法的流程\">PSO算法的流程</h3>\r\n<ol type=\"1\">\r\n<li>初始化粒子群，包括群体规模N，每个粒子的位置x<sub>i</sub>和速度v<sub>i</sub>；</li>\r\n<li>计算每个粒子的适应度Fitness(i)；</li>\r\n<li>对每个粒子，将其适应值Fitness(i)与其经过的最优值P<sub>best</sub>(i)作比较，如果较好，则将其替换掉原来的P<sub>best</sub>(i)；</li>\r\n<li>对每个粒子，将其适应值Fitness(i)与其经过的全局最优值g<sub>best</sub>(i)作比较，如果较好，则将其替换掉原来的g<sub>best</sub>(i)；</li>\r\n<li>根据公式更新粒子的速度v<sub>i</sub>和位置x<sub>i</sub>；</li>\r\n<li>如果满足结束条件退出，否则返回第2步。</li>\r\n</ol>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511055154081.png\" alt=\"PSO算法流程图\" style=\"zoom:80%;\" /></p>\r\n<h2 id=\"混合粒子群算法\">混合粒子群算法</h2>\r\n<p>标准粒子群算法通过追随个体极值和群体极值完成极值寻优，虽然操作简单，且能够快速收敛，但是随着迭代次数的不断增加，在种群收敛集中的同时，各粒子也越来越相似，可能在局部最优解周边无法跳出。</p>\r\n<p>混合粒子群算法摒弃了传统粒子群算法中的通过跟踪极值来更新粒子位置的方法，而是引入了<code>遗传算法</code>中的交叉和变异操作，通过粒子同个体极值和群体极值的交叉以及粒子自身变异的方式来搜索最优解。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511070402553.png\" alt=\"混合粒子群算法流程图\" style=\"zoom:80%;\" /></p>\r\n<h1 id=\"问题描述\">问题描述</h1>\r\n<p>TSP问题，具体描述参考<a href=\"https://liujk6525.github.io/posts/15650/\"><code>基于遗传算法的TSP算法</code></a>，这边不在赘叙。</p>\r\n<h1 id=\"代码实现\">代码实现</h1>\r\n<h2 id=\"适应值变化\">适应值变化</h2>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511154328042.png\" alt=\"适应值变化图\" style=\"zoom:80%;\" /></p>\r\n<h2 id=\"苹果位置图\">苹果位置图</h2>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511160009530.png\" alt=\"苹果分布图\" style=\"zoom:80%;\" /></p>\r\n<h2 id=\"路径规划图\">路径规划图</h2>\r\n<p>​ <img src=\"/imgs/$%7Bfiilename%7D/image-20230511154532035.png\" alt=\"路径规划图\" style=\"zoom: 80%;\" /></p>\r\n<h2 id=\"最优解\">最优解</h2>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511155618486.png\" alt=\"最优解\" style=\"zoom:80%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p>[1]史峰. MATLAB智能算法30个案例分析[M]. 北京航空航天大学出版社, 2011.</p>\r\n",
            "tags": [
                "Matlab",
                "路径规划"
            ]
        },
        {
            "id": "https://liujk6525.github.io/TSP%E9%97%AE%E9%A2%98/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84TSP%E7%AE%97%E6%B3%95/",
            "url": "https://liujk6525.github.io/TSP%E9%97%AE%E9%A2%98/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84TSP%E7%AE%97%E6%B3%95/",
            "title": "基于遗传算法的TSP算法",
            "date_published": "2023-05-07T08:48:51.000Z",
            "content_html": "<h2 id=\"理论基础\">理论基础</h2>\r\n<h3 id=\"遗传算法\">遗传算法</h3>\r\n<p>遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法。 <span id=\"more\"></span></p>\r\n<h3 id=\"tsp问题\">TSP问题</h3>\r\n<p>TSP (traveling salesman problem,旅行商问题) 是典型的NP完全问题，即其最坏情况下的时间复杂度随着问题规模的增大按指数方式增长，到目前为止还未找到一个多项式时间的有效算法。</p>\r\n<p>​ TSP问题可描述为：已知n个城市相互之间的距离，某一旅行商从某个城市出发访问每个城市一次且仅一次，最后回到出发城市，如何安排才使其所走路线最短。简言之，就是寻找一条最短的遍历n个城市的路径，或者说搜索自然子集X={1,2,….n} ( X的元素表示对n个 城市的编号 ) 的一个排列π(X)={V<sub>1</sub>,V<sub>2</sub>,…,V<sub>n</sub>},使 <span class=\"math display\">\\[\r\nT_d = \\sum_{i=1}^{n-1}{d(V_i,V_(i+1))}+d(V_n,V_1)\r\n\\]</span> 取最小值，其中 <span class=\"math display\">\\[\r\nd(V_i,V_i+1)\r\n\\]</span> 表示城市V<sub>i</sub>到城市V<sub>i+1</sub>的距离。 ## 问题描述</p>\r\n<p>通过搭建的双目视觉检测系统将苹果的三维坐标获取到后，需要对其进行路径规划，即寻找出一条最短的遍历所有目标苹果的路径</p>\r\n<p>表1 14个苹果的位置坐标</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>目标苹果编号</th>\r\n<th>X坐标</th>\r\n<th>Y坐标</th>\r\n<th>Z坐标</th>\r\n<th>目标苹果编号</th>\r\n<th>X坐标</th>\r\n<th>Y坐标</th>\r\n<th>Z坐标</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>1</td>\r\n<td>16.47</td>\r\n<td>96.10</td>\r\n<td>45.25</td>\r\n<td>8</td>\r\n<td>17.20</td>\r\n<td>96.29</td>\r\n<td>48.62</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>2</td>\r\n<td>16.47</td>\r\n<td>94.44</td>\r\n<td>44.25</td>\r\n<td>9</td>\r\n<td>16.30</td>\r\n<td>97.38,</td>\r\n<td>42.98</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>3</td>\r\n<td>20.09</td>\r\n<td>92.54</td>\r\n<td>45.63</td>\r\n<td>10</td>\r\n<td>14.05</td>\r\n<td>98.12,</td>\r\n<td>41.86</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>4</td>\r\n<td>22.39</td>\r\n<td>93.37</td>\r\n<td>47.21</td>\r\n<td>11</td>\r\n<td>16.53</td>\r\n<td>97.38</td>\r\n<td>,48.52</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>5</td>\r\n<td>25.23</td>\r\n<td>97.24</td>\r\n<td>44.29</td>\r\n<td>12</td>\r\n<td>21.52</td>\r\n<td>95.59</td>\r\n<td>46.25</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>6</td>\r\n<td>22.00</td>\r\n<td>96.05</td>\r\n<td>48.45</td>\r\n<td>13</td>\r\n<td>19.41</td>\r\n<td>97.13</td>\r\n<td>45.71</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>7</td>\r\n<td>20.47</td>\r\n<td>97.02</td>\r\n<td>47.56</td>\r\n<td>14</td>\r\n<td>20.09</td>\r\n<td>92.55</td>\r\n<td>44.44</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"解决思路及步骤\">解决思路及步骤</h2>\r\n<p>遗传算法TSP问题的流程图</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230510164303229.png\"  style=\"zoom:80%;\" /></p>\r\n<ol type=\"1\">\r\n<li>编码</li>\r\n</ol>\r\n<p>​ 对于n个苹果的TSP问题，染色体分为n段，例如检测到10个苹果{1,2,3,4,5,6,7,8,9,10}，则|1|0|2|4|5|6|8|7|9|3就是一个合法的染色体。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>种群初始化</li>\r\n</ol>\r\n<p>​ 编码后，需要初始化一个种群作为起始解，初始化种群的数目一般根据经验得到，种群的数量按苹果的规模确定，参考的取值为50~200。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>适应度函数</li>\r\n</ol>\r\n<p>​ 设k<sub>1</sub>|k<sub>2</sub>|k<sub>i</sub>|…|k<sub>n</sub>|为一个采用整数编码的染色体，d(k<sub>i</sub>,k<sub>j</sub>)为苹果k<sub>i</sub>到苹果k<sub>j</sub>的欧式距离，则该个体的适应度为 <span class=\"math display\">\\[\r\nfitness = \\frac{1}{\\sum_{i=1}^{n-1}{d(K_i,K_(i+1))}+d(K_n,K_1)}\r\n\\]</span> 即适应度函数恰好遍历了n个苹果，再回到第一个苹果的距离的倒数。优化的目标就是选择适应度函数值尽可能大的染色体。</p>\r\n<ol start=\"4\" type=\"1\">\r\n<li>选择操作</li>\r\n</ol>\r\n<p>​ 从旧群体中以一定概率选择个体到新群体中，个体被选中的概率跟适应度值有关，个体适应度值越大，被选中的概率越大。</p>\r\n<ol start=\"5\" type=\"1\">\r\n<li>交又操作 部分映射杂交，确定交叉操作的父代，将父代样本两两分组，每组重复以下过程。</li>\r\n</ol>\r\n<p>​ 假定城市数为10)，产生两个[1,10]区间内的随机整数和r<sub>1</sub>和r<sub>2</sub>，确定两个位置，对两位置的中间数据进行交叉，如r<sub>1</sub>=4,r<sub>2</sub>=7 (其实就是把四和七中间的位置给互换，包括四七位置本身)</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">1</th>\r\n<th style=\"text-align: center;\">2</th>\r\n<th style=\"text-align: center;\">3</th>\r\n<th style=\"text-align: center;\">4</th>\r\n<th style=\"text-align: center;\">5</th>\r\n<th style=\"text-align: center;\">6</th>\r\n<th style=\"text-align: center;\">7</th>\r\n<th style=\"text-align: center;\">8</th>\r\n<th style=\"text-align: center;\">9</th>\r\n<th style=\"text-align: center;\">10</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">9</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">3</td>\r\n<td style=\"text-align: center;\">7</td>\r\n<td style=\"text-align: center;\">4</td>\r\n<td style=\"text-align: center;\">2</td>\r\n<td style=\"text-align: center;\">10</td>\r\n<td style=\"text-align: center;\">8</td>\r\n<td style=\"text-align: center;\">6</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">10</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\">4</td>\r\n<td style=\"text-align: center;\">6</td>\r\n<td style=\"text-align: center;\">3</td>\r\n<td style=\"text-align: center;\">8</td>\r\n<td style=\"text-align: center;\">7</td>\r\n<td style=\"text-align: center;\">2</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">9</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>交叉后为</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">1</th>\r\n<th style=\"text-align: center;\">2</th>\r\n<th style=\"text-align: center;\">3</th>\r\n<th style=\"text-align: center;\">4</th>\r\n<th style=\"text-align: center;\">5</th>\r\n<th style=\"text-align: center;\">6</th>\r\n<th style=\"text-align: center;\">7</th>\r\n<th style=\"text-align: center;\">8</th>\r\n<th style=\"text-align: center;\">9</th>\r\n<th style=\"text-align: center;\">10</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">9</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\"><em>1</em></td>\r\n<td style=\"text-align: center;\"><em>6</em></td>\r\n<td style=\"text-align: center;\"><em>3</em></td>\r\n<td style=\"text-align: center;\"><em>8</em></td>\r\n<td style=\"text-align: center;\">7</td>\r\n<td style=\"text-align: center;\">10</td>\r\n<td style=\"text-align: center;\">*</td>\r\n<td style=\"text-align: center;\">*</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">10</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\">*</td>\r\n<td style=\"text-align: center;\"><em>3</em></td>\r\n<td style=\"text-align: center;\"><em>7</em></td>\r\n<td style=\"text-align: center;\"><em>4</em></td>\r\n<td style=\"text-align: center;\"><em>2</em></td>\r\n<td style=\"text-align: center;\">*</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">9</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>从表格中可以看到：同一个个体中有重复的编号，处理办法就是把不重复的数据保留，有重复的数据采用部分映射的方法消除冲突。就是利用四七段的映射关系来确定，比如第一个个体的九位置，它本来的数据是8的，现在这个数据8跑到六位置了，而原来的六位置的数据是4，所以现在的九位置变成4，最后在看这个个体缺少哪个数据，给补上就是了。</p>\r\n<ol start=\"6\" type=\"1\">\r\n<li>变异操作</li>\r\n</ol>\r\n<p>​ 随机选取两个点，将其对换位置。</p>\r\n<p>​ 产生两个[1,10]范围内的随机整数r<sub>1</sub>和r<sub>2</sub>，确定两个位置，将其对换位置，如r<sub>1</sub>=4,r<sub>2</sub>=7</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">1</th>\r\n<th style=\"text-align: center;\">2</th>\r\n<th style=\"text-align: center;\">3</th>\r\n<th style=\"text-align: center;\">4</th>\r\n<th style=\"text-align: center;\">5</th>\r\n<th style=\"text-align: center;\">6</th>\r\n<th style=\"text-align: center;\">7</th>\r\n<th style=\"text-align: center;\">8</th>\r\n<th style=\"text-align: center;\">9</th>\r\n<th style=\"text-align: center;\">10</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">9</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">3</td>\r\n<td style=\"text-align: center;\">7</td>\r\n<td style=\"text-align: center;\">4</td>\r\n<td style=\"text-align: center;\">2</td>\r\n<td style=\"text-align: center;\">10</td>\r\n<td style=\"text-align: center;\">8</td>\r\n<td style=\"text-align: center;\">6</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>变异后为</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>1</th>\r\n<th>2</th>\r\n<th>3</th>\r\n<th>4</th>\r\n<th>5</th>\r\n<th>6</th>\r\n<th>7</th>\r\n<th>8</th>\r\n<th>9</th>\r\n<th>10</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>9</td>\r\n<td>5</td>\r\n<td>1</td>\r\n<td><em>2</em></td>\r\n<td>7</td>\r\n<td>4</td>\r\n<td><em>3</em></td>\r\n<td>10</td>\r\n<td>8</td>\r\n<td>6</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ol start=\"7\" type=\"1\">\r\n<li>逆转操作</li>\r\n</ol>\r\n<p>​ 为改善遗传算法的局部搜索能力。这里的“进化”是指逆转算子的单方向性，即只有经逆转后，适应度值有提高的才接受下来，否则逆转无效。</p>\r\n<p>​ 产生两个[1,10]区间内的随机整数片r<sub>1</sub>和r<sub>2</sub>，确定两个位置，将其对换位置，如r<sub>1</sub>=4，r<sub>2</sub>=7</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">1</th>\r\n<th style=\"text-align: center;\">2</th>\r\n<th style=\"text-align: center;\">3</th>\r\n<th style=\"text-align: center;\">4</th>\r\n<th style=\"text-align: center;\">5</th>\r\n<th style=\"text-align: center;\">6</th>\r\n<th style=\"text-align: center;\">7</th>\r\n<th style=\"text-align: center;\">8</th>\r\n<th style=\"text-align: center;\">9</th>\r\n<th style=\"text-align: center;\">10</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">9</td>\r\n<td style=\"text-align: center;\">5</td>\r\n<td style=\"text-align: center;\">1</td>\r\n<td style=\"text-align: center;\">3</td>\r\n<td style=\"text-align: center;\">7</td>\r\n<td style=\"text-align: center;\">4</td>\r\n<td style=\"text-align: center;\">2</td>\r\n<td style=\"text-align: center;\">10</td>\r\n<td style=\"text-align: center;\">8</td>\r\n<td style=\"text-align: center;\">6</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>逆转后</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>1</th>\r\n<th>2</th>\r\n<th>3</th>\r\n<th>4</th>\r\n<th>5</th>\r\n<th>6</th>\r\n<th>7</th>\r\n<th>8</th>\r\n<th>9</th>\r\n<th>10</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>9</td>\r\n<td>5</td>\r\n<td>1</td>\r\n<td><em>4</em></td>\r\n<td><em>7</em></td>\r\n<td><em>3</em></td>\r\n<td>2</td>\r\n<td>10</td>\r\n<td>8</td>\r\n<td>6</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>​ 对每个个体进行交叉变异，然后代人适应度函数进行评估，选择出适应值大的个体进行下一代的交叉和变异以及逆转操作。</p>\r\n<p>循环操作：判断是否满足设定的最大遗传代数,不满足则跳入适应度值的计算；否则，结束遗传操作。</p>\r\n<h2 id=\"代码实现\">代码实现</h2>\r\n<h3 id=\"适应值变化\">适应值变化</h3>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230510183559745.png\"  style=\"zoom:80%;\" /></p>\r\n<h3 id=\"苹果位置图\">苹果位置图</h3>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230510185112226.png\"  style=\"zoom:80%;\" /></p>\r\n<h3 id=\"路径规划图\">路径规划图</h3>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511155819983.png\"  style=\"zoom:80%;\" /></p>\r\n<h2 id=\"最优解\">最优解</h2>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230511155901209.png\"  style=\"zoom:80%;\" /></p>\r\n<hr />\r\n<h2 id=\"参考文献\">参考文献</h2>\r\n<p>[1]史峰. MATLAB智能算法30个案例分析[M]. 北京航空航天大学出版社, 2011.</p>\r\n",
            "tags": [
                "Matlab",
                "路径规划"
            ]
        }
    ]
}