{
    "version": "https://jsonfeed.org/version/1",
    "title": "你不是单打独斗 • All posts by \"jupyter notebook\" tag",
    "description": "",
    "home_page_url": "https://liujk6525.github.io",
    "items": [
        {
            "id": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/",
            "url": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/",
            "title": "集成学习",
            "date_published": "2023-06-07T01:32:09.000Z",
            "content_html": "<h1 id=\"集成学习ensemble-learning\"><a href=\"https://baike.baidu.com/item/%E5%88%86%E7%B1%BB%E5%99%A8%E9%9B%86%E6%88%90/21512231?fromtitle=%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0&amp;fromid=3440721&amp;fr=aladdin\">集成学习（Ensemble Learning）</a></h1>\r\n<p>集成学习就是组合多个学习器，最后可以得到一个更 好的学习器。</p>\r\n<p>集成学习算法：</p>\r\n<ol type=\"1\">\r\n<li><p>个体学习器之间不存在强依赖关系，装袋（Bagging）</p></li>\r\n<li><p>随机森林（Random Forest）</p></li>\r\n<li><p>个体学习器之间存在强依赖关系，提升（Boosting）</p></li>\r\n<li><p>Stacking</p></li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<h2 id=\"bagging\">Bagging</h2>\r\n<p>Bagging也叫做Bootstrap Aggregating，是在原始 数据集选择S次后得到S个新数据集的一种技术。是一 种有放回抽样。</p>\r\n<p>原始训练数据集<span class=\"math inline\">\\(0,1,2,3,4,5,6,7,8,9\\)</span></p>\r\n<p>Bagging采样<span class=\"math inline\">\\(1,3,5,2,6,4,2,5,7,0——未采样8,9\\)</span></p>\r\n<h3 id=\"示例代码\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入算法包以及数据集</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> neighbors</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.ensemble <span class=\"keyword\">import</span> BaggingClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> tree</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\">划分数据集</span><br><span class=\"line\">iris = datasets.load_iris()</span><br><span class=\"line\">x_data = iris.data[:,:<span class=\"number\">2</span>]</span><br><span class=\"line\">y_data = iris.target</span><br><span class=\"line\"></span><br><span class=\"line\">x_train,x_test,y_train,y_test = train_test_split(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并训练KNN模型</span></span><br><span class=\"line\">knn = neighbors.KNeighborsClassifier()</span><br><span class=\"line\">knn.fit(x_train, y_train)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot</span>(<span class=\"params\">model</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 获取数据值所在的范围</span></span><br><span class=\"line\">    x_min, x_max = x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\">    y_min, y_max = x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 生成网格矩阵</span></span><br><span class=\"line\">    xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">                         np.arange(y_min, y_max, <span class=\"number\">0.02</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class=\"comment\"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class=\"line\">    z = z.reshape(xx.shape)</span><br><span class=\"line\">    <span class=\"comment\"># 等高线图</span></span><br><span class=\"line\">    cs = plt.contourf(xx, yy, z)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plot(knn)</span><br><span class=\"line\"><span class=\"comment\"># 样本散点图</span></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&quot;knn&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\">knn.score(x_test, y_test) <span class=\"comment\"># KNN模型准确率</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并训练bagging_knn模型</span></span><br><span class=\"line\">bagging_knn = BaggingClassifier(knn, n_estimators=<span class=\"number\">100</span>)</span><br><span class=\"line\">bagging_knn.fit(x_train, y_train)</span><br><span class=\"line\">plot(bagging_knn)</span><br><span class=\"line\"><span class=\"comment\"># 样本散点图</span></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;bagging_knn&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\">bagging_knn.score(x_test, y_test) <span class=\"comment\"># bagging_knn模型准确率</span></span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607113057905.png\"  style=\"zoom:50%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607113349947.png\"  style=\"zoom:50%;\" /></p>\r\n<h2 id=\"随机森林random-forest\"><a href=\"https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/1974765?fr=aladdin\">随机森林（Random Forest）</a></h2>\r\n<p>算法流程：</p>\r\n<ol type=\"1\">\r\n<li><p>随机选取样本：在样本集用<strong>bagging</strong>的方式随机选择n个样本。</p></li>\r\n<li><p>随机选取特征：从所有属性d中随机选择k个属性（k&lt;d），然后从k个属性中选择最佳分割属性作为节点建立 CART决策树。</p></li>\r\n<li><p>重复以上两个步骤m次，建立m棵CART决策树。</p></li>\r\n<li><p>这m棵CART决策树形成随机森林，通过投票表决结 果，决定数据属于哪一类。</p></li>\r\n</ol>\r\n<h3 id=\"示例代码-1\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> tree</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.ensemble <span class=\"keyword\">import</span> RandomForestClassifier <span class=\"comment\"># 集成学习中的随机森林模块</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">data = np.genfromtxt(<span class=\"string\">&quot;LR-testSet2.txt&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">x_data = data[:,:-<span class=\"number\">1</span>]</span><br><span class=\"line\">y_data = data[:,-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">plt.scatter(x_data[:,<span class=\"number\">0</span>],x_data[:,<span class=\"number\">1</span>],c=y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 划分数据集</span></span><br><span class=\"line\">x_train,x_test,y_train,y_test = train_test_split(x_data, y_data, test_size = <span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot</span>(<span class=\"params\">model</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 获取数据值所在的范围</span></span><br><span class=\"line\">    x_min, x_max = x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\">    y_min, y_max = x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 生成网格矩阵</span></span><br><span class=\"line\">    xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">                         np.arange(y_min, y_max, <span class=\"number\">0.02</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class=\"comment\"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class=\"line\">    z = z.reshape(xx.shape)</span><br><span class=\"line\">    <span class=\"comment\"># 等高线图</span></span><br><span class=\"line\">    cs = plt.contourf(xx, yy, z)</span><br><span class=\"line\">    <span class=\"comment\"># 样本散点图</span></span><br><span class=\"line\">    plt.scatter(x_test[:, <span class=\"number\">0</span>], x_test[:, <span class=\"number\">1</span>], c=y_test)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并训练随机森林模型</span></span><br><span class=\"line\">RF = RandomForestClassifier(n_estimators=<span class=\"number\">50</span>)</span><br><span class=\"line\">RF.fit(x_train, y_train)</span><br><span class=\"line\">plot(RF)</span><br><span class=\"line\">RF.score(x_test, y_test)</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607114037530.png\"  style=\"zoom:50%;\" /></p>\r\n<h2 id=\"boosting\"><a href=\"https://baike.baidu.com/item/Boosting/1403912?fr=aladdin\">Boosting</a></h2>\r\n<p>AdaBoost （Adaptive Boosting）算法，它的自适应在于，前一个基本分类器被错误分类的样本的权值会增大，而正确分类的样本的权值会减小，并再次用来训练下一个基本分类器。同时，在每一轮迭代中，加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数才确定最终的强分类器。</p>\r\n<p>算法流程：</p>\r\n<ol type=\"1\">\r\n<li><p>初始化训练数据的权值分布<span class=\"math inline\">\\(D1\\)</span>。假设有<span class=\"math inline\">\\(N\\)</span>个训练样本数据，则每一个训练样本最开始时，都被赋予 相同的权值<span class=\"math inline\">\\(w~1~=1/N\\)</span>。</p></li>\r\n<li><p>训练弱分类器<span class=\"math inline\">\\(h_i\\)</span>。</p>\r\n<ul>\r\n<li><p>如果某个训练样本点，被弱分类器<span class=\"math inline\">\\(h_i\\)</span>准确地分类，那么在构造下一个训练集中，它对应的权值要减小；</p></li>\r\n<li><p>如果某个训练样本点，被弱分类器<span class=\"math inline\">\\(h_i\\)</span>错误分类，那么它的权值就应该增大。权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</p></li>\r\n</ul></li>\r\n<li><p>将各个训练得到的弱分类器组合成一个强分类器。各个弱分类器的训练过程结束后，</p>\r\n<ul>\r\n<li>加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，</li>\r\n<li>降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"示例代码-2\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> tree</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.ensemble <span class=\"keyword\">import</span> AdaBoostClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.datasets <span class=\"keyword\">import</span> make_gaussian_quantiles</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> classification_report</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成2维正态分布，生成的数据按分位数分为两类，500个样本,2个样本特征</span></span><br><span class=\"line\">x1, y1 = make_gaussian_quantiles(n_samples=<span class=\"number\">500</span>, n_features=<span class=\"number\">2</span>,n_classes=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># 生成2维正态分布，生成的数据按分位数分为两类，400个样本,2个样本特征均值都为3</span></span><br><span class=\"line\">x2, y2 = make_gaussian_quantiles(mean=(<span class=\"number\">3</span>, <span class=\"number\">3</span>), n_samples=<span class=\"number\">500</span>, n_features=<span class=\"number\">2</span>, n_classes=<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># 将两组数据合成一组数据</span></span><br><span class=\"line\">x_data = np.concatenate((x1, x2))</span><br><span class=\"line\">y_data = np.concatenate((y1, - y2 + <span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># AdaBoost模型</span></span><br><span class=\"line\">model = AdaBoostClassifier(DecisionTreeClassifier(max_depth=<span class=\"number\">3</span>),n_estimators=<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"comment\"># 训练模型</span></span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取数据值所在的范围</span></span><br><span class=\"line\">x_min, x_max = x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\">y_min, y_max = x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成网格矩阵</span></span><br><span class=\"line\">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">                     np.arange(y_min, y_max, <span class=\"number\">0.02</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取预测值</span></span><br><span class=\"line\">z = model.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class=\"line\">z = z.reshape(xx.shape)</span><br><span class=\"line\"><span class=\"comment\"># 等高线图</span></span><br><span class=\"line\">cs = plt.contourf(xx, yy, z)</span><br><span class=\"line\"><span class=\"comment\"># 样本散点图</span></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 模型准确率</span></span><br><span class=\"line\">model.score(x_data,y_data)</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607153300730.png\"  style=\"zoom:50%;\" /></p>\r\n<h2 id=\"stacking\">Stacking</h2>\r\n<p>使用多个不同的分类器对训练集进预测，把预测 得到的结果作为一个次级分类器的输入。次级分 类器的输出是整个模型的预测结果。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607153502918.png\"  style=\"zoom:67%;\" /></p>\r\n<h3 id=\"示例代码-3\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets  </span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> model_selection  </span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LogisticRegression</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.neighbors <span class=\"keyword\">import</span> KNeighborsClassifier  </span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.tree <span class=\"keyword\">import</span> DecisionTreeClassifier</span><br><span class=\"line\"><span class=\"keyword\">from</span> mlxtend.classifier <span class=\"keyword\">import</span> StackingClassifier</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据集</span></span><br><span class=\"line\">iris = datasets.load_iris()  </span><br><span class=\"line\"><span class=\"comment\"># 只要第1,2列的特征</span></span><br><span class=\"line\">x_data, y_data = iris.data[:, <span class=\"number\">1</span>:<span class=\"number\">3</span>], iris.target  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义三个不同的分类器</span></span><br><span class=\"line\">clf1 = KNeighborsClassifier(n_neighbors=<span class=\"number\">1</span>)  </span><br><span class=\"line\">clf2 = DecisionTreeClassifier() </span><br><span class=\"line\">clf3 = LogisticRegression()  </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 定义一个次级分类器</span></span><br><span class=\"line\">lr = LogisticRegression()  </span><br><span class=\"line\">sclf = StackingClassifier(classifiers=[clf1, clf2, clf3],   </span><br><span class=\"line\">                          meta_classifier=lr)</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">for</span> clf,label <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>([clf1, clf2, clf3, sclf],</span><br><span class=\"line\">                      [<span class=\"string\">&#x27;KNN&#x27;</span>,<span class=\"string\">&#x27;Decision Tree&#x27;</span>,<span class=\"string\">&#x27;LogisticRegression&#x27;</span>,<span class=\"string\">&#x27;StackingClassifier&#x27;</span>]):  </span><br><span class=\"line\">    scores = model_selection.cross_val_score(clf, x_data, y_data, cv=<span class=\"number\">3</span>, scoring=<span class=\"string\">&#x27;accuracy&#x27;</span>)  </span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Accuracy: %0.2f [%s]&quot;</span> % (scores.mean(), label)) </span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\r\n",
            "tags": [
                "Python",
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/",
            "url": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/",
            "title": "决策树",
            "date_published": "2023-06-06T12:25:49.000Z",
            "content_html": "<h1 id=\"决策树-decision-tree\"><a href=\"https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E6%A0%91/10377049?fr=aladdin\">决策树 （Decision Tree）</a></h1>\r\n<p>比较适合分析离散数据。 如果是连续数据要先转成离散数据再做分析</p>\r\n<h2 id=\"熵entropy\">熵（entropy）</h2>\r\n<p>1948年，香浓提出了“<a href=\"https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E7%86%B5/7302318?fr=aladdin\">信息熵</a>”的概念，</p>\r\n<p><strong>一条信息的信息量大小和它的不确定性有直接的关系， 要搞清楚一件非常非常不确定的事情，或者是一无所知的事情，需要了解大量信息。—&gt;信息量的度量就等于不确定性的多少。</strong></p>\r\n<span id=\"more\"></span>\r\n<p>信息熵公式： <span class=\"math display\">\\[\r\nH[x]=-\\sum_{x}p(x)logp(x)\r\n\\]</span></p>\r\n<h2 id=\"id3算法\"><a href=\"https://baike.baidu.com/item/ID3%E7%AE%97%E6%B3%95/5522381?fr=aladdin\">ID3算法</a></h2>\r\n<p>决策树会选择最大化信息增益来对结点进行划分。</p>\r\n<p>信息增益（Information Gain）计算： <span class=\"math display\">\\[\r\nInfo(D)=-\\sum_{i=1}^{m}p_ilog(p_i)\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nInfo_A(D)=-\\sum_{j=1}^{v}\\frac{|D_j|}{|D|}\\times Info(D_j)\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nGain(A)=Info(D)-Info_A(D)\r\n\\]</span></p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>RID</th>\r\n<th>age</th>\r\n<th>income</th>\r\n<th>student</th>\r\n<th>credit_rating</th>\r\n<th>class_buys_computer</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>1</td>\r\n<td>youth</td>\r\n<td>high</td>\r\n<td>no</td>\r\n<td>fair</td>\r\n<td>no</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>2</td>\r\n<td>youth</td>\r\n<td>high</td>\r\n<td>no</td>\r\n<td>excellent</td>\r\n<td>no</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>3</td>\r\n<td>middle_aged</td>\r\n<td>high</td>\r\n<td>no</td>\r\n<td>fair</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>4</td>\r\n<td>senior</td>\r\n<td>medium</td>\r\n<td>no</td>\r\n<td>fair</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>5</td>\r\n<td>senior</td>\r\n<td>low</td>\r\n<td>yes</td>\r\n<td>fair</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>6</td>\r\n<td>senior</td>\r\n<td>low</td>\r\n<td>yes</td>\r\n<td>excellent</td>\r\n<td>no</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>7</td>\r\n<td>middle_aged</td>\r\n<td>low</td>\r\n<td>yes</td>\r\n<td>excellent</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>8</td>\r\n<td>youth</td>\r\n<td>medium</td>\r\n<td>no</td>\r\n<td>fair</td>\r\n<td>no</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>9</td>\r\n<td>youth</td>\r\n<td>low</td>\r\n<td>yes</td>\r\n<td>fair</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>10</td>\r\n<td>senior</td>\r\n<td>medium</td>\r\n<td>yes</td>\r\n<td>fair</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>11</td>\r\n<td>youth</td>\r\n<td>medium</td>\r\n<td>yes</td>\r\n<td>excellent</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>12</td>\r\n<td>middle_aged</td>\r\n<td>medium</td>\r\n<td>no</td>\r\n<td>excellent</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>13</td>\r\n<td>middle_aged</td>\r\n<td>high</td>\r\n<td>yes</td>\r\n<td>fair</td>\r\n<td>yes</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>14</td>\r\n<td>senior</td>\r\n<td>medium</td>\r\n<td>no</td>\r\n<td>excellent</td>\r\n<td>no</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>计算<strong>age</strong>的信息增益: <span class=\"math display\">\\[\r\nInfo(D)=-\\frac{9}{14}log_2(\\frac{9}{14})-\\frac{5}{14}log_2(\\frac{5}{14})=0.94\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nInfo_{age}(D)=\\frac{5}{14}(-\\frac{2}{5}log_2\\frac{2}{5}-\\frac{3}{5}log_2\\frac{3}{5})+\r\n\\frac{4}{14}(-\\frac{4}{4}log_2\\frac{4}{4}-\\frac{0}{4}log_2\\frac{0}{4})+\r\n\\frac{5}{14}(-\\frac{3}{5}log_2\\frac{3}{5}-\\frac{2}{5}log_2\\frac{2}{5})\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nGain(age)=Info(D)-Info_A(D)=0.94-0.694=0.246\r\n\\]</span></p>\r\n<p>其他的也是类似计算。</p>\r\n<h2 id=\"c4.5算法\"><a href=\"https://baike.baidu.com/item/C4.5%E7%AE%97%E6%B3%95/20814636\">C4.5算法</a></h2>\r\n<p>信息增益的方法倾向于首先选择因子数较多的变量 。</p>\r\n<p>信息增益的改进：增益率 <span class=\"math display\">\\[\r\nSplitInfo_A(D)=-\\sum_{j=1}^{v}\\frac{|D_j|}{|D|}\\times log_2(\\frac{|D_j|}{|D|})\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nGainRatio(A)=\\frac{Gain(A)}{SpliInfo_A(D)}\r\n\\]</span></p>\r\n<h2 id=\"cart算法\"><a href=\"https://baike.baidu.com/item/CART/17679070\">CART算法</a></h2>\r\n<p>CART决策树的生成就是递归地构建二叉决策树的过程。</p>\r\n<p>CART用基尼（Gini）系数最小化准则来进行特征选择，生成二叉树。</p>\r\n<p>Gini系数计算： <span class=\"math display\">\\[\r\nGini(D)=1-\\sum_{i=1}^{m}p_i^2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nGini_A(D)=\\frac{|D_1|}{|D|}Gini(D_1)+\\frac{|D_2|}{|D|}Gini(D_2)\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\Delta Gini(A)=Gini(D)-Gini_A(D)\r\n\\]</span></p>\r\n<p>优点：小规模数据集有效</p>\r\n<p>缺点： 处理连续变量不好 类别较多时，错误增加的比较快 不能处理大量数据</p>\r\n<h2 id=\"线性二分类示例代码\">线性二分类示例代码</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> classification_report</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> tree <span class=\"comment\"># 决策树模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">data = np.genfromtxt(<span class=\"string\">&quot;LR-testSet.csv&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">x_data = data[:,:-<span class=\"number\">1</span>]</span><br><span class=\"line\">y_data = data[:,-<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">plt.scatter(x_data[:,<span class=\"number\">0</span>],x_data[:,<span class=\"number\">1</span>],c=y_data) </span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建决策树模型</span></span><br><span class=\"line\">model = tree.DecisionTreeClassifier()</span><br><span class=\"line\"><span class=\"comment\"># 输入数据建立模型</span></span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取数据值所在的范围</span></span><br><span class=\"line\">x_min, x_max = x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\">y_min, y_max = x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成网格矩阵</span></span><br><span class=\"line\">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">                     np.arange(y_min, y_max, <span class=\"number\">0.02</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class=\"comment\"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class=\"line\">z = z.reshape(xx.shape)</span><br><span class=\"line\"><span class=\"comment\"># 等高线图</span></span><br><span class=\"line\">cs = plt.contourf(xx, yy, z)</span><br><span class=\"line\"><span class=\"comment\"># 样本散点图</span></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试与评估</span></span><br><span class=\"line\">predictions = model.predict(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(classification_report(predictions,y_data))</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607084609741.png\"  style=\"zoom:50%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230606214438933.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"非线性二分类示例代码\">非线性二分类示例代码</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> classification_report</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> tree</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">data = np.genfromtxt(<span class=\"string\">&quot;LR-testSet2.txt&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">x_data = data[:,:-<span class=\"number\">1</span>]</span><br><span class=\"line\">y_data = data[:,-<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\">plt.scatter(x_data[:,<span class=\"number\">0</span>],x_data[:,<span class=\"number\">1</span>],c=y_data) <span class=\"comment\"># s散点图</span></span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#分割数据</span></span><br><span class=\"line\">x_train,x_test,y_train,y_test = train_test_split(x_data, y_data) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建决策树模型</span></span><br><span class=\"line\"><span class=\"comment\"># max_depth，树的深度</span></span><br><span class=\"line\"><span class=\"comment\"># min_samples_split 内部节点再划分所需最小样本数</span></span><br><span class=\"line\">model = tree.DecisionTreeClassifier(max_depth=<span class=\"number\">7</span>,min_samples_split=<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\"># 拟合模型</span></span><br><span class=\"line\">model.fit(x_train, y_train)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取数据值所在的范围</span></span><br><span class=\"line\">x_min, x_max = x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\">y_min, y_max = x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成网格矩阵</span></span><br><span class=\"line\">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">                     np.arange(y_min, y_max, <span class=\"number\">0.02</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class=\"comment\"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class=\"line\">z = z.reshape(xx.shape)</span><br><span class=\"line\"><span class=\"comment\"># 等高线图</span></span><br><span class=\"line\">cs = plt.contourf(xx, yy, z)</span><br><span class=\"line\"><span class=\"comment\"># 样本散点图</span></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试并评估</span></span><br><span class=\"line\">predictions = model.predict(x_test)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(classification_report(predictions,y_test))</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607084429752.png\"  style=\"zoom: 50%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607084526669.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"回归树示例代码\">回归树示例代码</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> tree</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">data = np.genfromtxt(<span class=\"string\">&quot;data.csv&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">x_data = data[:,<span class=\"number\">0</span>,np.newaxis]</span><br><span class=\"line\">y_data = data[:,<span class=\"number\">1</span>,np.newaxis]</span><br><span class=\"line\">plt.scatter(x_data,y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">model = tree.DecisionTreeRegressor(max_depth=<span class=\"number\">5</span>)</span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\">x_test = np.linspace(<span class=\"number\">20</span>,<span class=\"number\">80</span>,<span class=\"number\">100</span>)</span><br><span class=\"line\">x_test = x_test[:,np.newaxis]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plt.plot(x_data, y_data, <span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\">plt.plot(x_test, model.predict(x_test), <span class=\"string\">&#x27;r&#x27;</span>) </span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230607090010220.png\"  style=\"zoom:50%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1Rt411q7WJ?p=50&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\">决策树</a></p>\r\n",
            "tags": [
                "Python",
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN%E7%AE%97%E6%B3%95/",
            "url": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN%E7%AE%97%E6%B3%95/",
            "title": "KNN算法",
            "date_published": "2023-06-06T12:05:23.000Z",
            "content_html": "<h1 id=\"k最近邻k-nearest-neighborknn分类算法\"><a href=\"https://baike.baidu.com/item/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/9512781?fr=aladdin\">K最近邻（K-Nearest Neighbor，KNN）</a>分类算法</h1>\r\n<ol type=\"1\">\r\n<li>为了判断未知实例的类别，以所有已知类别的实例作为 参照选择参数K</li>\r\n<li>计算未知实例与所有已知实例的距离</li>\r\n<li>选择最近K个已知实例</li>\r\n<li>根据少数服从多数的投票法则(majority-voting)，让 未知实例归类为K个最邻近样本中最多数的类别</li>\r\n</ol>\r\n<span id=\"more\"></span>\r\n<p>欧氏距离 <span class=\"math display\">\\[\r\nE(x,y)=\\sqrt{\\sum_{i=0}^{n}(x_i-y_i)^2}\r\n\\]</span> <a href=\"https://www.cnblogs.com/belfuture/p/5871452.html\">其他的距离衡量</a>：余弦值距离（cos），相关度（correlation），曼哈顿距离（Manhattan distance）</p>\r\n<p>算法缺点：</p>\r\n<ul>\r\n<li>算法复杂度较高（需要比较所有已知实例与要分类的实例）</li>\r\n<li>当其样本分布不平衡时，比如其中一类样本过大（实例数量过多）占主导的时候，新的未知实例容易被归类为这个主导样本，因为这类样本实例的数量过大，但这个新的未知实例实际并没有接近目标样本</li>\r\n</ul>\r\n<h2 id=\"示例代码\">示例代码</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入算法包以及数据集</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> neighbors</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> datasets</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.model_selection <span class=\"keyword\">import</span> train_test_split</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> classification_report</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">iris = datasets.load_iris()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(iris)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打乱数据切分数据集</span></span><br><span class=\"line\"><span class=\"comment\"># x_train,x_test,y_train,y_test = train_test_split(iris.data, iris.target, test_size=0.2) #分割数据0.2为测试数据，0.8为训练数据</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#打乱数据</span></span><br><span class=\"line\">data_size = iris.data.shape[<span class=\"number\">0</span>]</span><br><span class=\"line\">index = [i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(data_size)] </span><br><span class=\"line\">random.shuffle(index)  </span><br><span class=\"line\">iris.data = iris.data[index]</span><br><span class=\"line\">iris.target = iris.target[index]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#切分数据集</span></span><br><span class=\"line\">test_size = <span class=\"number\">40</span></span><br><span class=\"line\">x_train = iris.data[test_size:]</span><br><span class=\"line\">x_test =  iris.data[:test_size]</span><br><span class=\"line\">y_train = iris.target[test_size:]</span><br><span class=\"line\">y_test = iris.target[:test_size]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 构建模型</span></span><br><span class=\"line\">model = neighbors.KNeighborsClassifier(n_neighbors=<span class=\"number\">3</span>)</span><br><span class=\"line\">model.fit(x_train, y_train)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试和评估</span></span><br><span class=\"line\">prediction = model.predict(x_test)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(classification_report(y_test, prediction))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230606202144425.png\"  style=\"zoom: 67%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1Rt411q7WJ?p=41&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\">KNN算法</a></p>\r\n",
            "tags": [
                "Python",
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/",
            "url": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/",
            "title": "逻辑回归",
            "date_published": "2023-06-05T13:32:23.000Z",
            "content_html": "<h1 id=\"逻辑回归logistic-regression\"><a href=\"https://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92/2981575?fromtitle=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&amp;fromid=17202449&amp;fr=aladdin\">逻辑回归（Logistic Regression）</a></h1>\r\n<p>是一种广义的线性回归分析模型，与多重线性回归有很多相同之处。它们的模型形式基本上相同，都具有$ w’x+b$，其区别在于他们的因变量不同，</p>\r\n<ul>\r\n<li>多重线性回归直接将<span class=\"math inline\">\\(w&#39;x+b\\)</span>作为因变量，</li>\r\n<li>Logistic回归则通过函数L将<span class=\"math inline\">\\(w&#39;x+b\\)</span>对应一个隐状态<span class=\"math inline\">\\(p\\)</span>，<span class=\"math inline\">\\(p =L(w&#39;x+b)\\)</span>，然后根据<span class=\"math inline\">\\(p\\)</span>与<span class=\"math inline\">\\(1-p\\)</span>的大小决定因变量的值。</li>\r\n</ul>\r\n<p>如果L是Logistic函数，就是Logistic回归，</p>\r\n<p>如果L是多项式函数就是多项式回归。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"logistic-function\">Logistic Function</h2>\r\n<p>定义逻辑回归的预测函数为<span class=\"math inline\">\\(ℎ_\\theta(x) = 𝑔(\\theta^𝑇𝑥)\\)</span> ，其中g(x)函数是sigmoid函数。 <span class=\"math display\">\\[\r\ng(x)=\\frac{1}{1+e^{-x}}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nh_\\theta(x)=\\frac{1}{1+e^{-\\theta^Tx}}\r\n\\]</span></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230606093600860.png\"  style=\"zoom:50%;\" /></p>\r\n<ol type=\"1\">\r\n<li>当<span class=\"math inline\">\\(\\theta^Tx≥0\\)</span>，<span class=\"math inline\">\\(g(\\theta^Tx)≥0.5\\)</span></li>\r\n<li>当<span class=\"math inline\">\\(\\theta^Tx≤0\\)</span>，<span class=\"math inline\">\\(g(\\theta^Tx)≤0.5\\)</span></li>\r\n</ol>\r\n<h2 id=\"逻辑回归的代价函数cost-function\">逻辑回归的代价函数（Cost Function）</h2>\r\n<p><span class=\"math display\">\\[\r\nCost(h_\\theta(x),y)= \r\n\\begin{cases}\r\n-log(h_\\theta(x))\\quad\\quad\\quad if\\quad y=1\\\\\r\n-log(1-h_\\theta(x))\\quad if\\quad y=0\r\n\\end{cases}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=-ylog(h_\\theta(x))-(1-y)log(1-h_\\theta(x))\r\n\\]</span></p>\r\n<h2 id=\"梯度下降法gradient-descent\">梯度下降法（Gradient Descent）</h2>\r\n<p><span class=\"math display\">\\[\r\nJ(\\theta)=-\\frac{1}{m}[\\sum_{i=1}^{m}y^{(i)}logh_\\theta(x^{(i)})+(1-y^{(i)})log(1-h_\\theta(x^{(i)}))]\r\n\\]</span></p>\r\n<p>求解 <span class=\"math inline\">\\(min_\\theta J(\\theta)\\)</span> <span class=\"math display\">\\[\r\n\\theta_j:=\\theta_j-\\alpha\\sum_{i=1}^{m}(h_\\theta(x^{(i)})-y^{(i)})x_j^{(i)}\r\n\\]</span></p>\r\n<h2 id=\"准确率精准率召回率f1分数\">准确率|精准率|召回率|F<sub>1</sub>分数</h2>\r\n<p>混淆矩阵</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th></th>\r\n<th></th>\r\n<th>实际</th>\r\n<th>实际</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td></td>\r\n<td>1</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>预测</td>\r\n<td>1</td>\r\n<td>TP</td>\r\n<td>FP</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>预测</td>\r\n<td>0</td>\r\n<td>FN</td>\r\n<td>TN</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li>P（Positive）：代表1</li>\r\n<li>N（Negative）：代表0</li>\r\n<li>T（True）：代表预测正确</li>\r\n<li>F（False）：代表预测错误</li>\r\n</ul>\r\n<p><strong>准确率：</strong>即预测正确的结果占总样本的百分比 <span class=\"math display\">\\[\r\n准确率=\\frac{TP+TN}{TP+TN+FP+FN}\r\n\\]</span> <strong>精准率（Precision）：</strong>是指在所有被预测为正的样本中实际为正的样本的概率。 <span class=\"math display\">\\[\r\n精准率=\\frac{TP}{TP+FP}\r\n\\]</span> <strong>精准率就是你认为找的是对的实际上多少是对的</strong></p>\r\n<p><strong>召回率（Recall）：</strong>是指在实际为正的样本中被预测为正样本的概率。 <span class=\"math display\">\\[\r\n召回率=\\frac{TP}{TP+FN}\r\n\\]</span> <strong>F<sub>1</sub>分数：</strong>精准率和召回率之间的一个平衡点。 <span class=\"math display\">\\[\r\nF_1=\\frac{2\\times Precision\\times Recall}{Precision+Recall}\r\n\\]</span></p>\r\n<h2 id=\"逻辑回归示例代码\">逻辑回归示例代码</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.metrics <span class=\"keyword\">import</span> classification_report</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> preprocessing</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model</span><br><span class=\"line\"><span class=\"comment\"># 数据是否需要标准化</span></span><br><span class=\"line\">scale = <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">data = np.genfromtxt(<span class=\"string\">&quot;LR-testSet.csv&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">x_data = data[:,:-<span class=\"number\">1</span>]</span><br><span class=\"line\">y_data = data[:,-<span class=\"number\">1</span>]</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot</span>():</span><br><span class=\"line\">    x0 = []</span><br><span class=\"line\">    x1 = []</span><br><span class=\"line\">    y0 = []</span><br><span class=\"line\">    y1 = []</span><br><span class=\"line\">    <span class=\"comment\"># 切分不同类别的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(x_data)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> y_data[i]==<span class=\"number\">0</span>:</span><br><span class=\"line\">            x0.append(x_data[i,<span class=\"number\">0</span>])</span><br><span class=\"line\">            y0.append(x_data[i,<span class=\"number\">1</span>])</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            x1.append(x_data[i,<span class=\"number\">0</span>])</span><br><span class=\"line\">            y1.append(x_data[i,<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 画图</span></span><br><span class=\"line\">   scatter0 = plt.scatter(x0, y0, c=<span class=\"string\">&#x27;c&#x27;</span>, marker=<span class=\"string\">&#x27;+&#x27;</span>)</span><br><span class=\"line\">    scatter1 = plt.scatter(x1, y1, c=<span class=\"string\">&#x27;y&#x27;</span>, marker=<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#画图例</span></span><br><span class=\"line\">    plt.legend(handles=[scatter0,scatter1],labels=[<span class=\"string\">&#x27;label0&#x27;</span>,<span class=\"string\">&#x27;label1&#x27;</span>],loc=<span class=\"string\">&#x27;best&#x27;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">plot()</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并拟合模型</span></span><br><span class=\"line\">logistic = linear_model.LogisticRegression()</span><br><span class=\"line\">logistic.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> scale == <span class=\"literal\">False</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 画图决策边界</span></span><br><span class=\"line\">    plot()</span><br><span class=\"line\">    x_test = np.array([[-<span class=\"number\">4</span>],[<span class=\"number\">3</span>]])</span><br><span class=\"line\">    y_test = (-logistic.intercept_ - x_test*logistic.coef_[<span class=\"number\">0</span>][<span class=\"number\">0</span>])/logistic.coef_[<span class=\"number\">0</span>][<span class=\"number\">1</span>]</span><br><span class=\"line\">    plt.plot(x_test, y_test, <span class=\"string\">&#x27;k&#x27;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\"># 测试与评估    </span></span><br><span class=\"line\">predictions = logistic.predict(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(classification_report(y_data, predictions))</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230606164354040.png\"  style=\"zoom:50%;\" /></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230606164557574.png\"  style=\"zoom: 67%;\" /></p>\r\n<h2 id=\"非线性逻辑回归示例代码\">非线性逻辑回归示例代码</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.datasets <span class=\"keyword\">import</span> make_gaussian_quantiles</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> PolynomialFeatures</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成2维正态分布，生成的数据按分位数分为两类，500个样本,2个样本特征</span></span><br><span class=\"line\"><span class=\"comment\"># 可以生成两类或多类数据</span></span><br><span class=\"line\">x_data, y_data = make_gaussian_quantiles(n_samples=<span class=\"number\">500</span>, n_features=<span class=\"number\">2</span>,n_classes=<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并拟合模型</span></span><br><span class=\"line\">logistic = linear_model.LogisticRegression()</span><br><span class=\"line\">logistic.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义多项式回归,degree的值可以调节多项式的特征</span></span><br><span class=\"line\">poly_reg  = PolynomialFeatures(degree=<span class=\"number\">5</span>) </span><br><span class=\"line\"><span class=\"comment\"># 特征处理</span></span><br><span class=\"line\">x_poly = poly_reg.fit_transform(x_data)</span><br><span class=\"line\"><span class=\"comment\"># 定义逻辑回归模型</span></span><br><span class=\"line\">logistic = linear_model.LogisticRegression()</span><br><span class=\"line\"><span class=\"comment\"># 训练模型</span></span><br><span class=\"line\">logistic.fit(x_poly, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 获取数据值所在的范围</span></span><br><span class=\"line\">x_min, x_max = x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">0</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\">y_min, y_max = x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">min</span>() - <span class=\"number\">1</span>, x_data[:, <span class=\"number\">1</span>].<span class=\"built_in\">max</span>() + <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生成网格矩阵</span></span><br><span class=\"line\">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class=\"number\">0.02</span>),</span><br><span class=\"line\">                     np.arange(y_min, y_max, <span class=\"number\">0.02</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">z = logistic.predict(poly_reg.fit_transform(np.c_[xx.ravel(), yy.ravel()]))<span class=\"comment\"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class=\"line\">z = z.reshape(xx.shape)</span><br><span class=\"line\"><span class=\"comment\"># 等高线图</span></span><br><span class=\"line\">cs = plt.contourf(xx, yy, z)</span><br><span class=\"line\"><span class=\"comment\"># 样本散点图</span></span><br><span class=\"line\">plt.scatter(x_data[:, <span class=\"number\">0</span>], x_data[:, <span class=\"number\">1</span>], c=y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;score:&#x27;</span>,logistic.score(x_poly,y_data))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230606165631817.png\"  style=\"zoom:67%;\" /></p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1Rt411q7WJ?p=29\">逻辑回归</a></p>\r\n",
            "tags": [
                "Python",
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/",
            "url": "https://liujk6525.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/",
            "title": "线性回归及非线性回归",
            "date_published": "2023-06-05T01:37:27.000Z",
            "content_html": "<h1 id=\"基本概念\">基本概念：</h1>\r\n<p>将数据划分为三部分：<span class=\"math inline\">\\(\\begin{cases} 训练集(Train):用来训练，构建模型\\\\ 验证集(Validate):在模型训练阶段，测试模型的好坏\\\\ 测试集(Test):等模型训练好后，评估模型的好坏 \\end{cases}\\)</span></p>\r\n<span id=\"more\"></span>\r\n<p>学习方式：<span class=\"math inline\">\\(\\begin{cases} 监督学习\\\\ 无监督学习\\\\ 半监督学习 \\end{cases}\\)</span></p>\r\n<p>常见应用：<span class=\"math inline\">\\(\\begin{cases} 回归：预测数据为连续型数值。\\\\ 分类：预测数据为类别型数据，并且类别已知。\\\\ 聚类：预测数据为类别型数据，但是类别未知。 \\end{cases}\\)</span></p>\r\n<h1 id=\"回归分析regression\"><a href=\"https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/2625498?fr=aladdin\">回归分析（Regression）</a></h1>\r\n<p>回归分析用来建立方程，模拟两个或者多个变量之间如何关联，</p>\r\n<ul>\r\n<li>被预测的变量叫做：因变量/输出</li>\r\n<li>被用来进行预测的变量叫做： 自变量,/输入</li>\r\n</ul>\r\n<p>一元线性回归包含一个自变量和一个因变量，两个变量的关系用一条直线来模拟，如果包含两个以上的自变量，则称作多元回归分析（multiple regression）</p>\r\n<h1 id=\"一元线性回归\"><a href=\"https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/22770888?fr=aladdin\">一元线性回归</a></h1>\r\n<p>一元线性回归：<span class=\"math inline\">\\(h_\\theta(x)=\\theta_0+\\theta_1x\\)</span></p>\r\n<h2 id=\"代价函数cost-function\"><a href=\"https://baike.baidu.com/item/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/1783236?fromtitle=%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0&amp;fromid=7048599&amp;fr=aladdin\">代价函数（Cost Function）</a></h2>\r\n<p><strong>最小二乘法</strong></p>\r\n<p>假设真实值为<span class=\"math inline\">\\(y\\)</span>，预测值<span class=\"math inline\">\\(h_\\theta(x)\\)</span> ，则误差平方为<span class=\"math inline\">\\((h_\\theta(x)-y)^2\\)</span></p>\r\n<p>找到合适的参数，使得误差平方和<span class=\"math inline\">\\(J(\\theta_0,\\theta_1)\\)</span>最小。 <span class=\"math display\">\\[\r\nJ(\\theta_0,\\theta_1)=\\frac{1}{2m}\\sum_{i=1}^{m}{(h_\\theta(x^{(i)})-y^{(i)})^{2}}\r\n\\]</span></p>\r\n<h2 id=\"梯度下降法gradient-descent\"><a href=\"https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/8641233?fr=aladdin\">梯度下降法（Gradient Descent）</a></h2>\r\n<p><strong>最小化目标函数</strong> <span class=\"math inline\">\\(\\underset{\\theta_0,\\theta_1}{min}\\quad J(\\theta_0,\\theta_1)\\)</span></p>\r\n<p>初始化参数<span class=\"math inline\">\\(\\theta_0,\\theta_1\\)</span></p>\r\n<p>不断改变<span class=\"math inline\">\\(\\theta_0,\\theta_1\\)</span> ，直到<span class=\"math inline\">\\(J(\\theta_0,\\theta_1)\\)</span>到达一个全局最小值，或局部极小值。 <span class=\"math display\">\\[\r\n\\theta_j:=\\theta_j-\\alpha\\frac{\\partial}{\\partial\\theta_j}J(\\theta_0,\\theta_1)\\quad (j=0,1,2\\cdots)\r\n\\]</span></p>\r\n<h2 id=\"用梯度下降法求解线性回归\">用梯度下降法求解线性回归</h2>\r\n<p><span class=\"math display\">\\[\r\n\\frac{\\partial}{\\partial\\theta_0}J(\\theta_0,\\theta_1)=\r\n\\frac{1}{m}\\sum_{i=1}^{m}{(h_\\theta(x^{(i)})-y^{(i)})}\r\n\\\\\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{\\partial}{\\partial\\theta_1}J(\\theta_0,\\theta_1)=\r\n\\frac{1}{m}\\sum_{i=1}^{m}{(h_\\theta(x^{(i)})-y^{(i)})}\\times x^{(i)}\r\n\\]</span></p>\r\n<p>不断迭代，直到收敛： <span class=\"math display\">\\[\r\n\\theta_0:=\\theta_0-\\alpha\\frac{1}{m}{\\sum_{i=1}^{m}{(h_\\theta(x^{(i)})-y^{(i)})}}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\theta_1:=\\theta_1-\\alpha\\frac{1}{m}{\\sum_{i=1}^{m}{(h_\\theta(x^{(i)})-y^{(i)})}}\\times x^{(i)}\r\n\\]</span></p>\r\n<h2 id=\"示例代码\">示例代码：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression <span class=\"comment\"># 线性回归模型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">data = np.genfromtxt(<span class=\"string\">&quot;data.csv&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">x_data = data[:,<span class=\"number\">0</span>]</span><br><span class=\"line\">y_data = data[:,<span class=\"number\">1</span>]</span><br><span class=\"line\">plt.scatter(x_data,y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">x_data = data[:,<span class=\"number\">0</span>,np.newaxis]</span><br><span class=\"line\">y_data = data[:,<span class=\"number\">1</span>,np.newaxis]</span><br><span class=\"line\"><span class=\"comment\"># 创建并拟合模型</span></span><br><span class=\"line\">model = LinearRegression() <span class=\"comment\"># 线性回归</span></span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">x_test = [[<span class=\"number\">44.5</span>]]</span><br><span class=\"line\">predict = model.predict(x_test)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;predict&#x27;</span>,predict)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plt.plot(x_data, y_data, <span class=\"string\">&#x27;b.&#x27;</span>)</span><br><span class=\"line\">plt.plot(x_data, model.predict(x_data), <span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230605203607162.png\"  style=\"zoom:50%;\" /></p>\r\n<h1 id=\"多元线性回归multiple-linear-regression\"><a href=\"https://baike.baidu.com/item/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/10702248?fr=aladdin\">多元线性回归（Multiple Linear Regression）</a></h1>\r\n<p>多特征时，假设：<span class=\"math inline\">\\(h_\\theta(x)=\\theta_0+\\theta_1x_1+\\theta_2x_2+\\cdots+\\theta_nx_n\\)</span></p>\r\n<p>当真实值<span class=\"math inline\">\\(y\\)</span>的影响因素不是唯一时，需采用多元线性回归模型。</p>\r\n<p>代价函数： <span class=\"math display\">\\[\r\nJ(\\theta_0,\\theta_1,\\cdots,\\theta_n)=\\frac{1}{2m}\\sum_{i=1}^{m}(h_\\theta(x^{(i)})-y^{(i)})^{2}\r\n\\]</span> 梯度下降法： <span class=\"math display\">\\[\r\n\\theta_j:=\\theta_j-\\alpha\\frac{1}{m}\\sum_{i=1}^{m}{(h_\\theta(x^{(i)})-y^{(i)})}\\times x_j^{(i)}\\quad (j=0,1,2\\cdots,n)\r\n\\]</span> 注意这里的<span class=\"math inline\">\\(j=0\\)</span>时，<span class=\"math inline\">\\(x_0=1\\)</span></p>\r\n<h2 id=\"示例代码-1\">示例代码：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> genfromtxt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model <span class=\"comment\"># 线性回归模型</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt  </span><br><span class=\"line\"><span class=\"keyword\">from</span> mpl_toolkits.mplot3d <span class=\"keyword\">import</span> Axes3D  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读入数据 </span></span><br><span class=\"line\">data = genfromtxt(<span class=\"string\">r&quot;Delivery.csv&quot;</span>,delimiter=<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切分数据</span></span><br><span class=\"line\">x_data = data[:,:-<span class=\"number\">1</span>]</span><br><span class=\"line\">y_data = data[:,-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建模型</span></span><br><span class=\"line\">model = linear_model.LinearRegression()</span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">x_test = [[<span class=\"number\">102</span>,<span class=\"number\">4</span>]]</span><br><span class=\"line\">predict = model.predict(x_test)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;predict:&quot;</span>,predict)</span><br><span class=\"line\"></span><br><span class=\"line\">ax = plt.figure().add_subplot(<span class=\"number\">111</span>, projection = <span class=\"string\">&#x27;3d&#x27;</span>) </span><br><span class=\"line\">ax.scatter(x_data[:,<span class=\"number\">0</span>], x_data[:,<span class=\"number\">1</span>], y_data, c = <span class=\"string\">&#x27;r&#x27;</span>, marker = <span class=\"string\">&#x27;o&#x27;</span>, s = <span class=\"number\">100</span>) <span class=\"comment\">#点为红色三角形  </span></span><br><span class=\"line\">x0 = x_data[:,<span class=\"number\">0</span>]</span><br><span class=\"line\">x1 = x_data[:,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\"># 生成网格矩阵</span></span><br><span class=\"line\">x0, x1 = np.meshgrid(x0, x1)</span><br><span class=\"line\">z = model.intercept_ + x0*model.coef_[<span class=\"number\">0</span>] + x1*model.coef_[<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"comment\"># 画3D图</span></span><br><span class=\"line\">ax.plot_surface(x0, x1, z)</span><br><span class=\"line\"><span class=\"comment\">#设置坐标轴  </span></span><br><span class=\"line\">ax.set_xlabel(<span class=\"string\">&#x27;Miles&#x27;</span>)  </span><br><span class=\"line\">ax.set_ylabel(<span class=\"string\">&#x27;Num of Deliveries&#x27;</span>)  </span><br><span class=\"line\">ax.set_zlabel(<span class=\"string\">&#x27;Time&#x27;</span>)  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">#显示图像  </span></span><br><span class=\"line\">plt.show()  </span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230605204147960.png\"  style=\"zoom:50%;\" /></p>\r\n<h1 id=\"多项式回归\">多项式回归</h1>\r\n<p>假如我们不是要找直线（或者超平面），而是需要找到一 个用多项式所表示的曲线（或者超曲面）</p>\r\n<p>多项式回归：<span class=\"math inline\">\\(h_\\theta(x)=\\theta_0+\\theta_1x+\\theta_2x^2+\\cdots+\\theta_nx^n\\)</span></p>\r\n<h2 id=\"示例代码-2\">示例代码：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.preprocessing <span class=\"keyword\">import</span> PolynomialFeatures </span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn.linear_model <span class=\"keyword\">import</span> LinearRegression</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 载入数据</span></span><br><span class=\"line\">data = np.genfromtxt(<span class=\"string\">&quot;job.csv&quot;</span>, delimiter=<span class=\"string\">&quot;,&quot;</span>)</span><br><span class=\"line\">x_data = data[<span class=\"number\">1</span>:,<span class=\"number\">1</span>]</span><br><span class=\"line\">y_data = data[<span class=\"number\">1</span>:,<span class=\"number\">2</span>]</span><br><span class=\"line\">plt.scatter(x_data,y_data)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">x_data = x_data[:,np.newaxis]</span><br><span class=\"line\">y_data = y_data[:,np.newaxis]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义多项式回归,degree的值可以调节多项式的特征</span></span><br><span class=\"line\">poly_reg  = PolynomialFeatures(degree=<span class=\"number\">5</span>) </span><br><span class=\"line\"><span class=\"comment\"># 特征处理</span></span><br><span class=\"line\">x_poly = poly_reg.fit_transform(x_data)</span><br><span class=\"line\"><span class=\"comment\"># 定义回归模型</span></span><br><span class=\"line\">lin_reg = LinearRegression()</span><br><span class=\"line\"><span class=\"comment\"># 训练模型</span></span><br><span class=\"line\">lin_reg.fit(x_poly, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plt.plot(x_data, y_data, <span class=\"string\">&#x27;b.&#x27;</span>)</span><br><span class=\"line\">x_test = np.linspace(<span class=\"number\">1</span>,<span class=\"number\">10</span>,<span class=\"number\">100</span>)</span><br><span class=\"line\">x_test = x_test[:,np.newaxis]</span><br><span class=\"line\">plt.plot(x_test, lin_reg.predict(poly_reg.fit_transform(x_test)), c=<span class=\"string\">&#x27;r&#x27;</span>)</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;Truth or Bluff (Polynomial Regression)&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;Position level&#x27;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;Salary&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230605205328029.png\"  style=\"zoom:50%;\" /></p>\r\n<h1 id=\"标准方程法normal-equation\">标准方程法（Normal Equation）</h1>\r\n<p>注意这里的符号：<span class=\"math inline\">\\(w\\)</span>其实就是上面公式里的<span class=\"math inline\">\\(\\theta\\)</span>，就是要求解的那个参数。</p>\r\n<p>假设： <span class=\"math display\">\\[\r\nh_w(x)=w_0+w_1x_1+w_2x_2+\\cdots+w_nx_n\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nh_w(x)=xw\\\r\n\\]</span></p>\r\n<p>目标函数: <span class=\"math display\">\\[\r\nJ(w_0,w_1,\\cdots,w_n)=\\frac{1}{2m}\\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^{2}\r\n\\]</span> 又因为 <span class=\"math display\">\\[\r\n\\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^{2}=(y-Xw)^T(y-Xw)\r\n\\]</span> 所以 <span class=\"math display\">\\[\r\n\\frac{\\partial J(w)}{\\partial w}=\\frac{\\partial(y-Xw)^T(y-Xw)}{\\partial w}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\frac{\\partial(y^Ty-y^TXw-w^TX^Ty+w^TX^TXw)}{\\partial w}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\frac{\\partial(y^Ty)}{\\partial w}-\\frac{\\partial(y^TXw)}{\\partial w}-\\frac{\\partial(w^TX^Ty)}{\\partial w}+\\frac{\\partial(w^TX^TXw)}{\\partial w}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=0-X^Ty-X^Ty+2X^TXw\r\n\\]</span></p>\r\n<p>令 <span class=\"math display\">\\[\r\n\\frac{\\partial J(w)}{\\partial w}=0\r\n\\]</span> 求解： <span class=\"math display\">\\[\r\n-2X^Ty+2X^TXw=0\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nX^TXw=X^Ty\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nw=(X^TX)^{-1}X^Ty\r\n\\]</span></p>\r\n<h1 id=\"特征缩放\"><a href=\"https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE/17415222?fr=aladdin\">特征缩放</a></h1>\r\n<h2 id=\"数据归一化\">数据归一化</h2>\r\n<p>数据归一化就是把数据的取值范围处理为<span class=\"math inline\">\\(0-1\\)</span>，或者<span class=\"math inline\">\\(-1-1\\)</span>之间。</p>\r\n<p>任意数据转化为0-1之间： <span class=\"math display\">\\[\r\nNewValue = \\frac{OldValue-min}{max-min}\r\n\\]</span> 任意数据转化为-1-1之间： <span class=\"math display\">\\[\r\nNewValue=2\\times(\\frac{OldVaule-min}{max-min}-0.5)\r\n\\]</span></p>\r\n<h2 id=\"均值标准化\">均值标准化</h2>\r\n<p><span class=\"math inline\">\\(x\\)</span>为特征数据，<span class=\"math inline\">\\(u\\)</span>为数据的平均值，<span class=\"math inline\">\\(s\\)</span>为数据的方差。 <span class=\"math display\">\\[\r\nNewValue=\\frac{OldValue-u}{s}\r\n\\]</span></p>\r\n<h1 id=\"过拟合overfitting\">过拟合（Overfitting）</h1>\r\n<p>回归问题拟合有以下三种情况：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230605154335888.png\"  style=\"zoom:50%;\" /></p>\r\n<p>分类问题有以下三种情况：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230605154600447.png\" style=\"zoom:50%;\" /></p>\r\n<p>防止过拟合：减少特征；增加数据量；正则化（Regularized）</p>\r\n<h2 id=\"正则化\">正则化</h2>\r\n<p>L2正则化： <span class=\"math display\">\\[\r\nJ(\\theta)=\\frac{1}{2m}[\\sum_{i=1}^{m}{h_\\theta(x^{(i)}-y^{(i)})^2+\\lambda\\sum_{j=1}^{n}{\\theta_j^2}}]\r\n\\]</span> L1正则化： <span class=\"math display\">\\[\r\nJ(\\theta)=\\frac{1}{2m}[\\sum_{i=1}^{m}{h_\\theta(x^{(i)}-y^{(i)})^2+\\lambda\\sum_{j=1}^{n}{|\\theta_j|}}]\r\n\\]</span></p>\r\n<h1 id=\"岭回归ridge-regression\"><a href=\"https://baike.baidu.com/link?url=J428YjCOAduEv-hDj1BM53FvjQEMC1iR9icG161YvlKwmXXmtsgGoFBvkL_VK2T40KfCjPMUpQQ8ePln0cjp50QpceYEGvvCC4iewQhwY0fGCqcS9kwQCLnbARBjd0mT\">岭回归（Ridge Regression）</a></h1>\r\n<p>由标准方程法得出， <span class=\"math display\">\\[\r\nw = (𝑋^𝑇𝑋)^{-1}𝑋^𝑇y\r\n\\]</span> 如果数据的特征比样本点还多，（数据特征<span class=\"math inline\">\\(n\\)</span>，样本个数<span class=\"math inline\">\\(m\\)</span>），如果<span class=\"math inline\">\\(n&gt;m\\)</span>，<span class=\"math inline\">\\(𝑋^𝑇𝑋\\)</span>不是满秩矩阵，不可逆，计算<span class=\"math inline\">\\(𝑋^𝑇𝑋^{-1}\\)</span>时会出错。</p>\r\n<p>为了解决这个问题，引入了岭回归的概念。<span class=\"math inline\">\\(\\lambda\\)</span>为岭系数，<span class=\"math inline\">\\(I\\)</span>为单位矩阵。 <span class=\"math display\">\\[\r\nw = (𝑋^𝑇𝑋 + \\lambda I)^{-1}𝑋^𝑇y\r\n\\]</span> 推导： <span class=\"math display\">\\[\r\nJ(\\theta)=\\frac{1}{2}[\\sum_{i=1}^{m}{h_\\theta(x^{(i)}-y^{(i)})^2+\\lambda\\sum_{j=1}^{n}{\\theta_j^2}}]\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\frac{1}{2}(Xw-y)^T(Xw-y)+\\lambda w^Tw\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\frac{1}{2}(w^TX^TXw-w^TX^Ty-y^TXw+y^Ty)+\\lambda w^Tw\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\frac{\\partial J(w)}{\\partial w}=X^TXw-X^Ty+\\lambda w\r\n\\]</span></p>\r\n<p>令 <span class=\"math display\">\\[\r\n\\frac{\\partial J(w)}{\\partial w}=0\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nw = (𝑋^𝑇𝑋 + \\lambda I)^{-1}𝑋^𝑇y\r\n\\]</span></p>\r\n<h2 id=\"示例代码-3\">示例代码：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> genfromtxt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读入数据 </span></span><br><span class=\"line\">data = genfromtxt(<span class=\"string\">r&quot;longley.csv&quot;</span>,delimiter=<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切分数据</span></span><br><span class=\"line\">x_data = data[<span class=\"number\">1</span>:,<span class=\"number\">2</span>:]</span><br><span class=\"line\">y_data = data[<span class=\"number\">1</span>:,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建模型</span></span><br><span class=\"line\"><span class=\"comment\"># 生成50个值</span></span><br><span class=\"line\">alphas_to_test = np.linspace(<span class=\"number\">0.001</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 创建模型，保存误差值</span></span><br><span class=\"line\">model = linear_model.RidgeCV(alphas=alphas_to_test, store_cv_values=<span class=\"literal\">True</span>)</span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\"><span class=\"comment\"># 岭系数跟loss值的关系</span></span><br><span class=\"line\">plt.plot(alphas_to_test, model.cv_values_.mean(axis=<span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"comment\"># 选取的岭系数值的位置</span></span><br><span class=\"line\">plt.plot(model.alpha_, <span class=\"built_in\">min</span>(model.cv_values_.mean(axis=<span class=\"number\">0</span>)),<span class=\"string\">&#x27;ro&#x27;</span>)</span><br><span class=\"line\">plt.xlabel(<span class=\"string\">&#x27;alphas&#x27;</span>)</span><br><span class=\"line\">plt.ylabel(<span class=\"string\">&#x27;loss&#x27;</span>)</span><br><span class=\"line\">plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试</span></span><br><span class=\"line\">model.predict(x_data[<span class=\"number\">2</span>,np.newaxis])</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20230605210828441.png\"  style=\"zoom:50%;\" /></p>\r\n<h1 id=\"lassoleast-absolute-shrinkage-and\">[LASSO（Least Absolute Shrinkage and</h1>\r\n<p>Selectionator operator）](https://baike.baidu.com/item/Lasso%E7%AE%97%E6%B3%95/22685468?fromtitle=LASSO&amp;fromid=20366865&amp;fr=aladdin)</p>\r\n<p>LASSO的代价函数： <span class=\"math display\">\\[\r\nJ(\\theta)=\\frac{1}{2m}[\\sum_{i=1}^{m}{h_\\theta(x^{(i)}-y^{(i)})^2+\\lambda\\sum_{j=1}^{n}{|\\theta_j|}}]\r\n\\]</span></p>\r\n<h2 id=\"示例代码-4\">示例代码：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> genfromtxt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读入数据 </span></span><br><span class=\"line\">data = genfromtxt(<span class=\"string\">r&quot;longley.csv&quot;</span>,delimiter=<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切分数据</span></span><br><span class=\"line\">x_data = data[<span class=\"number\">1</span>:,<span class=\"number\">2</span>:]</span><br><span class=\"line\">y_data = data[<span class=\"number\">1</span>:,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并拟合模型</span></span><br><span class=\"line\">model = linear_model.LassoCV()</span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># lasso系数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(model.alpha_)</span><br><span class=\"line\"><span class=\"comment\"># 相关系数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(model.coef_)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预测</span></span><br><span class=\"line\">model.predict(x_data[-<span class=\"number\">2</span>,np.newaxis])</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"弹性网elastic-net\">弹性网（Elastic Net）</h1>\r\n<p>在<span class=\"math inline\">\\(q\\)</span>取不同值情况下的代价函数 <span class=\"math display\">\\[\r\nJ(\\theta)=\\frac{1}{2m}[\\sum_{i=1}^{m}{h_\\theta(x^{(i)}-y^{(i)})^2+\\lambda\\sum_{j=1}^{n}{|\\theta_j|^q}}]\r\n\\]</span> <img src=\"/imgs/$%7Bfiilename%7D/image-20230605164458909.png\"  style=\"zoom:50%;\" /></p>\r\n<p>Elastic Net的代价函数： <span class=\"math display\">\\[\r\nJ(\\theta)=\\frac{1}{2m}[\\sum_{i=1}^{m}{h_\\theta(x^{(i)}-y^{(i)})^2+\\lambda\\sum_{j=1}^{n}{\\alpha\\theta_j^2+(1-\\alpha)|\\theta_j|}}]\r\n\\]</span></p>\r\n<h2 id=\"示例代码-5\">示例代码：</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> numpy <span class=\"keyword\">import</span> genfromtxt</span><br><span class=\"line\"><span class=\"keyword\">from</span> sklearn <span class=\"keyword\">import</span> linear_model</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读入数据 </span></span><br><span class=\"line\">data = genfromtxt(<span class=\"string\">r&quot;longley.csv&quot;</span>,delimiter=<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 切分数据</span></span><br><span class=\"line\">x_data = data[<span class=\"number\">1</span>:,<span class=\"number\">2</span>:]</span><br><span class=\"line\">y_data = data[<span class=\"number\">1</span>:,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(x_data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建并拟合模型</span></span><br><span class=\"line\">model = linear_model.ElasticNetCV()</span><br><span class=\"line\">model.fit(x_data, y_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 弹性网系数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(model.alpha_)</span><br><span class=\"line\"><span class=\"comment\"># 相关系数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(model.coef_)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 预测</span></span><br><span class=\"line\">model.predict(x_data[-<span class=\"number\">2</span>,np.newaxis])</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1Rt411q7WJ?p=23&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\">线性回归及其非线性回归</a></p>\r\n",
            "tags": [
                "Python",
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/OpenCV/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A1%88%E4%BE%8B/",
            "url": "https://liujk6525.github.io/OpenCV/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A1%88%E4%BE%8B/",
            "title": "人脸识别案例",
            "date_published": "2023-05-20T06:16:48.000Z",
            "content_html": "<h1 id=\"基础\">基础</h1>\r\n<p>使用机器学习的方法完成人脸检测，首先需要大量的正样本图像（面部图像）和负样本图像（不含面部的图像）来训练分类器。我们需要从其中提取特征。下图中的 Haar 特征会被使用，就像我们的卷积核，每一个特征是一个值，这个值等于黑色矩形中的像素值之后减去白色矩形中的像素值之和。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191014152218924-1684563500129-1.png\"  style=\"zoom:67%;\" /></p>\r\n<p>Haar特征值反映了图像的灰度变化情况。例如：脸部的一些特征能由矩形特征简单的描述，眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。</p>\r\n<p>Haar特征可用于于图像任意位置，大小也可以任意改变，所以矩形特征值是矩形模版类别、矩形位置和矩形大小这三个因素的函数。故类别、大小和位置的变化，使得很小的检测窗口含有非常多的矩形特征。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191014152716626-1684563652425-11.png\"  style=\"zoom: 50%;\" /></p>\r\n<p>得到图像的特征后，训练一个决策树构建的adaboost级联决策器来识别是否为人脸。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191014160504382-1684563672078-13.png\"  style=\"zoom:50%;\" /></p>\r\n<p>OpenCV中自带已训练好的检测器，包括面部，眼睛，猫脸等，都保存在XML文件中，利用这些文件来识别人脸，眼睛等。</p>\r\n<ol type=\"1\">\r\n<li><p>读取图片，并转换成灰度图</p></li>\r\n<li><p>实例化人脸和眼睛检测的分类器对象</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 实例化级联分类器</span></span><br><span class=\"line\">classifier =cv.CascadeClassifier( <span class=\"string\">&quot;haarcascade_frontalface_default.xml&quot;</span> ) </span><br><span class=\"line\"><span class=\"comment\"># 加载分类器</span></span><br><span class=\"line\">classifier.load(<span class=\"string\">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\r\n<li><p>进行人脸和眼睛的检测</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rect = classifier.detectMultiScale(gray, scaleFactor, minNeighbors, minSize,maxsize)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>Gray: 要进行检测的人脸图像</li>\r\n<li>scaleFactor: 前后两次扫描中，搜索窗口的比例系数</li>\r\n<li>minneighbors：目标至少被检测到minNeighbors次才会被认为是目标</li>\r\n<li>minsize和maxsize: 目标的最小尺寸和最大尺寸</li>\r\n</ul></li>\r\n<li><p>将检测结果绘制出来就可以了。</p></li>\r\n</ol>\r\n<h3 id=\"示例代码\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1.以灰度图的形式读取图片</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&quot;16.jpg&quot;</span>)</span><br><span class=\"line\">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.实例化OpenCV人脸和眼睛识别的分类器 </span></span><br><span class=\"line\">face_cas = cv.CascadeClassifier( <span class=\"string\">&quot;haarcascade_frontalface_default.xml&quot;</span> ) </span><br><span class=\"line\">face_cas.load(<span class=\"string\">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">eyes_cas = cv.CascadeClassifier(<span class=\"string\">&quot;haarcascade_eye.xml&quot;</span>)</span><br><span class=\"line\">eyes_cas.load(<span class=\"string\">&quot;haarcascade_eye.xml&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.调用识别人脸 </span></span><br><span class=\"line\">faceRects = face_cas.detectMultiScale( gray, scaleFactor=<span class=\"number\">1.2</span>, minNeighbors=<span class=\"number\">3</span>, minSize=(<span class=\"number\">32</span>, <span class=\"number\">32</span>)) </span><br><span class=\"line\"><span class=\"keyword\">for</span> faceRect <span class=\"keyword\">in</span> faceRects: </span><br><span class=\"line\">    x, y, w, h = faceRect </span><br><span class=\"line\">    <span class=\"comment\"># 框出人脸 </span></span><br><span class=\"line\">    cv.rectangle(img, (x, y), (x + h, y + w),(<span class=\"number\">0</span>,<span class=\"number\">255</span>,<span class=\"number\">0</span>), <span class=\"number\">3</span>) </span><br><span class=\"line\">    <span class=\"comment\"># 4.在识别出的人脸中进行眼睛的检测</span></span><br><span class=\"line\">    roi_color = img[y:y+h, x:x+w]</span><br><span class=\"line\">    roi_gray = gray[y:y+h, x:x+w]</span><br><span class=\"line\">    eyes = eyes_cas.detectMultiScale(roi_gray) </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (ex,ey,ew,eh) <span class=\"keyword\">in</span> eyes:</span><br><span class=\"line\">        cv.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(<span class=\"number\">0</span>,<span class=\"number\">255</span>,<span class=\"number\">0</span>),<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># 5. 检测结果的绘制</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">8</span>,<span class=\"number\">6</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;检测结果&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/yangzi2.jpeg\"  style=\"zoom:67%;\" /></p>\r\n<p>在视频中对人脸进行检测：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1.读取视频</span></span><br><span class=\"line\">cap = cv.VideoCapture(<span class=\"string\">&quot;movie.mp4&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2.在每一帧数据中进行人脸识别</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(cap.isOpened()):</span><br><span class=\"line\">    ret, frame = cap.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ret==<span class=\"literal\">True</span>:</span><br><span class=\"line\">        gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class=\"line\">        <span class=\"comment\"># 3.实例化OpenCV人脸识别的分类器 </span></span><br><span class=\"line\">        face_cas = cv.CascadeClassifier( <span class=\"string\">&quot;haarcascade_frontalface_default.xml&quot;</span> ) </span><br><span class=\"line\">        face_cas.load(<span class=\"string\">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 4.调用识别人脸 </span></span><br><span class=\"line\">        faceRects = face_cas.detectMultiScale(gray, scaleFactor=<span class=\"number\">1.2</span>, minNeighbors=<span class=\"number\">3</span>, minSize=(<span class=\"number\">32</span>, <span class=\"number\">32</span>)) </span><br><span class=\"line\">        <span class=\"keyword\">for</span> faceRect <span class=\"keyword\">in</span> faceRects: </span><br><span class=\"line\">            x, y, w, h = faceRect </span><br><span class=\"line\">            <span class=\"comment\"># 框出人脸 </span></span><br><span class=\"line\">            cv.rectangle(frame, (x, y), (x + h, y + w),(<span class=\"number\">0</span>,<span class=\"number\">255</span>,<span class=\"number\">0</span>), <span class=\"number\">3</span>) </span><br><span class=\"line\">        cv.imshow(<span class=\"string\">&quot;frame&quot;</span>,frame)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> cv.waitKey(<span class=\"number\">1</span>) &amp; <span class=\"number\">0xFF</span> == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"comment\"># 5. 释放资源</span></span><br><span class=\"line\">cap.release()  </span><br><span class=\"line\">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>\r\n",
            "tags": [
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/OpenCV/%E8%A7%86%E9%A2%91%E8%BF%BD%E8%B8%AA/",
            "url": "https://liujk6525.github.io/OpenCV/%E8%A7%86%E9%A2%91%E8%BF%BD%E8%B8%AA/",
            "title": "视频追踪",
            "date_published": "2023-05-20T05:31:48.000Z",
            "content_html": "<h1 id=\"视频读写\">视频读写</h1>\r\n<h2 id=\"读取视频\">读取视频</h2>\r\n<p><strong>创建读取视频的对象</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cap = cv.VideoCapture(filepath)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>filepath：视频文件路径</p>\r\n<span id=\"more\"></span></li>\r\n</ul>\r\n<p><strong>获取视频的某些属性</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retval = cap.get(propId)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>propId: 从0到18的数字，每个数字表示视频的属性</p>\r\n<p>常用属性有：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191016164053661-1684560896151-1.png\"  style=\"zoom: 33%;\" /></p></li>\r\n</ul>\r\n<p><strong>修改视频的属性信息</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cap.<span class=\"built_in\">set</span>(propId，value)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>proid：属性的索引，与上面的表格相对应</li>\r\n<li>value：修改后的属性值</li>\r\n</ul>\r\n<p><strong>判断图像是否读取成功</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">isornot = cap.isOpened()</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>若读取成功则返回true，否则返回False</li>\r\n</ul>\r\n<p><strong>获取视频的一帧图像</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret, frame = cap.read()</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>ret：若获取成功返回True，获取失败，返回False</li>\r\n<li>frame：获取到的某一帧的图像</li>\r\n</ul>\r\n<p><strong>将视频释放掉</strong></p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cap.realease()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"示例代码\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"comment\"># 1.获取视频对象</span></span><br><span class=\"line\">cap = cv.VideoCapture(<span class=\"string\">&#x27;DOG.wmv&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2.判断是否读取成功</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(cap.isOpened()):</span><br><span class=\"line\">    <span class=\"comment\"># 3.获取每一帧图像</span></span><br><span class=\"line\">    ret, frame = cap.read()</span><br><span class=\"line\">    <span class=\"comment\"># 4. 获取成功显示图像</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ret == <span class=\"literal\">True</span>:</span><br><span class=\"line\">        cv.imshow(<span class=\"string\">&#x27;frame&#x27;</span>,frame)</span><br><span class=\"line\">    <span class=\"comment\"># 5.每一帧间隔为25ms</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> cv.waitKey(<span class=\"number\">25</span>) &amp; <span class=\"number\">0xFF</span> == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"comment\"># 6.释放视频对象</span></span><br><span class=\"line\">cap.release()</span><br><span class=\"line\">cv.destoryAllwindows()</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"保存视频\">保存视频</h1>\r\n<p><strong>创建视频写入的对象</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out = cv2.VideoWriter(filename,fourcc, fps, frameSize)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>filename：视频保存的位置</li>\r\n<li>fourcc：指定视频编解码器的4字节代码</li>\r\n<li>fps：帧率</li>\r\n<li>frameSize：帧大小</li>\r\n</ul>\r\n<p><strong>设置视频的编解码器</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">retval = cv2.VideoWriter_fourcc( c1, c2, c3, c4 )</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>c1,c2,c3,c4：是视频编解码器的4字节代码，常用的有：</p>\r\n<ul>\r\n<li><p>在Windows中：DIVX（.avi）</p></li>\r\n<li><p>在OS中：MJPG（.mp4），DIVX（.avi），X264（.mkv）。</p></li>\r\n</ul></li>\r\n</ul>\r\n<p><strong>获取视频的一帧图像</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ret, frame = cap.read()</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>ret：若获取成功返回True，获取失败，返回False</li>\r\n<li>frame：获取到的某一帧的图像</li>\r\n</ul>\r\n<p><strong>某一帧图像写入视频</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">out.write()</span><br></pre></td></tr></table></figure>\r\n<p><strong>释放资源</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cap.release()</span><br><span class=\"line\">out.release()</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"示例代码-1\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1. 读取视频</span></span><br><span class=\"line\">cap = cv.VideoCapture(<span class=\"string\">&quot;DOG.wmv&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 获取图像的属性（宽和高，）,并将其转换为整数</span></span><br><span class=\"line\">frame_width = <span class=\"built_in\">int</span>(cap.get(<span class=\"number\">3</span>))</span><br><span class=\"line\">frame_height = <span class=\"built_in\">int</span>(cap.get(<span class=\"number\">4</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 创建保存视频的对象，设置编码格式，帧率，图像的宽高等</span></span><br><span class=\"line\">out = cv.VideoWriter(<span class=\"string\">&#x27;outpy.avi&#x27;</span>,cv.VideoWriter_fourcc(<span class=\"string\">&#x27;M&#x27;</span>,<span class=\"string\">&#x27;J&#x27;</span>,<span class=\"string\">&#x27;P&#x27;</span>,<span class=\"string\">&#x27;G&#x27;</span>), <span class=\"number\">10</span>, (frame_width,frame_height))</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">True</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 4.获取视频中的每一帧图像</span></span><br><span class=\"line\">    ret, frame = cap.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ret == <span class=\"literal\">True</span>: </span><br><span class=\"line\">        <span class=\"comment\"># 5.将每一帧图像写入到输出文件中</span></span><br><span class=\"line\">        out.write(frame)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 6.释放资源</span></span><br><span class=\"line\">cap.release()</span><br><span class=\"line\">out.release()</span><br><span class=\"line\">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"视频追踪\">视频追踪</h1>\r\n<h2 id=\"meanshift算法\"><code>meanshift算法</code></h2>\r\n<p>假设有一堆点集，还有一个小的窗口，这个窗口可能是圆形的，现在你可能要移动这个窗口到点集密度最大的区域当中。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image1-0784863-1684561795932-3.jpg\" style=\"zoom:67%;\" /></p>\r\n<p>最开始的窗口是蓝色圆环的区域，命名为<span class=\"math inline\">\\(C1\\)</span>。蓝色圆环的圆心用一个蓝色的矩形标注，命名为<span class=\"math inline\">\\(C1_o\\)</span>。而窗口中所有点的点集构成的质心在蓝色圆形点<span class=\"math inline\">\\(C1_r\\)</span>处，显然圆环的形心和质心并不重合。所以，移动蓝色的窗口，使得形心与之前得到的质心重合。在新移动后的圆环的区域当中再次寻找圆环当中所包围点集的质心，然后再次移动，通常情况下，形心和质心是不重合的。不断执行上面的移动过程，直到形心和质心大致重合结束。 这样，最后圆形的窗口会落到像素分布最大的地方，也就是图中的绿色圈，命名为<span class=\"math inline\">\\(C2\\)</span>。</p>\r\n<ol type=\"1\">\r\n<li><p>首先在图像上选定一个目标区域</p></li>\r\n<li><p>计算选定区域的直方图分布，一般是<code>HSV</code>色彩空间的直方图。</p></li>\r\n<li><p>对下一帧图像<span class=\"math inline\">\\(b\\)</span>同样计算直方图分布。</p></li>\r\n<li><p>计算图像<span class=\"math inline\">\\(b\\)</span>当中与选定区域直方图分布最为相似的区域，使用<code>meanshift算法</code>将选定区域沿着最为相似的部分进行移动，直到找到最相似的区域，便完成了在图像<span class=\"math inline\">\\(b\\)</span>中的目标追踪。</p></li>\r\n<li><p>重复3、4的过程，就完成整个视频目标追踪。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image2-0785334-1684562460307-7.gif\"  style=\"zoom: 80%;\" /></p></li>\r\n</ol>\r\n<p>通常情况下使用<strong>直方图反向投影</strong>得到的图像和第一帧目标对象的起始位置，目标对象的移动会反映到直方图反向投影图中，<code>meanshift 算法</code>把窗口移动到反向投影图像中灰度密度最大的区域。</p>\r\n<p>直方图反向投影的流程是：</p>\r\n<ol type=\"1\">\r\n<li>假设我们有一张<span class=\"math inline\">\\(100\\times100\\)</span>的输入图像，有一张<span class=\"math inline\">\\(10\\times10\\)</span>的模板图像，</li>\r\n<li>从输入图像的左上角<span class=\"math inline\">\\((0,0)\\)</span>开始，切割一块<span class=\"math inline\">\\((0,0)\\)</span>至<span class=\"math inline\">\\((10,10)\\)</span>的临时图像，</li>\r\n<li>生成临时图像的直方图，</li>\r\n<li>用临时图像的直方图和模板图像的直方图对比，对比结果记为<span class=\"math inline\">\\(c\\)</span>，</li>\r\n<li>直方图对比结果<span class=\"math inline\">\\(c\\)</span>，就是结果图像<span class=\"math inline\">\\((0,0)\\)</span>处的像素值，</li>\r\n<li>切割输入图像从<span class=\"math inline\">\\((0,1)\\)</span>至<span class=\"math inline\">\\((10,11)\\)</span>的临时图像，对比直方图，并记录到结果图像，</li>\r\n<li>重复1～5步直到输入图像的右下角，就形成了直方图的反向投影。</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.meanShift(probImage, window, criteria)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>probImage: ROI区域，即目标的直方图的反向投影</li>\r\n<li>window： 初始搜索窗口，就是定义ROI的rect</li>\r\n<li>criteria: 确定窗口搜索停止的准则，主要有迭代次数达到设置的最大值，窗口中心的漂移值大于某个设定的限值等。</li>\r\n</ul>\r\n<h3 id=\"示例代码-2\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"comment\"># 1.获取图像</span></span><br><span class=\"line\">cap = cv.VideoCapture(<span class=\"string\">&#x27;DOG.wmv&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.获取第一帧图像，并指定目标位置</span></span><br><span class=\"line\">ret,frame = cap.read()</span><br><span class=\"line\"><span class=\"comment\"># 2.1 目标位置（行，高，列，宽）</span></span><br><span class=\"line\">r,h,c,w = <span class=\"number\">197</span>,<span class=\"number\">141</span>,<span class=\"number\">0</span>,<span class=\"number\">208</span>  </span><br><span class=\"line\">track_window = (c,r,w,h)</span><br><span class=\"line\"><span class=\"comment\"># 2.2 指定目标的感兴趣区域</span></span><br><span class=\"line\">roi = frame[r:r+h, c:c+w]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 计算直方图</span></span><br><span class=\"line\"><span class=\"comment\"># 3.1 转换色彩空间（HSV）</span></span><br><span class=\"line\">hsv_roi =  cv.cvtColor(roi, cv.COLOR_BGR2HSV)</span><br><span class=\"line\"><span class=\"comment\"># 3.2 去除低亮度的值</span></span><br><span class=\"line\"><span class=\"comment\"># mask = cv.inRange(hsv_roi, np.array((0., 60.,32.)), np.array((180.,255.,255.)))</span></span><br><span class=\"line\"><span class=\"comment\"># 3.3 计算直方图</span></span><br><span class=\"line\">roi_hist = cv.calcHist([hsv_roi],[<span class=\"number\">0</span>],<span class=\"literal\">None</span>,[<span class=\"number\">180</span>],[<span class=\"number\">0</span>,<span class=\"number\">180</span>])</span><br><span class=\"line\"><span class=\"comment\"># 3.4 归一化</span></span><br><span class=\"line\">cv.normalize(roi_hist,roi_hist,<span class=\"number\">0</span>,<span class=\"number\">255</span>,cv.NORM_MINMAX)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 目标追踪</span></span><br><span class=\"line\"><span class=\"comment\"># 4.1 设置窗口搜索终止条件：最大迭代次数，窗口中心漂移最小值</span></span><br><span class=\"line\">term_crit = ( cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, <span class=\"number\">10</span>, <span class=\"number\">1</span> )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">True</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 4.2 获取每一帧图像</span></span><br><span class=\"line\">    ret ,frame = cap.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ret == <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 4.3 计算直方图的反向投影</span></span><br><span class=\"line\">        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class=\"line\">        dst = cv.calcBackProject([hsv],[<span class=\"number\">0</span>],roi_hist,[<span class=\"number\">0</span>,<span class=\"number\">180</span>],<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 4.4 进行meanshift追踪</span></span><br><span class=\"line\">        ret, track_window = cv.meanShift(dst, track_window, term_crit)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 4.5 将追踪的位置绘制在视频上，并进行显示</span></span><br><span class=\"line\">        x,y,w,h = track_window</span><br><span class=\"line\">        img2 = cv.rectangle(frame, (x,y), (x+w,y+h), <span class=\"number\">255</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">        cv.imshow(<span class=\"string\">&#x27;frame&#x27;</span>,img2)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cv.waitKey(<span class=\"number\">60</span>) &amp; <span class=\"number\">0xFF</span> == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">break</span>        </span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"comment\"># 5. 资源释放        </span></span><br><span class=\"line\">cap.release()</span><br><span class=\"line\">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191011180244485-1684561868819-5.png\"  style=\"zoom: 50%;\" /></p>\r\n<h1 id=\"camshift算法\">Camshift算法</h1>\r\n<p>检测的窗口的大小是固定的，而狗狗由近及远是一个逐渐变小的过程，固定的窗口是不合适的。所以需要根据目标的大小和角度来对窗口的大小和角度进行修正。</p>\r\n<p>连续自适应<code>MeanShift</code>(Continuously Adaptive Mean-Shift，<a href=\"https://baike.baidu.com/item/Camshift/5302311\">Camshift</a>)算法是对<code>MeanShift算法</code>的改进算法，可随着跟踪目标的大小变化实时调整搜索窗口的大小，具有较好的跟踪效果。</p>\r\n<p>首先应用<code>meanshift</code>，一旦<code>meanshift</code>收敛，它就会更新窗口的大小，还计算最佳拟合椭圆的方向，从而根据目标的位置和大小更新搜索窗口。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image4-1684563103560-9.gif\"  style=\"zoom: 80%;\" /></p>\r\n<h3 id=\"示例代码-3\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"comment\"># 1.获取图像</span></span><br><span class=\"line\">cap = cv.VideoCapture(<span class=\"string\">&#x27;DOG.wmv&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.获取第一帧图像，并指定目标位置</span></span><br><span class=\"line\">ret,frame = cap.read()</span><br><span class=\"line\"><span class=\"comment\"># 2.1 目标位置（行，高，列，宽）</span></span><br><span class=\"line\">r,h,c,w = <span class=\"number\">197</span>,<span class=\"number\">141</span>,<span class=\"number\">0</span>,<span class=\"number\">208</span>  </span><br><span class=\"line\">track_window = (c,r,w,h)</span><br><span class=\"line\"><span class=\"comment\"># 2.2 指定目标的感兴趣区域</span></span><br><span class=\"line\">roi = frame[r:r+h, c:c+w]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 计算直方图</span></span><br><span class=\"line\"><span class=\"comment\"># 3.1 转换色彩空间（HSV）</span></span><br><span class=\"line\">hsv_roi =  cv.cvtColor(roi, cv.COLOR_BGR2HSV)</span><br><span class=\"line\"><span class=\"comment\"># 3.2 去除低亮度的值</span></span><br><span class=\"line\"><span class=\"comment\"># mask = cv.inRange(hsv_roi, np.array((0., 60.,32.)), np.array((180.,255.,255.)))</span></span><br><span class=\"line\"><span class=\"comment\"># 3.3 计算直方图</span></span><br><span class=\"line\">roi_hist = cv.calcHist([hsv_roi],[<span class=\"number\">0</span>],<span class=\"literal\">None</span>,[<span class=\"number\">180</span>],[<span class=\"number\">0</span>,<span class=\"number\">180</span>])</span><br><span class=\"line\"><span class=\"comment\"># 3.4 归一化</span></span><br><span class=\"line\">cv.normalize(roi_hist,roi_hist,<span class=\"number\">0</span>,<span class=\"number\">255</span>,cv.NORM_MINMAX)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 目标追踪</span></span><br><span class=\"line\"><span class=\"comment\"># 4.1 设置窗口搜索终止条件：最大迭代次数，窗口中心漂移最小值</span></span><br><span class=\"line\">term_crit = ( cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, <span class=\"number\">10</span>, <span class=\"number\">1</span> )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">True</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 4.2 获取每一帧图像</span></span><br><span class=\"line\">    ret ,frame = cap.read()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ret == <span class=\"literal\">True</span>:</span><br><span class=\"line\">        <span class=\"comment\"># 4.3 计算直方图的反向投影</span></span><br><span class=\"line\">        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class=\"line\">        dst = cv.calcBackProject([hsv],[<span class=\"number\">0</span>],roi_hist,[<span class=\"number\">0</span>,<span class=\"number\">180</span>],<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 4.4 进行camshift追踪</span></span><br><span class=\"line\">   \t \tret, track_window = cv.CamShift(dst, track_window, term_crit)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># 绘制追踪结果</span></span><br><span class=\"line\">        pts = cv.boxPoints(ret)</span><br><span class=\"line\">        pts = np.int0(pts)</span><br><span class=\"line\">        img2 = cv.polylines(frame,[pts],<span class=\"literal\">True</span>, <span class=\"number\">255</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">        cv.imshow(<span class=\"string\">&#x27;frame&#x27;</span>,img2)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> cv.waitKey(<span class=\"number\">60</span>) &amp; <span class=\"number\">0xFF</span> == <span class=\"built_in\">ord</span>(<span class=\"string\">&#x27;q&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">break</span>        </span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\"><span class=\"comment\"># 5. 资源释放        </span></span><br><span class=\"line\">cap.release()</span><br><span class=\"line\">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"总结\">总结</h1>\r\n<p><code>Meanshift</code>和<code>camshift</code>算法都各有优势，自然也有劣势：</p>\r\n<ul>\r\n<li><code>Meanshift算法</code>：简单，迭代次数少，但无法解决目标的遮挡问题并且不能适应运动目标的的形状和大小变化。</li>\r\n<li><code>camshift算法</code>：可适应运动目标的大小形状的改变，具有较好的跟踪效果，但当背景色和目标颜色接近时，容易使目标的区域变大，最终有可能导致目标跟踪丢失。</li>\r\n</ul>\r\n",
            "tags": [
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/OpenCV/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E6%8F%8F%E8%BF%B0/",
            "url": "https://liujk6525.github.io/OpenCV/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E6%8F%8F%E8%BF%B0/",
            "title": "图像特征提取与描述",
            "date_published": "2023-05-19T15:38:12.000Z",
            "content_html": "<h1 id=\"角点特征\">角点特征</h1>\r\n<p>如下图所示，蓝色框中的区域是一个平面，无论向哪个方向移动蓝色框，都是一样的。对于黑色框中的区域，它是一个边缘。如果沿垂直方向移动，它会改变。但是如果沿水平方向移动就不会改变。而红色框中的角点，无论你向那个方向移动，得到的结果都不同，这说明它是唯一的。 所以说，角点是一个好的图像特征。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008141945745-1684510965118-1.png\"  style=\"zoom: 80%;\" /></p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"harris和shi-tomas算法\">Harris和Shi-Tomas算法</h1>\r\n<h2 id=\"harris角点检测\">Harris角点检测</h2>\r\n<p>Harris角点检测的思想是通过图像的局部的小窗口观察图像，角点的特征是窗口沿任意方向移动都会导致图像灰度的明显变化，如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008144647540-1684511183358-3.png\"  style=\"zoom: 33%;\" /></p>\r\n<p>将局部窗口向各个方向移动<span class=\"math inline\">\\((u,v)\\)</span>，并计算所有灰度差异的总和，表达式如下： <span class=\"math display\">\\[\r\nE(u,v)=\\sum_{x,y}w(x,y)[I(x+u,y+v)-I(x,y)]^2\r\n\\]</span> 其中<span class=\"math inline\">\\(E(u,v)\\)</span>是局部窗口的图像灰度，<span class=\"math inline\">\\(I(x+u,y+v)\\)</span>是平移后的图像灰度，<span class=\"math inline\">\\(w(x,y)\\)</span>是窗口函数，该可以是矩形窗口，也可以是对每一个像素赋予不同权重的高斯窗口，如下所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008153014984-1684511417820-5.png\"  style=\"zoom: 50%;\" /></p>\r\n<p>角点检测中使<span class=\"math inline\">\\(E(u,v)\\)</span>的值最大。利用一阶泰勒展开有： <span class=\"math display\">\\[\r\nI(x+u,y+v)=I(x,y)+I_xu+I_yv\r\n\\]</span> 其中<span class=\"math inline\">\\(I_x\\)</span>和<span class=\"math inline\">\\(I_y\\)</span>是沿<span class=\"math inline\">\\(x\\)</span>和<span class=\"math inline\">\\(y\\)</span>方向的导数，可用<code>sobel算子</code>计算 <span class=\"math display\">\\[\r\nE(u,v)=\\sum_{x,y}w(x,y)[I(x+u,y+v)-I(x,y)]^2\r\n\\]</span> <span class=\"math display\">\\[\r\n=\\sum_{x,y}w(x,y)[I(x,y)+I_xu+I_yv-I(x,y)]^2\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\sum_{x,y}w(x,y)[I_x^2u^2+2I_xI_yuv+I_y^2v^2]\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\sum_{x,y}w(x,y)\\left[\\begin{matrix}u&amp;v\\end{matrix}\\right]\r\n\\left[\\begin{matrix}I_x^2&amp;I_xI_y\\\\I_xI_y&amp;I_y^2\\end{matrix}\\right]\r\n\\left[\\begin{matrix}u\\\\v\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n=\\left[\\begin{matrix}u&amp;v\\end{matrix}\\right]\\underbrace{\\sum_{x,y}w(x,y)\r\n\\left[\\begin{matrix}I_x^2&amp;I_xI_y\\\\I_xI_y&amp;I_y^2\\end{matrix}\\right]}_M\r\n\\left[\\begin{matrix}u\\\\v\\end{matrix}\\right]=\\left[\\begin{matrix}u&amp;v\\end{matrix}\\right]M\r\n\\left[\\begin{matrix}u\\\\v\\end{matrix}\\right]\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(M\\)</span>矩阵决定了<span class=\"math inline\">\\(E(u,v)\\)</span>的取值，下面我们利用<span class=\"math inline\">\\(M\\)</span>来求角点，<span class=\"math inline\">\\(M\\)</span>是<span class=\"math inline\">\\(I_x\\)</span>和<span class=\"math inline\">\\(I_y\\)</span>的二次项函数，可以表示成椭圆的形状，椭圆的长短半轴由<span class=\"math inline\">\\(M\\)</span>的特征值<span class=\"math inline\">\\(\\lambda_1\\)</span>和<span class=\"math inline\">\\(\\lambda_2\\)</span>决定，方向由特征矢量决定，如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008160908338-1684512358754-7.png\"  style=\"zoom: 60%;\" /></p>\r\n<p>椭圆函数特征值与图像中的角点、直线（边缘）和平面之间的关系如下图所示。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008161040473-1684512385628-9.png\"  style=\"zoom: 45%;\" /></p>\r\n<p>共可分为三种情况：</p>\r\n<ol type=\"1\">\r\n<li>图像中的直线。一个特征值大，另一个特征值小，<span class=\"math inline\">\\(\\lambda_1&gt;&gt;\\lambda_2\\)</span>或 <span class=\"math inline\">\\(\\lambda_2&gt;&gt;\\lambda_1\\)</span>。椭圆函数值在某一方向上大，在其他方向上小。</li>\r\n<li>图像中的平面。两个特征值都小，且近似相等；椭圆函数数值在各个方向上都小。</li>\r\n<li>图像中的角点。两个特征值都大，且近似相等，椭圆函数在所有方向都增大</li>\r\n</ol>\r\n<p>Harris给出的角点计算方法并不需要计算具体的特征值，而是计算一个<strong>角点响应值<span class=\"math inline\">\\(R\\)</span></strong>来判断角点。<span class=\"math inline\">\\(R\\)</span>的计算公式是 <span class=\"math display\">\\[\r\nR=detM-\\alpha(traceM)^2\\\\\r\ndetM=\\lambda_1\\lambda_2\\\\\r\ntraceM=\\lambda_1+\\lambda_2\r\n\\]</span> 式中，<span class=\"math inline\">\\(detM\\)</span>为矩阵<span class=\"math inline\">\\(M\\)</span>的行列式；<span class=\"math inline\">\\(traceM\\)</span>为矩阵<span class=\"math inline\">\\(M\\)</span>的迹；<span class=\"math inline\">\\(\\alpha\\)</span>为常数，取值范围为0.04~0.06。</p>\r\n<p>如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008161904372-1684512700094-11.png\"  style=\"zoom: 50%;\" /></p>\r\n<ul>\r\n<li>当R为大数值的正数时是角点</li>\r\n<li>当R为大数值的负数时是边界</li>\r\n<li>当R为小数是认为是平坦区域</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dst=cv.cornerHarris(src, blockSize, ksize, k)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img：数据类型为 ﬂoat32 的输入图像。</li>\r\n<li>blockSize：角点检测中要考虑的邻域大小。</li>\r\n<li>ksize：<code>sobel算子</code>求导使用的核大小。</li>\r\n<li>k：角点检测方程中的自由参数，取值参数为 [0.04，0.06]。</li>\r\n</ul>\r\n<h3 id=\"示例代码\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像，并转换成灰度图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/chessboard.jpg&#x27;</span>)</span><br><span class=\"line\">gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class=\"line\"><span class=\"comment\"># 2 角点检测</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 输入图像必须是 float32</span></span><br><span class=\"line\">gray = np.float32(gray)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2 最后一个参数在 0.04 到 0.05 之间</span></span><br><span class=\"line\">dst = cv.cornerHarris(gray,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">0.04</span>)</span><br><span class=\"line\"><span class=\"comment\"># 3 设置阈值，将角点绘制出来，阈值根据图像进行选择</span></span><br><span class=\"line\">img[dst&gt;<span class=\"number\">0.001</span>*dst.<span class=\"built_in\">max</span>()] = [<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>]</span><br><span class=\"line\"><span class=\"comment\"># 4 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;Harris角点检测&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008164344988-1684512767151-13.png\"  style=\"zoom: 33%;\" /></p>\r\n<p>Harris角点检测的优缺点：</p>\r\n<p>优点：</p>\r\n<ul>\r\n<li>旋转不变性，椭圆转过一定角度但是其形状保持不变（特征值保持不变）</li>\r\n<li>对于图像灰度的仿射变化具有部分的不变性，由于仅仅使用了图像的一介导数，对于图像灰度平移变化不变；对于图像灰度尺度变化不变</li>\r\n</ul>\r\n<p>缺点：</p>\r\n<ul>\r\n<li>对尺度很敏感，不具备几何尺度不变性。</li>\r\n<li>提取的角点是像素级的</li>\r\n</ul>\r\n<h2 id=\"shi-tomasi角点检测\">Shi-Tomasi角点检测</h2>\r\n<p><code>Shi-Tomasi算法</code>是对<code>Harris算法</code>的改进，具体地：若矩阵M的两个特征值<span class=\"math inline\">\\(\\lambda_1,\\lambda_2\\)</span>中较小的一个大于阈值，则认为他是角点，即： <span class=\"math display\">\\[\r\nR=min(\\lambda_1,\\lambda_2)\r\n\\]</span></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">corners = cv2.goodFeaturesToTrack ( image, maxcorners, qualityLevel, minDistance )</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>Image：输入灰度图像</li>\r\n<li>maxCorners：获取角点数的数目。</li>\r\n<li>qualityLevel：指出最低可接受的角点质量水平，在0-1之间。</li>\r\n<li>minDistance：角点之间最小的欧式距离，避免得到相邻特征点。</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>Corners: 搜索到的角点，在这里所有低于质量水平的角点被排除掉，然后把合格的角点按质量排序，然后将质量较好的角点附近（小于最小欧式距离）的角点删掉，最后找到maxCorners个角点返回。</li>\r\n</ul>\r\n<h3 id=\"示例代码-1\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np </span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/tv.jpg&#x27;</span>) </span><br><span class=\"line\">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class=\"line\"><span class=\"comment\"># 2 角点检测</span></span><br><span class=\"line\">corners = cv.goodFeaturesToTrack(gray,<span class=\"number\">1000</span>,<span class=\"number\">0.01</span>,<span class=\"number\">10</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 3 绘制角点</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> corners:</span><br><span class=\"line\">    x,y = i.ravel()</span><br><span class=\"line\">    cv.circle(img,(x,y),<span class=\"number\">2</span>,(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>),-<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 4 图像展示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;shi-tomasi角点检测&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008174257711.png\"  style=\"zoom: 45%;\" /></p>\r\n<h1 id=\"sift和surf算法\">SIFT和SURF算法</h1>\r\n<h2 id=\"sift算法\"><a href=\"https://baike.baidu.com/item/SIFT/1396275?fr=aladdin\">SIFT算法</a></h2>\r\n<p><code>Harris</code>和<code>Shi-Tomasi</code>角点检测算法具有旋转不变性，但不具有尺度不变性，以下图为例，在左侧小图中可以检测到角点，但是图像被放大后，在使用同样的窗口，就检测不到角点了。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008181535222-1684547971195-2.png\"  style=\"zoom: 80%;\" /></p>\r\n<p><strong>尺度不变特征转换</strong>（Scale-invariant feature transform，SIFT）。此算法由 David Lowe在1999年所发表，2004年完善总结。它的实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如<strong>角点、边缘点、暗区的亮点及亮区的暗点</strong>等。</p>\r\n<ol type=\"1\">\r\n<li>尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯差分函数来识别潜在的对于尺度和旋转不变的关键点。</li>\r\n<li>关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。</li>\r\n<li>关键点方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而保证了对于这些变换的不变性。</li>\r\n<li>关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度作为关键点的描述符，它允许比较大的局部形状的变形或光照变化。</li>\r\n</ol>\r\n<h3 id=\"尺度空间极值检测\">尺度空间极值检测</h3>\r\n<p>在不同的尺度空间是不能使用相同的窗口检测极值点，对小的关键点使用小的窗口，对大的关键点使用大的窗口，为了达到上述目的，使用<strong>尺度空间滤波器</strong>。（高斯核是唯一可以产生多尺度空间的核函数）</p>\r\n<p>一个图像的尺度空间<span class=\"math inline\">\\(L(x,y,\\sigma)\\)</span>定义为原始图像<span class=\"math inline\">\\(I(x,y)\\)</span>与一个可变尺度的2维高斯函数<span class=\"math inline\">\\(G(x,y,\\sigma)\\)</span><strong>卷积运算</strong> ，即： <span class=\"math display\">\\[\r\nL(x,y,\\sigma)=G(x,y,\\sigma)*I(x,y)\r\n\\]</span> 其中<span class=\"math inline\">\\(\\sigma\\)</span>是尺度空间因子，它决定图像的模糊程度。在大尺度下(<span class=\"math inline\">\\(\\sigma\\)</span>值大)表现的是图像的概貌信息，在小尺度下(<span class=\"math inline\">\\(\\sigma\\)</span>值小)表现的是图像的细节信息。</p>\r\n<p>在计算高斯函数的离散近似时，在大概<span class=\"math inline\">\\(3\\sigma\\)</span>距离之外的像素都可以看作不起作用，这些像素的计算也就可以忽略。所以，在实际应用中，只计算<span class=\"math inline\">\\((6\\sigma+1)\\times(6\\sigma+1)\\)</span>的高斯卷积核就可以保证相关像素影响。</p>\r\n<p>下面构建图像的高斯金字塔，它采用高斯函数对图像进行模糊以及降采样处理得到的， 1. 将图像扩大一倍，在扩大的图像的基础之上构建高斯金字塔， 2. 对该尺寸下图像进行高斯模糊，几幅模糊之后的图像集合构成了一个Octave， 3. 对该Octave下选择一幅图像进行下采样，长和宽分别缩短一倍，图像面积变为原来四分之一。这幅图像就是下一个Octave的初始图像，在初始图像的基础上完成属于这个Octave的高斯模糊处理， 4. 以此类推，完成整个算法。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191009110944907-1684549584975-4.png\"  style=\"zoom: 40%;\" /></p>\r\n<p>利用高斯拉普拉斯算子(Laplacian of Gaussian, <code>LoG</code>)，即图像的二阶导数，可以在不同的尺度下检测图像的关键点信息，从而确定图像的特征点。但<code>LoG</code>的计算量大，效率低。所以通过两个相邻高斯尺度空间的图像相减，得到高斯差分(Difference of Gaussians，<a href=\"https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%B7%AE%E5%88%86%E5%87%BD%E6%95%B0/1597793?fr=aladdin\">DOG</a>)来近似<code>LoG</code>。</p>\r\n<ol type=\"1\">\r\n<li>构建<strong>高斯差分金字塔</strong>\r\n<ul>\r\n<li>将<strong>高斯金字塔</strong>中每个Octave中相邻两层相减就构成了高斯差分金字塔。</li>\r\n<li>高斯差分金字塔的<strong>第o组第i层图</strong>像是由高斯金字塔的<strong>第o组第i+1层减第o组第i层</strong>得到的。</li>\r\n</ul></li>\r\n</ol>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191009113953721-1684549912508-6.png\"  style=\"zoom: 33%;\" /></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>在不同的尺度空间中搜索局部最大值\r\n<ul>\r\n<li>对于图像中的每一个像素点而言，它需要与自己周围的<span class=\"math inline\">\\(8\\)</span>邻域，以及尺度空间中上下两层中的相邻的<span class=\"math inline\">\\(18(2\\times9)\\)</span>个点相比。</li>\r\n<li>如果是局部最大值，它就可能是一个关键点。 <img src=\"/imgs/$%7Bfiilename%7D/image-20191009115023016-1684549955480-8.png\" style=\"zoom:50%;\" /></li>\r\n<li>搜索过程从每组的第二层开始，以第二层为当前层，对第二层的<code>DoG</code>图像中的每个点取一个<span class=\"math inline\">\\(3\\times3\\)</span>的立方体，立方体上下层为第一层与第三层。搜索得到的极值点既有位置坐标(<code>DoG</code>的图像坐标)，又有空间尺度坐标(层坐标)。</li>\r\n<li>当第二层搜索完成后，再以第三层作为当前层，其过程与第二层的搜索类似。</li>\r\n<li>当<span class=\"math inline\">\\(S=3\\)</span>时，每组里面要搜索3层，所以在高斯差分金字塔中就有<span class=\"math inline\">\\(S+2\\)</span>层，在高斯金字塔中每组有<span class=\"math inline\">\\(S+3\\)</span>层。</li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"关键点定位\">关键点定位</h3>\r\n<p>由于<code>DoG</code>对噪声和边缘比较敏感，因此在高斯差分金字塔中检测到的局部极值点需经过进一步的检验才能精确定位为特征点。</p>\r\n<p>使用尺度空间的泰勒级数展开来获得极值的准确位置， 如果<strong>极值点的灰度值小于阈值</strong>（一般为0.03或0.04）就会被忽略掉。 在 OpenCV 中这种阈值被称为 contrastThreshold。</p>\r\n<p>欠佳的关键点在平行边缘的方向有较大的主曲率，而在垂直于边缘的方向有较小的曲率，两者的比值如果高于某个阈值（在OpenCV中叫做边界阈值），就认为该关键点为边界，将被忽略，一般该阈值为10。</p>\r\n<p>将低对比度和边界的关键点去除，得到的就是我们感兴趣的关键点。</p>\r\n<h3 id=\"关键点方向确定\">关键点方向确定</h3>\r\n<p>为了实现旋转不变性，还需要为每个关键点分配一个方向角度，也就是在高斯尺度图像的邻域结构中求得一个方向基准。</p>\r\n<p>对于任一关键点，采集其所在高斯金字塔图像以<span class=\"math inline\">\\(r\\)</span>为半径的区域内所有像素的梯度特征（幅值和幅角），<span class=\"math inline\">\\(r=3\\times1.5\\sigma\\)</span>，其中<span class=\"math inline\">\\(\\sigma\\)</span>是关键点所在octave的图像的尺度，可以得到对应的尺度图像。</p>\r\n<p>梯度的幅值和方向的计算公式为： <span class=\"math display\">\\[\r\nm(x,y)=\\sqrt{(L(x+1,y)-L(x-1,y))^2+(L(x,y+1)-L(x,y-1))^2}\r\n\\]</span> <span class=\"math display\">\\[\r\n\\theta(x,y)=\\arctan(\\frac{L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}\r\n\\]</span> 邻域像素梯度的计算结果如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191009143818527-1684552168908-10.png\"  style=\"zoom:50%;\" /></p>\r\n<p>使用直方图统计关键点邻域内像素的梯度幅值和方向。</p>\r\n<ol type=\"1\">\r\n<li><p>将<span class=\"math inline\">\\(360^\\circ\\)</span>分为<span class=\"math inline\">\\(36\\)</span>柱，每<span class=\"math inline\">\\(10^\\circ\\)</span>为一柱，然后在以<span class=\"math inline\">\\(r\\)</span>为半径的区域内，将梯度方向在某一个柱内的像素找出来。</p></li>\r\n<li><p>将他们的幅值相加在一起作为柱的高度。因为在r为半径的区域内像素的梯度幅值对中心像素的贡献是不同的，因此还需要对幅值进行加权处理，采用高斯加权，方差为<span class=\"math inline\">\\(1.5\\sigma\\)</span>。 <img src=\"/imgs/$%7Bfiilename%7D/image-20191009144726492-1684552637576-16.png\"  style=\"zoom:33%;\" /></p></li>\r\n<li><p>每个特征点必须分配一个主方向，还需要一个或多个辅方向，增加辅方向的目的是为了增强图像匹配的鲁棒性。辅方向的定义是，当一个柱体的高度大于主方向柱体高度的<span class=\"math inline\">\\(80\\%\\)</span>时，则该柱体所代表的的方向就是给特征点的辅方向。</p></li>\r\n<li><p>直方图的峰值，即最高的柱代表的方向是特征点邻域范围内图像梯度的主方向，但该柱体代表的角度是一个范围，所以我们还要对离散的直方图进行插值拟合，以得到更精确的方向角度值。利用抛物线对离散的直方图进行拟合。 <img src=\"/imgs/$%7Bfiilename%7D/image-20191009150008701-1684552598604-14.png\" style=\"zoom: 40%;\" /></p></li>\r\n</ol>\r\n<p>获得图像关键点主方向后，使用一个带箭头的圆或直接使用箭头表示SIFT区域的三个值：中心表示特征点位置<span class=\"math inline\">\\((x,y)\\)</span>，半径表示关键点尺度<span class=\"math inline\">\\((\\sigma)\\)</span>，箭头表示方向<span class=\"math inline\">\\((\\theta)\\)</span>。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191025112522974-1684552568027-12.png\"  style=\"zoom:50%;\" /></p>\r\n<h3 id=\"关键点描述\">关键点描述</h3>\r\n<p>为每个关键点建立一个描述符，该描述符既具有可区分性，又具有对某些变量的不变性，如光照，视角等。而且描述符不仅仅包含关键点，也包括关键点周围对其有贡献的的像素点。</p>\r\n<p>在关键点所在的高斯尺度图像上生成对应的描述符。以特征点为中心，将其附近邻域划分为<span class=\"math inline\">\\(d\\times d\\)</span>个子区域（一般取<span class=\"math inline\">\\(d=4\\)</span>)，每个子区域都是一个正方形，边长为<span class=\"math inline\">\\(3\\sigma\\)</span>，考虑到实际计算时，需进行三次线性插值，所以特征点邻域的为<span class=\"math inline\">\\(3\\sigma(d+1)\\times3\\sigma(d+1)\\)</span>的范围，如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191009161647267-1684552834400-18.png\"  style=\"zoom: 67%;\" /></p>\r\n<p>为了保证特征点的旋转不变性，以特征点为中心，将坐标轴旋转为关键点的主方向，如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191009161756423-1684552865043-20.png\"  style=\"zoom:67%;\" /></p>\r\n<p>计算子区域内的像素的梯度，并按照<span class=\"math inline\">\\(\\sigma=0.5d\\)</span>进行高斯加权，然后插值计算得到每个种子点的八个方向的梯度，插值方法如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191009162914982-1684552898801-22.png\"  style=\"zoom:67%;\" /></p>\r\n<p>每个种子点的梯度都是由覆盖其的<span class=\"math inline\">\\(4\\)</span>个子区域插值而得的。如图中的红色点，落在第<span class=\"math inline\">\\(0\\)</span>行和第<span class=\"math inline\">\\(1\\)</span>行之间，对这两行都有贡献。</p>\r\n<ul>\r\n<li>对第<span class=\"math inline\">\\(0\\)</span>行第<span class=\"math inline\">\\(3\\)</span>列种子点的贡献因子为<span class=\"math inline\">\\(dr\\)</span>，对第<span class=\"math inline\">\\(1\\)</span>行第<span class=\"math inline\">\\(3\\)</span>列的贡献因子为<span class=\"math inline\">\\(1-dr\\)</span>，</li>\r\n<li>对邻近两列的贡献因子为<span class=\"math inline\">\\(dc\\)</span>和<span class=\"math inline\">\\(1-dc\\)</span></li>\r\n<li>对邻近两个方向的贡献因子为<span class=\"math inline\">\\(do\\)</span>和<span class=\"math inline\">\\(1-do\\)</span>。</li>\r\n</ul>\r\n<p>最终累加在每个方向上的梯度大小为： <span class=\"math display\">\\[\r\nweight=w*dr^k(1-dr)^{(1-k)}dc^m(1-dc)^{1-m}do^n(1-do^{1-n})\r\n\\]</span> 其中<span class=\"math inline\">\\(k,m,n\\)</span>为0或为1。 如上统计<span class=\"math inline\">\\(4\\times4\\times8=128\\)</span>个梯度信息即为该关键点的特征向量，按照特征点的对每个关键点的特征向量进行排序，就得到了SIFT特征描述向量。</p>\r\n<p><strong>实例化sift</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sift = cv.xfeatures2d.SIFT_create()</span><br></pre></td></tr></table></figure>\r\n<p><strong>利用<code>sift.detectAndCompute()</code>检测关键点并计算</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kp,des = sift.detectAndCompute(gray,<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>gray：进行关键点检测的图像，注意是灰度图像</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>kp：关键点信息，包括位置，尺度，方向信息</li>\r\n<li>des：关键点描述符，每个关键点对应128个梯度信息的特征向量</li>\r\n</ul>\r\n<p><strong>将关键点检测结果绘制在图像上</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.drawKeypoints(image, keypoints, outputimage, color, flags)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>image: 原始图像</p></li>\r\n<li><p>keypoints：关键点信息，将其绘制在图像上</p></li>\r\n<li><p>outputimage：输出图片，可以是原始图像</p></li>\r\n<li><p>color：颜色设置，通过修改b、g、r的值,更改画笔的颜色</p></li>\r\n<li><p>flags：绘图功能的标识设置</p>\r\n<ul>\r\n<li><p>cv2.DRAW_MATCHES_FLAGS_DEFAULT：创建输出图像矩阵，使用现存的输出图像绘制匹配对和特征点，对每一个关键点只绘制中间点</p></li>\r\n<li><p>cv2.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG：不创建输出图像矩阵，而是在输出图像上绘制匹配对</p></li>\r\n<li><p>cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS：对每一个特征点绘制带大小和方向的关键点图形</p></li>\r\n<li><p>cv2.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS：单点的特征点不被绘制</p></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"示例代码-2\">示例代码：</h3>\r\n<p>利用SIFT算法在中央电视台的图片上检测关键点，并将其绘制出来：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv </span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/tv.jpg&#x27;</span>)</span><br><span class=\"line\">gray= cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class=\"line\"><span class=\"comment\"># 2 sift关键点检测</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 实例化sift对象</span></span><br><span class=\"line\">sift = cv.xfeatures2d.SIFT_create()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2 关键点检测：kp关键点信息包括方向，尺度，位置信息，des是关键点的描述符</span></span><br><span class=\"line\">kp,des=sift.detectAndCompute(gray,<span class=\"literal\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2.3 在图像上绘制关键点的检测结果</span></span><br><span class=\"line\">cv.drawKeypoints(img,kp,img,flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">8</span>,<span class=\"number\">6</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;sift检测&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191009181525538-1684553395070-26.png\"  style=\"zoom: 50%;\" /></p>\r\n<h2 id=\"surf算法\">SURF算法</h2>\r\n<p>使用 SIFT 算法进行关键点检测和描述的执行速度比较慢， 需要速度更快的算法。 2006 年 Bay提出了 SURF 算法，是SIFT算法的增强版，它的计算量小，运算速度快，提取的特征与SIFT几乎相同，将其与SIFT算法对比如下：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191016163330835-1684553312569-24.png\"  style=\"zoom:67%;\" /></p>\r\n<h1 id=\"fast和orb算法\">Fast和ORB算法</h1>\r\n<h2 id=\"fast算法\"><a href=\"https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test\">Fast算法</a></h2>\r\n<p>Fast(Features from accelerated segment test)是一种角点检测算法，Edward Rosten和Tom Drummond在2006年提出了FAST算法，并在2010年对其进行了修正。该算法的原理是取图像中检测点，以该点为圆心的周围邻域内像素点判断检测点是否为角点，通俗的讲就是<strong>若一个像素周围有一定数量的像素与该点像素值不同，则认为其为角点</strong>。</p>\r\n<ol type=\"1\">\r\n<li><p>在图像中选取一个像素点<span class=\"math inline\">\\(p\\)</span>，来判断它是不是关键点。<span class=\"math display\">\\[I_p\\]</span>等于像素点<span class=\"math inline\">\\(p\\)</span>的灰度值。</p></li>\r\n<li><p>以<span class=\"math inline\">\\(r\\)</span>为半径画圆，覆盖<span class=\"math inline\">\\(p\\)</span>点周围的<span class=\"math inline\">\\(M\\)</span>个像素，通常情况设置<span class=\"math inline\">\\(r=3\\)</span>，则<span class=\"math inline\">\\(M=16\\)</span>。 <img src=\"/imgs/$%7Bfiilename%7D/image17-1684555943527-30.jpg\"  style=\"zoom: 67%;\" /></p></li>\r\n<li><p>设置阈值<span class=\"math inline\">\\(t\\)</span>，如果在这<span class=\"math inline\">\\(16\\)</span>个像素点中存在<span class=\"math inline\">\\(n\\)</span>个连续像素点的灰度值都高于<span class=\"math inline\">\\(I_p+t\\)</span>，或者低于<span class=\"math inline\">\\(I_p-t\\)</span>，那么像素点<span class=\"math inline\">\\(p\\)</span>就被认为是一个角点。如上图中的虚线所示，一般取值为<span class=\"math inline\">\\(n=12\\)</span>。</p></li>\r\n<li><p>采用一种<strong>非特征点判别</strong>的方法：首先对候选点的周围每个<span class=\"math inline\">\\(90^\\circ\\)</span>的点（<span class=\"math inline\">\\(1,9,5,13\\)</span>）进行测试(先测试<span class=\"math inline\">\\(1\\)</span>和<span class=\"math inline\">\\(9\\)</span>，如果它们符合阈值要求再测试<span class=\"math inline\">\\(5\\)</span>和<span class=\"math inline\">\\(13\\)</span>)。如果<span class=\"math inline\">\\(p\\)</span>是角点，那么这四个点中至少有 3 个要符合阈值要求，否则直接剔除。对保留下来的点再继续进行测试。</p></li>\r\n</ol>\r\n<h3 id=\"机器学习的角点检测器\">机器学习的角点检测器</h3>\r\n<ol type=\"1\">\r\n<li><p>选择一组训练图片</p></li>\r\n<li><p>使用<code>FAST算法</code>找出每幅图像的特征点，对图像中的每一个特征点，将其周围的<span class=\"math inline\">\\(16\\)</span>个像素存储构成一个向量<span class=\"math inline\">\\(P\\)</span>。 <img src=\"/imgs/$%7Bfiilename%7D/image-20191010114459269-1684556434454-32.png\"  style=\"zoom:67%;\" /></p></li>\r\n<li><p>每一个特征点的 16 像素点都属于下列三类中的一种 $$ S_{px}=</p>\r\n<span class=\"math display\">\\[\\begin{cases}\r\nd\\quad I_{p\\rightarrow x}\\leq I_{p}-t\\quad (darker)\\\\\r\ns\\quad I_{p}-t\\leq I_{p\\rightarrow x}\\leq I_{p}+t\\quad (similar)\\\\\r\nb\\quad I_{p}+t\\leq I_{p\\rightarrow x}\\quad (brighter)\\\\\r\n\r\n\\end{cases}\\]</span>\r\n<p>$$</p></li>\r\n<li><p>根据这些像素点的分类，特征向量<span class=\"math inline\">\\(P\\)</span>也被分为<span class=\"math inline\">\\(3\\)</span>个子集(<span class=\"math inline\">\\(P_d,P_s,P_b\\)</span>)，</p></li>\r\n<li><p>定义一个新的布尔变量<span class=\"math inline\">\\(K_p\\)</span>，如果<span class=\"math inline\">\\(p\\)</span>是角点就设置为<span class=\"math inline\">\\(True\\)</span>，如果不是就设置为<span class=\"math inline\">\\(False\\)</span>。</p></li>\r\n<li><p>利用特征值向量<span class=\"math inline\">\\(p\\)</span>，目标值是<span class=\"math inline\">\\(K_p\\)</span>，训练<span class=\"math inline\">\\(ID3\\)</span>树（决策树分类器）。</p></li>\r\n<li><p>将构建好的决策树运用于其他图像的快速检测。</p></li>\r\n</ol>\r\n<h3 id=\"非极大值抑制\">非极大值抑制</h3>\r\n<p><strong>在筛选出来的候选角点中有很多是紧挨在一起的，需要通过非极大值抑制来消除这种影响。</strong></p>\r\n<p>为所有的候选角点确定一个打分函数<span class=\"math inline\">\\(V\\)</span></p>\r\n<ol type=\"1\">\r\n<li><p>分别计算<span class=\"math inline\">\\(I_p\\)</span>与圆上<span class=\"math inline\">\\(16\\)</span>个点的像素值差值，取绝对值，</p></li>\r\n<li><p>将这16个绝对值相加，就得到了<span class=\"math inline\">\\(V\\)</span>的值 <span class=\"math display\">\\[\r\nV = \\sum_{i}^{16}|I_p-I_i|\r\n\\]</span></p></li>\r\n<li><p>比较毗邻候选角点的<span class=\"math inline\">\\(V\\)</span>值，把<span class=\"math inline\">\\(V\\)</span>值较小的候选角点去除掉。</p></li>\r\n</ol>\r\n<p><strong>实例化Fast</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fast = =cv.FastFeatureDetector_create( threshold, nonmaxSuppression)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>threshold：阈值t，默认值10</li>\r\n<li>nonmaxSuppression：是否进行非极大值抑制，默认值True</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>Fast：创建的FastFeatureDetector对象</li>\r\n</ul>\r\n<p><strong>利用<code>fast.detect()</code>检测关键点，没有对应的关键点描述</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kp = fast.detect(grayImg, <span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>gray: 进行关键点检测的图像，注意是灰度图像</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>kp: 关键点信息，包括位置，尺度，方向信息</li>\r\n</ul>\r\n<p><strong>将关键点检测结果绘制在图像上</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.drawKeypoints(image, keypoints, outputimage, color, flags)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"示例代码-3\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/tv.jpg&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 Fast角点检测</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 创建一个Fast对象，传入阈值，注意：可以处理彩色空间图像</span></span><br><span class=\"line\">fast = cv.FastFeatureDetector_create(threshold=<span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2 检测图像上的关键点</span></span><br><span class=\"line\">kp = fast.detect(img,<span class=\"literal\">None</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2.3 在图像上绘制关键点</span></span><br><span class=\"line\">img2 = cv.drawKeypoints(img, kp, <span class=\"literal\">None</span>, color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.4 输出默认参数</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>( <span class=\"string\">&quot;Threshold: &#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(fast.getThreshold()) )</span><br><span class=\"line\"><span class=\"built_in\">print</span>( <span class=\"string\">&quot;nonmaxSuppression:&#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(fast.getNonmaxSuppression()) )</span><br><span class=\"line\"><span class=\"built_in\">print</span>( <span class=\"string\">&quot;neighborhood: &#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(fast.getType()) )</span><br><span class=\"line\"><span class=\"built_in\">print</span>( <span class=\"string\">&quot;Total Keypoints with nonmaxSuppression: &#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">len</span>(kp)) )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.5 关闭非极大值抑制</span></span><br><span class=\"line\">fast.setNonmaxSuppression(<span class=\"number\">0</span>)</span><br><span class=\"line\">kp = fast.detect(img,<span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>( <span class=\"string\">&quot;Total Keypoints without nonmaxSuppression: &#123;&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">len</span>(kp)) )</span><br><span class=\"line\"><span class=\"comment\"># 2.6 绘制为进行非极大值抑制的结果</span></span><br><span class=\"line\">img3 = cv.drawKeypoints(img, kp, <span class=\"literal\">None</span>, color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 绘制图像</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img2[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;加入非极大值抑制&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(img3[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;未加入非极大值抑制&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191010120822413-1684557401983-34.png\"  style=\"zoom: 50%;\" /></p>\r\n<h2 id=\"orb-算法\"><a href=\"https://medium.com/data-breach/introduction-to-orb-oriented-fast-and-rotated-brief-4220e8ec40cf\">ORB 算法</a></h2>\r\n<p>ORB（Oriented Fast and Rotated Brief）可以用来对图像中的关键点快速创建特征向量，并用这些特征向量来识别图像中的对象。</p>\r\n<p>ORB算法结合了Fast和Brief算法，提出了构造金字塔，为Fast特征点添加了方向，从而使得关键点具有了尺度不变性和旋转不变性。</p>\r\n<ol type=\"1\">\r\n<li>构造尺度金字塔\r\n<ul>\r\n<li>金字塔共有<span class=\"math inline\">\\(n\\)</span>层，与SIFT不同的是，每一层仅有一幅图像。第<span class=\"math inline\">\\(s\\)</span>层的尺度为<span class=\"math inline\">\\(\\sigma_s=\\sigma_0^s\\)</span>， <span class=\"math inline\">\\(\\sigma_0\\)</span>是初始尺度，默认为<span class=\"math inline\">\\(1.2\\)</span>，原图在第<span class=\"math inline\">\\(0\\)</span>层。第<span class=\"math inline\">\\(s\\)</span>层图像的大小<span class=\"math inline\">\\(Size = (H*\\frac{1}{\\sigma_s})\\times(W*\\frac{1}{\\sigma_s})\\)</span></li>\r\n</ul></li>\r\n<li>在不同的尺度上利用<code>Fast算法</code>检测特征点\r\n<ul>\r\n<li>采用Harris角点响应函数，根据角点的响应值排序，选取前<span class=\"math inline\">\\(N\\)</span>个特征点，作为本尺度的特征点。</li>\r\n</ul></li>\r\n<li>计算特征点的主方向\r\n<ul>\r\n<li><p>计算以特征点为圆心，半径为<span class=\"math inline\">\\(r\\)</span>的圆形邻域内的灰度质心位置，将从特征点位置到质心位置的方向做特征点的主方向。 <span class=\"math display\">\\[\r\nm_{pq}=\\sum_{x,y}x^py^qI(x,y)\r\n\\]</span> 质心位置： <span class=\"math inline\">\\(C=(\\frac{m_{10}}{m_{00}},\\frac{m_{01}}{m_{10}})\\)</span></p>\r\n<p>主方向： <span class=\"math inline\">\\(\\theta = arctan(m_{01},m_{10})\\)</span></p></li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"brief算法\">BRIEF算法</h3>\r\n<p>了解决旋转不变性，将特征点的邻域旋转到主方向上利用<code>Brief算法</code>构建特征描述符，至此就得到了ORB的特征描述向量。</p>\r\n<p><code>Brief算法</code>是一种特征描述子提取算法，并非特征点的提取算法，匹配只需要使用简单的汉明距离(Hamming Distance)利用比特之间的异或操作就可以完成。</p>\r\n<ol type=\"1\">\r\n<li>图像滤波\r\n<ul>\r\n<li>原始图像中存在噪声时，会对结果产生影响，所以需要对图像进行滤波，去除部分噪声。</li>\r\n</ul></li>\r\n<li>选取点对\r\n<ul>\r\n<li><p>以特征点为中心，取<span class=\"math inline\">\\(S\\times S\\)</span>的邻域窗口，在窗口内随机选取<span class=\"math inline\">\\(N\\)</span>组点对，一般<span class=\"math inline\">\\(N=128,256,512\\)</span>，默认是<span class=\"math inline\">\\(256\\)</span>，关于选取随机点对，提供了五种形式</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(x,y\\)</span>方向平均分布采样</li>\r\n<li><span class=\"math inline\">\\(x,y\\)</span>均服从<span class=\"math inline\">\\(Gauss(0,\\frac{S^2}{25})\\)</span>各向同性采样</li>\r\n<li><span class=\"math inline\">\\(x\\)</span>服从<span class=\"math inline\">\\(Gauss(0,\\frac{S^2}{25})\\)</span>，<span class=\"math inline\">\\(y\\)</span>服从<span class=\"math inline\">\\(Gauss(0,\\frac{S^2}{100})\\)</span>采样</li>\r\n<li><span class=\"math inline\">\\(x,y\\)</span>从网格中随机获取</li>\r\n<li><span class=\"math inline\">\\(x\\)</span>一直在<span class=\"math inline\">\\((0,0)\\)</span>，<span class=\"math inline\">\\(y\\)</span>从网格中随机选取</li>\r\n</ul>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191010153907973-1684559140937-36.png\"  style=\"zoom:67%;\" /></p></li>\r\n<li><p>图中一条线段的两个端点就是一组点对，其中第二种方法的结果比较好。</p></li>\r\n</ul></li>\r\n<li>构建描述符\r\n<ul>\r\n<li><p>假设<span class=\"math inline\">\\(x,y\\)</span>是某个点对的两个端点，<span class=\"math inline\">\\(p(x),p(y)\\)</span>是两点对应的像素值， <span class=\"math display\">\\[\r\nt(x,y)=\\begin{cases}1 &amp;if&amp;p(x)&gt;p(y)\\\\ 0&amp; else\\end{cases}\r\n\\]</span></p></li>\r\n<li><p>对每一个点对都进行上述的二进制赋值，形成<code>Brief</code>的关键点的描述特征向量，该向量一般为<span class=\"math inline\">\\(128-512\\)</span>位的字符串，其中仅包含<span class=\"math inline\">\\(1\\)</span>和<span class=\"math inline\">\\(0\\)</span></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191010161944491-1684559749207-38.png\" style=\"zoom: 50%;\" /></p></li>\r\n</ul></li>\r\n</ol>\r\n<p><strong>实例化ORB</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">orb = cv.xfeatures2d.orb_create(nfeatures)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>nfeatures: 特征点的最大数量</li>\r\n</ul>\r\n<p><strong>利用<code>orb.detectAndCompute()</code>检测关键点并计算</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kp,des = orb.detectAndCompute(gray,<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>gray: 进行关键点检测的图像，注意是灰度图像</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>kp: 关键点信息，包括位置，尺度，方向信息</li>\r\n<li>des: 关键点描述符，每个关键点BRIEF特征向量，二进制字符串，</li>\r\n</ul>\r\n<p><strong>将关键点检测结果绘制在图像上</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.drawKeypoints(image, keypoints, outputimage, color, flags)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"示例代码-4\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/tv.jpg&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2 ORB角点检测</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 实例化ORB对象</span></span><br><span class=\"line\">orb = cv.ORB_create(nfeatures=<span class=\"number\">500</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2.2 检测关键点,并计算特征描述符</span></span><br><span class=\"line\">kp,des = orb.detectAndCompute(img,<span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(des.shape)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 将关键点绘制在图像上</span></span><br><span class=\"line\">img2 = cv.drawKeypoints(img, kp, <span class=\"literal\">None</span>, color=(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), flags=<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4. 绘制图像</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.imshow(img2[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191010162532196-1684559841023-40.png\"  style=\"zoom: 45%;\" /></p>\r\n",
            "tags": [
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/OpenCV/OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E4%B8%8B/",
            "url": "https://liujk6525.github.io/OpenCV/OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E4%B8%8B/",
            "title": "OpenCV图像处理(下)",
            "date_published": "2023-05-19T00:30:52.000Z",
            "content_html": "<h1 id=\"直方图\">直方图</h1>\r\n<h2 id=\"图像直方图\">图像直方图</h2>\r\n<p>在统计学中，<a href=\"https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE\">直方图</a>是一种对数据分布情况的图形表示，是一种二维统计图表，它的两个 坐标分别是统计样本和该样本对应的某个属性的度量，以长条图(bar)的形式具体表现。因为直方图的长度及宽度很适合用来表现数量上的变化，所以较容易解读差异小的数值。</p>\r\n<span id=\"more\"></span>\r\n<p>图像直方图（Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素个数。这种直方图中，横坐标的左侧为较暗的区域，而右侧为较亮的区域。因此一张较暗图片的直方图中的数据多集中于左侧和中间部分，而整体明亮、只有少量阴影的图像则相反。</p>\r\n<p>假设有一张图像的信息（灰度值<span class=\"math inline\">\\(0-255\\)</span>），按一定规律将这个范围分割成子区域（也就是 bins）。如下按<span class=\"math inline\">\\(bin=16\\)</span>分割 <span class=\"math display\">\\[\r\n[0,255]=\\underbrace{[0,15]}_{b_{1}}\\cup\\underbrace{[16,30]}_{b_{2}}\\cdots\\cup\\underbrace{[240,255]}_{b_{16}}\r\n\\]</span> 再统计<span class=\"math inline\">\\(bin(i)\\)</span> 的像素数目。得到以<span class=\"math inline\">\\(x\\)</span>轴表示<span class=\"math inline\">\\(bin\\)</span>，<span class=\"math inline\">\\(y\\)</span> 轴表示各个<span class=\"math inline\">\\(bin\\)</span>中的像素个数的图像直方图</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928144352467-1684457137421-1.png\"  style=\"zoom:67%;\" /></p>\r\n<p><strong>注意：</strong></p>\r\n<ul>\r\n<li><p>直方图是根据灰度图进行绘制的，而不是彩色图像。</p></li>\r\n<li><p>直方图是图像中像素强度分布的图形表达方式。   </p></li>\r\n<li><p>它统计了每一个强度值所具有的像素个数。</p></li>\r\n<li><p>不同的图像的直方图可能是相同的</p></li>\r\n</ul>\r\n<h2 id=\"直方图的计算和绘制\">直方图的计算和绘制</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv2.calcHist(images,channels,mask,histSize,ranges[,hist[,accumulate]])</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>images：原图像。当传入函数时应该用中括号[]括起来，例如：[img]。</li>\r\n<li>channels：如果输入图像是灰度图，它的值就是[0]；如果是彩色图像的话，传入的参数可以是[0]，[1]，[2]。它们分别对应着B，G，R通道。 　　</li>\r\n<li>mask: 掩模图像。要统计整幅图像的直方图就把它设为 None。但是如果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并使用它。　　</li>\r\n<li>histsize：<span class=\"math inline\">\\(bin\\)</span>的数目。也应该用中括号括起来，例如：[256]。 　　</li>\r\n<li>ranges：像素值范围，通常为[0，256]</li>\r\n</ul>\r\n<h3 id=\"示例代码\">示例代码</h3>\r\n<p>绘制直方图</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 直接以灰度图的方式读入</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/cat.jpeg&#x27;</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 统计灰度图</span></span><br><span class=\"line\">histr = cv.calcHist([img],[<span class=\"number\">0</span>],<span class=\"literal\">None</span>,[<span class=\"number\">256</span>],[<span class=\"number\">0</span>,<span class=\"number\">256</span>])</span><br><span class=\"line\"><span class=\"comment\"># 3 绘制灰度图</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">6</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.plot(histr)</span><br><span class=\"line\">plt.grid()</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928155000064-1684458391504-3.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"掩膜\">掩膜</h2>\r\n<p>掩膜是用选定的图像、图形或物体，对要处理的图像进行遮挡，来控制图像处理的区域。</p>\r\n<p>在数字图像处理中，通常使用二维矩阵数组进行掩膜。掩膜是由0和1组成一个二进制图像，利用该掩膜图像要处理的图像进行掩膜，其中1值的区域被处理，0 值区域被屏蔽，不会处理。</p>\r\n<p>使用<code>cv.calcHist()</code>来查找完整图像的直方图。</p>\r\n<p>如果要查找图像某些区域的直方图， 只需在要查找直方图的区域上创建一个白色的掩膜图像，否则创建黑色， 然后将其作为掩码mask传递即可。</p>\r\n<h3 id=\"示例代码-1\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1. 直接以灰度图的方式读入</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/cat.jpeg&#x27;</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建蒙版</span></span><br><span class=\"line\">mask = np.zeros(img.shape[:<span class=\"number\">2</span>], np.uint8)</span><br><span class=\"line\">mask[<span class=\"number\">400</span>:<span class=\"number\">650</span>, <span class=\"number\">200</span>:<span class=\"number\">500</span>] = <span class=\"number\">255</span></span><br><span class=\"line\"><span class=\"comment\"># 3.掩模</span></span><br><span class=\"line\">masked_img = cv.bitwise_and(img,img,mask = mask)</span><br><span class=\"line\"><span class=\"comment\"># 4. 统计掩膜后图像的灰度图</span></span><br><span class=\"line\">mask_histr = cv.calcHist([img],[<span class=\"number\">0</span>],mask,[<span class=\"number\">256</span>],[<span class=\"number\">1</span>,<span class=\"number\">256</span>])</span><br><span class=\"line\"><span class=\"comment\"># 5. 图像展示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">2</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>))</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">0</span>].imshow(img,cmap=plt.cm.gray)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">1</span>].imshow(mask,cmap=plt.cm.gray)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;蒙版数据&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">0</span>].imshow(masked_img,cmap=plt.cm.gray)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;掩膜后数据&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">1</span>].plot(mask_histr)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">1</span>].grid()</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;灰度直方图&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928160241831-1684458631460-5.png\"  style=\"zoom:67%;\" /></p>\r\n<h1 id=\"直方图均衡化\">直方图均衡化</h1>\r\n<p><a href=\"https://baike.baidu.com/item/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1/4950487\">直方图均衡化</a>是把原始图像的灰度直方图从比较集中的某个灰度区间变成在更广泛灰度范围内的分布。</p>\r\n<p>直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。</p>\r\n<p>通过这种方法，亮度可以更好地在直方图上分布。这样可以用于增强局部的对比度而不影响整体的对比度</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/300px-Histogrammeinebnung.png\"  style=\"zoom: 80%;\" /></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dst = cv.equalizeHist(img)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img: 灰度图像</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>dst : 均衡化后的结果</li>\r\n</ul>\r\n<h3 id=\"示例代码-2\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1. 直接以灰度图的方式读入</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/cat.jpeg&#x27;</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2. 均衡化处理</span></span><br><span class=\"line\">dst = cv.equalizeHist(img)</span><br><span class=\"line\"><span class=\"comment\"># 3. 结果展示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">2</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img,cmap=plt.cm.gray)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(dst,cmap=plt.cm.gray)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;均衡化后结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928163431354-1684460359762-9.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"自适应的直方图均衡化\">自适应的直方图均衡化</h2>\r\n<p>上述的直方图均衡，我们考虑的是图像的全局对比度。在许多情况下，这样做的效果并不好，但，会丢失了很多信息。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191024105039014-1684460404147-11.png\"  style=\"zoom:67%;\" /></p>\r\n<p>为了解决这个问题， 需要使用自适应的直方图均衡化。</p>\r\n<ol type=\"1\">\r\n<li>整幅图像会被分成很多小块，这些小块被称为<code>tiles</code></li>\r\n<li>然后再分别对每个小块进行直方图均衡化。 所以在每个区域中， 直方图会集中在某一个小的区域中。如果有噪声的话，噪声会被放大。为了避免这种情况的出现要使用对比度限制。对于每个小块来说，如果直方图中的 <span class=\"math inline\">\\(bin\\)</span>超过对比度的上限的话，就把其中的像素点均匀分散到其他<span class=\"math inline\">\\(bins\\)</span>中，然后在进行直方图均衡化。</li>\r\n</ol>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/300px-Clahe-redist.svg.png\"  style=\"zoom:90%;\" /></p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>最后，为了去除每一个小块之间的边界，再使用双线性差值，对每一小块进行拼接。</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.createCLAHE(clipLimit, tileGridSize)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>clipLimit：对比度限制，默认是40</li>\r\n<li>tileGridSize：分块的大小，默认为<span class=\"math inline\">\\(8\\times8\\)</span></li>\r\n</ul>\r\n<h3 id=\"示例代码-3\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"comment\"># 1. 以灰度图形式读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/cat.jpeg&#x27;</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2. 创建一个自适应均衡化的对象，并应用于图像</span></span><br><span class=\"line\">clahe = cv.createCLAHE(clipLimit=<span class=\"number\">2.0</span>, tileGridSize=(<span class=\"number\">8</span>,<span class=\"number\">8</span>))</span><br><span class=\"line\">cl1 = clahe.apply(img)</span><br><span class=\"line\"><span class=\"comment\"># 3. 图像展示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img,cmap=plt.cm.gray)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(cl1,cmap=plt.cm.gray)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;自适应均衡化后的结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928165605432-1684460980293-17.png\"  style=\"zoom:67%;\" /></p>\r\n<p>与均衡化相比，可以看到在猫腿处不再显得暗黑。</p>\r\n<h1 id=\"边缘检测\">边缘检测</h1>\r\n<p><a href=\"https://baike.baidu.com/item/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/3221648\">边缘检测</a>是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。</p>\r\n<p>边缘检测的方法绝大部分可以划分为两类</p>\r\n<ul>\r\n<li><p><strong>基于搜索：</strong>通过寻找<strong>图像一阶导数中的最大值</strong>来检测边界，然后利用计算结果估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到局部梯度模的最大值，代表算法是<code>Sobel算子</code>和<code>Scharr算子</code>。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929104240226-1684461871286-19.png\"  style=\"zoom:67%;\" /></p></li>\r\n<li><p><strong>基于零穿越：</strong>通过寻找<strong>图像二阶导数零穿越</strong>来寻找边界，代表算法是<code>Laplacian算子</code></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929104430480-1684462287627-21.png\"  style=\"zoom:67%;\" /></p></li>\r\n</ul>\r\n<h2 id=\"sobel算子-基于搜索\"><a href=\"https://baike.baidu.com/item/%E7%B4%A2%E8%B4%9D%E5%B0%94%E7%AE%97%E5%AD%90/15805328\"><code>Sobel算子</code></a>-基于搜索</h2>\r\n<p>对于不连续的函数，一阶导数可以写作<span class=\"math inline\">\\(f&#39;(x)=f(x)-f(x-1)\\)</span>或者<span class=\"math inline\">\\(f&#39;(x)=f(x+1)-f(x)\\)</span>，所以有 <span class=\"math display\">\\[\r\nf&#39;(x)=\\frac{f(x+1)-f(x-1)}{2}\r\n\\]</span> 假设要处理的图像为<span class=\"math inline\">\\(I\\)</span>，在两个方向求导</p>\r\n<ol type=\"1\">\r\n<li><strong>水平变化</strong>：将图像<span class=\"math inline\">\\(I\\)</span>与奇数大小的模版进行卷积，结果为<span class=\"math inline\">\\(G_x\\)</span>。</li>\r\n</ol>\r\n<ul>\r\n<li>比如，当模板大小为<span class=\"math inline\">\\(3\\times3\\)</span>时, <span class=\"math display\">\\[\r\nG_x=\\left[\\begin{matrix}-1&amp;0&amp;+1\\\\-2&amp;0&amp;+2\\\\-1&amp;0&amp;+1\\end{matrix}\\right]*I\r\n\\]</span></li>\r\n</ul>\r\n<ol start=\"2\" type=\"1\">\r\n<li><p><strong>垂直变化</strong>：将图像<span class=\"math inline\">\\(I\\)</span>与奇数大小的模板进行卷积，结果为<span class=\"math inline\">\\(G_y\\)</span>。</p>\r\n<ul>\r\n<li>比如，当模板大小为<span class=\"math inline\">\\(3\\times3\\)</span>时, <span class=\"math display\">\\[\r\nG_y=\\left[\\begin{matrix}-1&amp;-2&amp;-1\\\\0&amp;0&amp;0\\\\+1&amp;+2&amp;+1\\end{matrix}\\right]*I\r\n\\]</span></li>\r\n</ul></li>\r\n</ol>\r\n<p>在图像的每一点，通过公式求出： <span class=\"math display\">\\[\r\nG=\\sqrt{G_x^2+G_y^2}\r\n\\]</span> 统计极大值所在的位置，就是图像的边缘。</p>\r\n<p><strong>注意：</strong></p>\r\n<ul>\r\n<li>当核大小为<span class=\"math inline\">\\(3\\times3\\)</span>时, 以上<code>Sobel</code>卷积核可能产生比较明显的误差，</li>\r\n<li>为解决这一问题，我们使用<code>Scharr</code>函数，但该函数仅作用于大小为<span class=\"math inline\">\\(3\\times3\\)</span>的卷积核。该函数的运算与<code>Sobel</code>函数一样快，但结果却更加精确，其计算方法为:</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nG_x=\\left[\\begin{matrix}-3&amp;0&amp;+3\\\\-10&amp;0&amp;+10\\\\-3&amp;0&amp;+3\\end{matrix}\\right]*I\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nG_y=\\left[\\begin{matrix}-3&amp;-10&amp;-3\\\\0&amp;0&amp;0\\\\+3&amp;+10&amp;+3\\end{matrix}\\right]*I\r\n\\]</span></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sobel_x_or_y = cv2.Sobel(src, ddepth, dx, dy, dst, ksize, scale, delta, borderType)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>src：传入的图像</p></li>\r\n<li><p>ddepth：图像的深度</p></li>\r\n<li><p>dx和dy：指求导的阶数，0表示这个方向上没有求导，取值为0、1。</p></li>\r\n<li><p>ksize：是<code>Sobel算子</code>的大小，即卷积核的大小，默认为3。</p>\r\n<p><strong>注意：</strong>如果ksize=-1，就演变成为<span class=\"math inline\">\\(3\\times3\\)</span>的<code>Scharr算子</code>。</p></li>\r\n<li><p>scale：缩放导数的比例常数，默认情况为没有伸缩系数。</p></li>\r\n<li><p>borderType：图像边界的模式，默认值为cv2.BORDER_DEFAULT。</p></li>\r\n</ul>\r\n<p><code>Sobel函数</code>求导后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以建立的图像位数不够，会有截断。</p>\r\n<p>因此要使用16位有符号的数据类型，即<code>cv2.CV_16S</code>。处理完图像后，再使用<code>cv2.convertScaleAbs()</code>函数将其转回原来的uint8格式，否则图像无法显示。</p>\r\n<p>最后还需要用<code>cv2.addWeighted()</code>函数将两个方向的<code>Sobel算子</code>计算结果组合起来</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scale_abs = cv2.convertScaleAbs(x)  # 格式转换函数</span><br><span class=\"line\">result = cv2.addWeighted(src1, alpha, src2, beta) # 图像混合</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"示例代码-4\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/horse.jpg&#x27;</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 计算Sobel卷积结果</span></span><br><span class=\"line\">x = cv.Sobel(img, cv.CV_16S, <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">y = cv.Sobel(img, cv.CV_16S, <span class=\"number\">0</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 3 将数据进行转换</span></span><br><span class=\"line\">Scale_absX = cv.convertScaleAbs(x)  <span class=\"comment\"># convert 转换  scale 缩放</span></span><br><span class=\"line\">Scale_absY = cv.convertScaleAbs(y)</span><br><span class=\"line\"><span class=\"comment\"># 4 结果合成</span></span><br><span class=\"line\">result = cv.addWeighted(Scale_absX, <span class=\"number\">0.5</span>, Scale_absY, <span class=\"number\">0.5</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 5 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">121</span>),plt.imshow(img,cmap=plt.cm.gray),plt.title(<span class=\"string\">&#x27;原图&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.subplot(<span class=\"number\">122</span>),plt.imshow(result,cmap = plt.cm.gray),plt.title(<span class=\"string\">&#x27;Sobel滤波后结果&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929141752847-1684464763720-23.png\" style=\"zoom:67%;\" /></p>\r\n<p>将上述代码中计算<code>sobel算子</code>的部分中将ksize设为-1，就是利用<code>Scharrs算子</code>进行边缘检测。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = cv.Sobel(img, cv.CV_16S, <span class=\"number\">1</span>, <span class=\"number\">0</span>, ksize = -<span class=\"number\">1</span>)</span><br><span class=\"line\">y = cv.Sobel(img, cv.CV_16S, <span class=\"number\">0</span>, <span class=\"number\">1</span>, ksize = -<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929141636521-1684464782140-25.png\"  style=\"zoom:67%;\" /></p>\r\n<h1 id=\"laplacian算子-基于零穿越\"><a href=\"https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90/7261323\"><code>Laplacian算子</code></a>-基于零穿越</h1>\r\n<p><code>Laplacian</code>是利用二阶导数来检测边缘 。 因为图像是2维, 我们需要在两个方向求导，如下式所示： <span class=\"math display\">\\[\r\n\\Delta src=\\frac{\\partial^2src}{\\partial x^2}+\\frac{\\partial^2src}{\\partial y^2}\r\n\\]</span></p>\r\n<p>不连续函数的二阶导数是： <span class=\"math display\">\\[\r\nf&#39;&#39;(x)=f&#39;(x+1)-f&#39;(x)=f(x+1)+f(x-1)-2f(x)\r\n\\]</span> 使用的卷积核是： <span class=\"math display\">\\[\r\nkernel=\\left[\\begin{matrix}0&amp;1&amp;0\\\\1&amp;-4&amp;1\\\\0&amp;1&amp;0\\\\\\end{matrix}\\right]\r\n\\]</span></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">laplacian = cv2.Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>src：需要处理的图像，</li>\r\n<li>ddepth：图像的深度，-1表示采用的是原图像相同的深度，目标图像的深度必须大于等于原图像的深度；</li>\r\n<li>ksize：算子的大小，即卷积核的大小</li>\r\n</ul>\r\n<h3 id=\"示例代码-5\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/horse.jpg&#x27;</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 laplacian转换</span></span><br><span class=\"line\">result = cv.Laplacian(img,cv.CV_16S)</span><br><span class=\"line\">Scale_abs = cv.convertScaleAbs(result)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像展示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">121</span>),plt.imshow(img,cmap=plt.cm.gray),plt.title(<span class=\"string\">&#x27;原图&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.subplot(<span class=\"number\">122</span>),plt.imshow(Scale_abs,cmap = plt.cm.gray),plt.title(<span class=\"string\">&#x27;Laplacian检测后结果&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929145507862.png\"  style=\"zoom:67%;\" /></p>\r\n<h1 id=\"canny算子\"><a href=\"https://baike.baidu.com/item/Canny%E7%AE%97%E5%AD%90/8821789\"><code>Canny算子</code></a></h1>\r\n<p>Canny 边缘检测算法是 John F. Canny 于 1986年提出的，被认为是最优的边缘检测算法。</p>\r\n<ol type=\"1\">\r\n<li><p>去除噪声</p>\r\n<ul>\r\n<li>由于边缘检测很容易受到噪声的影响，所以首先使用<span class=\"math inline\">\\(5\\times5\\)</span>高斯平滑滤波器去除噪声，</li>\r\n</ul></li>\r\n<li><p>计算图像梯度</p>\r\n<ul>\r\n<li><p>对平滑后的图像使用<code>Sobel算子</code>计算水平方向和竖直方向的一阶导数<span class=\"math inline\">\\(G_x,G_y\\)</span>。</p></li>\r\n<li><p>根据这两幅梯度图找到边界的梯度和方向，公式如下: <span class=\"math display\">\\[\r\nEdge_Gradient(G)=\\sqrt{G_x^2+G_y^2}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\nAngle(\\theta)=\\tan^{-1}(\\frac{G_y}{G_x})\r\n\\]</span></p></li>\r\n<li><p>如果某个像素点是边缘，则其梯度方向总是垂直于边缘。梯度方向被归为四类：垂直，水平，和两个对角线方向。</p></li>\r\n</ul></li>\r\n<li><p>非极大值抑制</p>\r\n<ul>\r\n<li>在获得梯度的方向和大小之后，对整幅图像进行扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。</li>\r\n<li>A点位于图像的边缘，在其梯度变化方向，选择像素点B和C，用来检验A点的梯度是否为极大值，若为极大值，则进行保留，否则A点被抑制，最终的结果是具有细边的二进制图像。如下图所示：</li>\r\n</ul>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929153926063.png\"  style=\"zoom:67%;\" /></p></li>\r\n<li><p>滞后阈值</p>\r\n<ul>\r\n<li><p>现在要确定真正的边界。 我们设置两个阈值： <code>minVal</code>和<code>maxVal</code>。 当图像的灰度梯度高于<code>maxVal</code>时被认为是真的边界， 低于<code>minVal</code>的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929155208751.png\"  style=\"zoom:67%;\" /></p></li>\r\n<li><p>如上图所示，A高于阈值<code>maxVal</code>所以是真正的边界点，C虽然低于<code>maxVal</code>但高于<code>minVal</code>并且与A相连，所以也被认为是真正的边界点。而B就会被抛弃，因为低于<code>maxVal</code>而且不与真正的边界点相连。</p></li>\r\n</ul></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">canny = cv2.Canny(image, threshold1, threshold2)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>image：灰度图，</li>\r\n<li>threshold1: minval，较小的阈值将间断的边缘连接起来</li>\r\n<li>threshold2: maxval，较大的阈值检测图像中明显的边缘</li>\r\n</ul>\r\n<h3 id=\"示例代码-6\">示例代码：</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/horse.jpg&#x27;</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 Canny边缘检测</span></span><br><span class=\"line\">lowThreshold = <span class=\"number\">0</span></span><br><span class=\"line\">max_lowThreshold = <span class=\"number\">100</span></span><br><span class=\"line\">canny = cv.Canny(img, lowThreshold, max_lowThreshold) </span><br><span class=\"line\"><span class=\"comment\"># 3 图像展示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">121</span>),plt.imshow(img,cmap=plt.cm.gray),plt.title(<span class=\"string\">&#x27;原图&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.subplot(<span class=\"number\">122</span>),plt.imshow(canny,cmap = plt.cm.gray),plt.title(<span class=\"string\">&#x27;Canny检测后结果&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190929160959357.png\" style=\"zoom:67%;\" /></p>\r\n<h1 id=\"模版匹配和霍夫变换\">模版匹配和霍夫变换</h1>\r\n<h2 id=\"模板匹配\">模板匹配</h2>\r\n<p>所谓的模板匹配，就是在给定的图片中查找和模板最相似的区域，该算法的输入包括模板和图片，然后按照滑窗的思路不断的移动模板图片，计算其与图像中对应区域的匹配度，最终将匹配度最高的区域选择为最终的结果。</p>\r\n<ol type=\"1\">\r\n<li>准备两幅图像\r\n<ul>\r\n<li>原图像<span class=\"math inline\">\\(I\\)</span>：在这幅图中，找到与模板相匹配的区域</li>\r\n<li>模板<span class=\"math inline\">\\(T\\)</span>：与原图像<span class=\"math inline\">\\(I\\)</span>进行比对的图像块</li>\r\n</ul></li>\r\n<li>滑动模板图像和原图像进行比对\r\n<ul>\r\n<li>将模板块每次移动一个像素 (从左往右，从上往下)，在每一个位置，都计算与模板图像的相似程度。</li>\r\n</ul></li>\r\n<li>对于每一个位置将计算的相似结果保存在结果矩阵<span class=\"math inline\">\\(R\\)</span>中。\r\n<ul>\r\n<li>如果输入图像的大小为<span class=\"math inline\">\\((W\\times H)\\)</span>且模板图像的大小为<span class=\"math inline\">\\((w\\times h)\\)</span>，则输出矩阵<span class=\"math inline\">\\(R\\)</span>的大小为<span class=\"math inline\">\\((W-w+1,H-h+1)\\)</span>，将<span class=\"math inline\">\\(R\\)</span>显示为图像。</li>\r\n</ul></li>\r\n<li>获得上述图像后，查找最大值所在的位置，那么该位置对应的区域就被认为是最匹配的。对应的区域就是以该点为顶点，长宽和模板图像一样大小的矩阵。</li>\r\n</ol>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res = cv.matchTemplate(img,template,method)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img：要进行模板匹配的图像</li>\r\n<li>Template：模板</li>\r\n<li>method：实现模板匹配的算法，主要有：\r\n<ol type=\"1\">\r\n<li>平方差匹配(CV_TM_SQDIFF)：利用模板与图像之间的平方差进行匹配，最好的匹配是0，匹配越差，匹配的值越大。</li>\r\n<li>相关匹配(CV_TM_CCORR)：利用模板与图像间的乘法进行匹配，数值越大表示匹配程度较高，越小表示匹配效果差。</li>\r\n<li>利用相关系数匹配(CV_TM_CCOEFF)：利用模板与图像间的相关系数匹配，1表示完美的匹配，-1表示最差的匹配。</li>\r\n</ol></li>\r\n</ul>\r\n<p>完成匹配后，使用<code>cv.minMaxLoc()</code>方法查找最大值所在的位置即可。如果使用平方差作为比较方法，则最小值位置是最佳匹配位置。</p>\r\n<h3 id=\"示例代码-7\">示例代码：</h3>\r\n<p>载入要搜索的图像和模板，图像如下所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/wulin2-1684485180064-5.jpeg\"  style=\"zoom:67%;\" /></p>\r\n<p>模板如下所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/wulin-0430810-1684485193472-7.jpeg\"  style=\"zoom:67%;\" /></p>\r\n<p>通过<code>matchTemplate</code>实现模板匹配，使用<code>minMaxLoc</code>定位最匹配的区域，并用矩形标注最匹配的区域。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像和模板读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/wulin2.jpeg&#x27;</span>)</span><br><span class=\"line\">template = cv.imread(<span class=\"string\">&#x27;./image/wulin.jpeg&#x27;</span>)</span><br><span class=\"line\">h,w,l = template.shape</span><br><span class=\"line\"><span class=\"comment\"># 2 模板匹配</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 模板匹配</span></span><br><span class=\"line\">res = cv.matchTemplate(img, template, cv.TM_CCORR)</span><br><span class=\"line\"><span class=\"comment\"># 2.2 返回图像中最匹配的位置，确定左上角的坐标，并将匹配位置绘制在图像上</span></span><br><span class=\"line\">min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)</span><br><span class=\"line\"><span class=\"comment\"># 使用平方差时最小值为最佳匹配位置</span></span><br><span class=\"line\"><span class=\"comment\"># top_left = min_loc</span></span><br><span class=\"line\">top_left = max_loc</span><br><span class=\"line\">bottom_right = (top_left[<span class=\"number\">0</span>] + w, top_left[<span class=\"number\">1</span>] + h)</span><br><span class=\"line\">cv.rectangle(img, top_left, bottom_right, (<span class=\"number\">0</span>,<span class=\"number\">255</span>,<span class=\"number\">0</span>), <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;匹配结果&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007144614688-1684485615344-9.png\"  style=\"zoom:67%;\" /></p>\r\n<p><strong>拓展：</strong>模板匹配不适用于尺度变换，视角变换后的图像，这时我们就要使用关键点匹配算法，比较经典的关键点检测算法包括SIFT和SURF等，主要的思路是首先通过关键点检测算法获取模板和测试图片中的关键点；然后使用关键点匹配算法处理即可，这些关键点可以很好的处理尺度变化、视角变换、旋转变化、光照变化等，具有很好的不变性。</p>\r\n<h2 id=\"霍夫变换\">霍夫变换</h2>\r\n<p>霍夫变换常用来提取图像中的直线和圆等几何形状。在笛卡尔坐标系中，一条直线由两个点<span class=\"math inline\">\\(A=(x_1,y_1)\\)</span>和<span class=\"math inline\">\\(B(x2，y_2)\\)</span>确定，如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007153126537.png\"  style=\"zoom:67%;\" /></p>\r\n<p>将直线<span class=\"math inline\">\\(y=kx+q\\)</span>可写成关于<span class=\"math inline\">\\((k,q)\\)</span>的函数表达式： <span class=\"math display\">\\[\r\n\\begin{cases}\r\nq=-kx_1+y_1\\\\\r\nq=-kx_2+y_2\r\n\\end{cases}\r\n\\]</span> 对应的变换通过图形直观的表示如下：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007154123721.png\"  style=\"zoom:67%;\" /></p>\r\n<p>变换后的空间我们叫做霍夫空间。即：<strong>笛卡尔坐标系中的一条直线，对应于霍夫空间中的一个点</strong>。反过来，同样成立，霍夫空间中的一条线，对应于笛卡尔坐标系中一个点，如下所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007154350195.png\"  style=\"zoom:67%;\" /></p>\r\n<p>我们再来看下<span class=\"math inline\">\\(A\\)</span>、<span class=\"math inline\">\\(B\\)</span>两个点，对应于霍夫空间的情形：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007154546905.png\"  style=\"zoom:67%;\" /></p>\r\n<p>在看下三点共线的情况：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007160434136.png\"  style=\"zoom:67%;\" /></p>\r\n<p>可以看出如果<strong>在笛卡尔坐标系的点共线，那么这些点在霍夫空间中对应的直线交于一点</strong>。</p>\r\n<p>如果不止存在一条直线时，如下所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007160932077.png\"  style=\"zoom:67%;\" /></p>\r\n<p>我们选择尽可能多的直线汇成的点，上图中三条直线汇成的<span class=\"math inline\">\\(A\\)</span>、<span class=\"math inline\">\\(B\\)</span>两点，将其对应回笛卡尔坐标系中的直线：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007161219204.png\"  style=\"zoom:67%;\" /></p>\r\n<p>到这里我们似乎已经完成了霍夫变换的求解。但如果像下图这种情况时：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007161417485.png\"  style=\"zoom:67%;\" /></p>\r\n<p>上图中的直线是<span class=\"math inline\">\\(x=2\\)</span>，那<span class=\"math inline\">\\((k,q)\\)</span>怎么确定呢？为了解决这个问题，考虑将笛卡尔坐标系转换为极坐标。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007165431682.png\"  style=\"zoom:67%;\" /></p>\r\n<p>在极坐标下是一样的，极坐标中的点对应于霍夫空间的线，这时的霍夫空间不在是参数<span class=\"math inline\">\\((k,q)\\)</span>的空间，而是<span class=\"math inline\">\\((\\rho,\\theta)\\)</span>的空间，<span class=\"math inline\">\\(\\rho\\)</span>是原点到直线的垂直距离，<span class=\"math inline\">\\(\\theta\\)</span>表示直线的垂线与横轴顺时针方向的夹角，垂直线的角度为<span class=\"math inline\">\\(0^\\circ\\)</span>，水平线的角度是<span class=\"math inline\">\\(180^\\circ\\)</span>。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007163203594.png\"  style=\"zoom:67%;\" /></p>\r\n<p>只要求得霍夫空间中的交点的位置，即可得到原坐标系下的直线。</p>\r\n<ol type=\"1\">\r\n<li>假设有一个大小为<span class=\"math inline\">\\(100\\times100\\)</span>的图片，首先创建一个<span class=\"math inline\">\\(2D\\)</span>数组(累加器)，初始化所有值为0，行表示<span class=\"math inline\">\\(\\rho\\)</span>，列表示$$。若角度的精度为<span class=\"math inline\">\\(1^\\circ\\)</span>，那就需要180列。对于<span class=\"math inline\">\\(\\rho\\)</span>，最大值为图片对角线的距离，如果精度要达到像素级别，行数应该与图像的对角线的距离相等。</li>\r\n<li>取直线上的第一个点<span class=\"math inline\">\\((x,y)\\)</span>，将其带入直线在极坐标中的公式中，然后遍历<span class=\"math inline\">\\(\\theta\\)</span>的取值<span class=\"math inline\">\\((0,1,2,\\cdots,180)\\)</span>，分别求出对应的<span class=\"math inline\">\\(\\rho\\)</span>值，如果这个数值在<strong>累加器</strong>中存在相应的位置，则在该位置上加1。</li>\r\n<li>取直线上的第二个点，重复上述步骤，更新累加器中的值。对图像中的直线上的每个点都直线以上步骤，每次更新累加器中的值。</li>\r\n<li>搜索累加器中的最大值，并找到其对应的<span class=\"math inline\">\\((\\rho,\\theta)\\)</span>，就可将图像中的直线表示出来。</li>\r\n</ol>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image70-0440438.gif\"  style=\"zoom: 80%;\" /></p>\r\n<h2 id=\"霍夫线检测\">霍夫线检测</h2>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.HoughLines(img, rho, theta, threshold)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>img：检测的图像<strong>要求是二值化的图像</strong>，所以在调用霍夫变换之前首先要进行二值化，或者进行Canny边缘检测。</p></li>\r\n<li><p>rho、theta：<span class=\"math inline\">\\(\\rho\\)</span> 和<span class=\"math inline\">\\(\\theta\\)</span>的精确度。</p></li>\r\n<li><p>threshold：阈值，只有累加器中的值高于该阈值时才被认为是直线。</p></li>\r\n</ul>\r\n<h3 id=\"示例代码-8\">示例代码</h3>\r\n<p>检测下述图像中的直线：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/rili.jpg\" style=\"zoom:67%;\" /></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1.加载图片，转为二值图</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/rili.jpg&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class=\"line\">edges = cv.Canny(gray, <span class=\"number\">50</span>, <span class=\"number\">150</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.霍夫直线变换</span></span><br><span class=\"line\">lines = cv.HoughLines(edges, <span class=\"number\">0.8</span>, np.pi / <span class=\"number\">180</span>, <span class=\"number\">150</span>)</span><br><span class=\"line\"><span class=\"comment\"># 3.将检测的线绘制在图像上（注意是极坐标噢）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> lines:</span><br><span class=\"line\">    rho, theta = line[<span class=\"number\">0</span>]</span><br><span class=\"line\">    a = np.cos(theta)</span><br><span class=\"line\">    b = np.sin(theta)</span><br><span class=\"line\">    x0 = a * rho</span><br><span class=\"line\">    y0 = b * rho</span><br><span class=\"line\">    x1 = <span class=\"built_in\">int</span>(x0 + <span class=\"number\">1000</span> * (-b))</span><br><span class=\"line\">    y1 = <span class=\"built_in\">int</span>(y0 + <span class=\"number\">1000</span> * (a))</span><br><span class=\"line\">    x2 = <span class=\"built_in\">int</span>(x0 - <span class=\"number\">1000</span> * (-b))</span><br><span class=\"line\">    y2 = <span class=\"built_in\">int</span>(y0 - <span class=\"number\">1000</span> * (a))</span><br><span class=\"line\">    cv.line(img, (x1, y1), (x2, y2), (<span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>))</span><br><span class=\"line\"><span class=\"comment\"># 4. 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;霍夫变换线检测&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191007184301611.png\"  style=\"zoom: 20%;\" /></p>\r\n<h2 id=\"霍夫圆检测\">霍夫圆检测</h2>\r\n<p>圆的表示式是：<span class=\"math inline\">\\((x-a)^2+(y-b)^2=r\\)</span>，其中圆心坐标为<span class=\"math inline\">\\((a,b)\\)</span>，半径为<span class=\"math inline\">\\(r\\)</span>，因此标准的霍夫圆检测就是在这三个参数组成的三维空间累加器上进行圆形检测，此时的效率很低。</p>\r\n<p>所以<code>OpenCV</code>中使用<strong>霍夫梯度法</strong>进行圆形的检测，霍夫梯度法是霍夫变换的改进，它的目的是减小霍夫空间的维度，提高效率。</p>\r\n<p>霍夫梯度法将霍夫圆检测范围两个阶段，第一阶段检测圆心，第二阶段利用圆心推导出圆半径。</p>\r\n<ol type=\"1\">\r\n<li>圆心检测的原理：圆心是圆周法线的交汇处，设置一个阈值，在某点的相交的直线的条数大于这个阈值就认为该交汇点为圆心。</li>\r\n<li>圆半径确定原理：圆心到圆周上的距离（半径）是相同的，确定一个阈值，只要相同距离的数量大于该阈值，就认为该距离是该圆心的半径。</li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">circles = cv.HoughCircles(image, method, dp, minDist, param1=<span class=\"number\">100</span>, param2=<span class=\"number\">100</span>, minRadius=<span class=\"number\">0</span>,maxRadius=<span class=\"number\">0</span> )</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>image：输入图像，应输入灰度图像</li>\r\n<li>method：使用霍夫变换圆检测的算法，它的参数是CV_HOUGH_GRADIENT</li>\r\n<li>dp：霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2时霍夫空间是输入图像空间的一半，以此类推。</li>\r\n<li>minDist：为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认为它们是同一个圆心。</li>\r\n<li>param1：边缘检测时使用Canny算子的高阈值，低阈值是高阈值的一半。</li>\r\n<li>param2：检测圆心和确定半径时所共有的阈值。</li>\r\n<li>minRadius：所检测到的圆半径的最小值。</li>\r\n<li>maxRadius：所检测到的圆半径的最大值。</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>circles：输出圆向量，包括三个浮点型的元素（圆心横坐标，圆心纵坐标和圆半径）</li>\r\n</ul>\r\n<h3 id=\"示例代码-9\">示例代码</h3>\r\n<p>由于霍夫圆检测对噪声比较敏感，所以首先对图像进行中值滤波。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像，并转换为灰度图</span></span><br><span class=\"line\">planets = cv.imread(<span class=\"string\">&quot;./image/star.jpeg&quot;</span>)</span><br><span class=\"line\">gay_img = cv.cvtColor(planets, cv.COLOR_BGRA2GRAY)</span><br><span class=\"line\"><span class=\"comment\"># 2 进行中值模糊，去噪点</span></span><br><span class=\"line\">img = cv.medianBlur(gay_img, <span class=\"number\">7</span>)  </span><br><span class=\"line\"><span class=\"comment\"># 3 霍夫圆检测</span></span><br><span class=\"line\">circles = cv.HoughCircles(img, cv.HOUGH_GRADIENT, <span class=\"number\">1</span>, <span class=\"number\">200</span>, param1=<span class=\"number\">100</span>, param2=<span class=\"number\">30</span>, minRadius=<span class=\"number\">0</span>, maxRadius=<span class=\"number\">100</span>)</span><br><span class=\"line\"><span class=\"comment\"># 4 将检测结果绘制在图像上</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> circles[<span class=\"number\">0</span>, :]:  <span class=\"comment\"># 遍历矩阵每一行的数据</span></span><br><span class=\"line\">    <span class=\"comment\"># 绘制圆形</span></span><br><span class=\"line\">    cv.circle(planets, (i[<span class=\"number\">0</span>], i[<span class=\"number\">1</span>]), i[<span class=\"number\">2</span>], (<span class=\"number\">0</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>), <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 绘制圆心</span></span><br><span class=\"line\">    cv.circle(planets, (i[<span class=\"number\">0</span>], i[<span class=\"number\">1</span>]), <span class=\"number\">2</span>, (<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">255</span>), <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\"># 5 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.imshow(planets[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;霍夫变换圆检测&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191008105125382.png\" style=\"zoom: 33%;\" /></p>\r\n",
            "tags": [
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/OpenCV/OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E4%B8%8A/",
            "url": "https://liujk6525.github.io/OpenCV/OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E4%B8%8A/",
            "title": "OpenCV图像处理(上)",
            "date_published": "2023-05-17T13:19:42.000Z",
            "content_html": "<h1 id=\"几何变换\">几何变换</h1>\r\n<h2 id=\"图像缩放\">图像缩放</h2>\r\n<p>缩放是对图像的大小进行调整，即使图像放大或缩小。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv2.resize(src,dsize,fx=<span class=\"number\">0</span>,fy=<span class=\"number\">0</span>,interpolation=cv2.INTER_LINEAR)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>src : 输入图像</li>\r\n<li>dsize: 绝对尺寸，直接指定调整后图像的大小</li>\r\n<li>fx,fy: 相对尺寸，将dsize设置为None，然后将fx和fy设置为比例因子即可</li>\r\n<li>interpolation：插值方法，</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191016161502727-1684329818370-10.png\" style=\"zoom:67%;\" /></p>\r\n<h3 id=\"示例代码\">示例代码</h3>\r\n<p>将图像分别以绝对尺度的方式放大，以相对尺寸的方式缩小。</p>\r\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"comment\"># 1. 读取图片</span></span><br><span class=\"line\">img1 = cv.imread(<span class=\"string\">&quot;./image/dog.jpeg&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2.图像缩放</span></span><br><span class=\"line\"><span class=\"comment\"># 2.1 绝对尺寸</span></span><br><span class=\"line\">rows,cols = img1.shape[:<span class=\"number\">2</span>]</span><br><span class=\"line\">res = cv.resize(img1,(<span class=\"number\">2</span>*cols,<span class=\"number\">2</span>*rows),interpolation=cv.INTER_CUBIC)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2.2 相对尺寸</span></span><br><span class=\"line\">res1 = cv.resize(img1,<span class=\"literal\">None</span>,fx=<span class=\"number\">0.5</span>,fy=<span class=\"number\">0.5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\"><span class=\"comment\"># 3.1 使用opencv显示图像(不推荐)</span></span><br><span class=\"line\">cv.imshow(<span class=\"string\">&quot;orignal&quot;</span>,img1)</span><br><span class=\"line\">cv.imshow(<span class=\"string\">&quot;enlarge&quot;</span>,res)</span><br><span class=\"line\">cv.imshow(<span class=\"string\">&quot;shrink）&quot;</span>,res1)</span><br><span class=\"line\">cv.waitKey(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.2 使用matplotlib显示图像</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">3</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(res[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;绝对尺度（放大）&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(img1[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">2</span>].imshow(res1[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">2</span>].set_title(<span class=\"string\">&quot;相对尺度（缩小）&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure></p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926143500645-1684329980666-12.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"图像平移\">图像平移</h2>\r\n<p>图像平移将图像按照指定方向和距离，移动到相应的位置。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.warpAffine(img,M,dsize)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>img: 输入图像</p></li>\r\n<li><p>M： 2∗3的移动矩阵</p>\r\n<p>对于(x,y)处的像素点，要把它移动到<span class=\"math inline\">\\((x+t_x,y+t_y)\\)</span>处时，M矩阵应如下设置：</p>\r\n<p><span class=\"math inline\">\\(M=\\left[\\begin{matrix}1&amp;0&amp;t_x\\\\0&amp;1&amp;t_y\\\\&amp;&amp;\\end{matrix}\\right]\\)</span></p>\r\n<p><strong>注意：</strong>将<span class=\"math inline\">\\(M\\)</span>设置为<code>np.float32</code>类型的<code>Numpy</code>数组。</p></li>\r\n<li><p>dsize: 输出图像的大小</p>\r\n<p><strong>注意：</strong>输出图像的大小，它应该是(宽度，高度)的形式。请记住,width=列数，height=行数。</p></li>\r\n</ul>\r\n<h3 id=\"示例代码-1\">示例代码</h3>\r\n<p>将图像的像素点移动(50,100)的距离。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1. 读取图像</span></span><br><span class=\"line\">img1 = cv.imread(<span class=\"string\">&quot;./image/image2.jpg&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2. 图像平移</span></span><br><span class=\"line\">rows,cols = img1.shape[:<span class=\"number\">2</span>]</span><br><span class=\"line\">M = M = np.float32([[<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">100</span>],[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">50</span>]])<span class=\"comment\"># 平移矩阵</span></span><br><span class=\"line\">dst = cv.warpAffine(img1,M,(cols,rows))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3. 图像显示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img1[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(dst[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;平移后结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926151127550-1684330295827-14.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"图像旋转\">图像旋转</h2>\r\n<p>图像旋转是指图像按照某个位置转动一定角度的过程，旋转中图像仍保持这原始尺寸。</p>\r\n<p>假设图像逆时针旋转<span class=\"math inline\">\\(\\theta\\)</span>，则根据坐标转换可得:</p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{matrix}x&#39;&amp;y&#39;&amp;1\\end{matrix}\\right]=\\left[\\begin{matrix}x&amp;y&amp;1\\end{matrix}\\right]\\left[\\begin{matrix}\\cos\\theta&amp;-\\sin\\theta&amp;0\\\\\\sin\\theta&amp;\\cos\\theta&amp;0\\\\0&amp;0&amp;1\\end{matrix}\\right]\r\n\\]</span> 假设在旋转的时候是以旋转中心为坐标原点的，旋转结束后还需要将坐标原点移到图像左上角，也就是还要进行一次变换。 <span class=\"math display\">\\[\r\n\\left[\\begin{matrix}x&#39;&#39;&amp;y&#39;&#39;&amp;1\\end{matrix}\\right]=\\left[\\begin{matrix}x&#39;&amp;y&#39;&amp;1\\end{matrix}\\right]\\left[\\begin{matrix}1&amp;0&amp;0\\\\0&amp;-1&amp;0\\\\left&amp;top&amp;1\\end{matrix}\\right]\\\\\r\n=\\left[\\begin{matrix}x&#39;&amp;y&#39;&amp;1\\end{matrix}\\right]\\left[\\begin{matrix}\\cos\\theta&amp;-\\sin\\theta&amp;0\\\\\\sin\\theta&amp;\\cos\\theta&amp;0\\\\0&amp;0&amp;1\\end{matrix}\\right]\\left[\\begin{matrix}1&amp;0&amp;0\\\\0&amp;-1&amp;0\\\\left&amp;top&amp;1\\end{matrix}\\right]\r\n\\]</span> 在<code>OpenCV</code>中图像旋转首先根据旋转角度和旋转中心获取旋转矩阵，然后根据旋转矩阵进行变换，即可实现任意角度和任意中心的旋转效果。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv2.getRotationMatrix2D(center, angle, scale)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>center：旋转中心</li>\r\n<li>angle：旋转角度</li>\r\n<li>scale：缩放比例</li>\r\n</ul>\r\n<p>返回：</p>\r\n<ul>\r\n<li>M：旋转矩阵</li>\r\n</ul>\r\n<p>调用<code>cv.warpAffine</code>完成图像的旋转</p>\r\n<h3 id=\"示例代码-2\">示例代码</h3>\r\n<p>将图像以中心点旋转<span class=\"math inline\">\\(90^\\circ\\)</span></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&quot;./image/image2.jpg&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2 图像旋转</span></span><br><span class=\"line\">rows,cols = img.shape[:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># 2.1 生成旋转矩阵</span></span><br><span class=\"line\">M = cv.getRotationMatrix2D((cols/<span class=\"number\">2</span>,rows/<span class=\"number\">2</span>),<span class=\"number\">90</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2.2 进行旋转变换</span></span><br><span class=\"line\">dst = cv.warpAffine(img,M,(cols,rows))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 图像展示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img1[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(dst[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;旋转后结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926152854704.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"仿射变换\">仿射变换</h2>\r\n<p><a href=\"https://baike.baidu.com/item/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/4289056\"><code>仿射变换</code></a>是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。</p>\r\n<p>图像的仿射变换，如下图所示，原始图像的点A，B和C与仿射图像三个点一一映射, 仍然形成三角形, 但形状已经大大改变，通过这样两组三点（感兴趣点）求出仿射变换， 接下来我们就能把仿射变换应用到图像中所有的点中，就完成了图像的仿射变换。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/images.jpeg\"  style=\"zoom: 80%;\" /></p>\r\n<p>在<code>OpenCV</code>中，仿射变换的矩阵是一个2×3的矩阵 <span class=\"math display\">\\[\r\nM=\r\n\\left[\\begin{matrix}A&amp;B\\end{matrix}\\right]=\r\n\\left[\\begin{matrix}a_{00}\\quad a_{01}\\quad b_0\\\\\\underbrace{a_{10}\\quad a_{11}}_A\\quad b_1\\end{matrix}\\right]\r\n\\]</span> 其中子矩阵<span class=\"math inline\">\\(A\\)</span>是线性变换矩阵，子矩阵<span class=\"math inline\">\\(B\\)</span>是平移项，对于图像上的任一位置<span class=\"math inline\">\\((x,y)\\)</span>，仿射变换执行的是如下的操作： <span class=\"math display\">\\[\r\nT_{affine}=A\r\n\\left[\\begin{matrix}x\\\\y\\end{matrix}\\right]+B=M\r\n\\left[\\begin{matrix}x\\\\y\\\\1\\end{matrix}\\right]\r\n\\]</span> <strong>注意：</strong>对于图像而言，宽度方向是x，高度方向是y，坐标的顺序和图像像素对应下标一致。所以原点的位置不是左下角而是左上角，y的方向也不是向上，而是向下。</p>\r\n<p>在仿射变换中，原图中所有的平行线在结果图像中同样平行。为了创建这个矩阵我们需要从原图像中找到三个点以及他们在输出图像中的位置。然后<code>cv2.getAffineTransform</code> 会创建一个$ 2$ 的矩阵，最后这个矩阵会被传给函数<code>cv2.warpAffine</code>。</p>\r\n<h3 id=\"示例代码-3\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&quot;./image/image2.jpg&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2 仿射变换</span></span><br><span class=\"line\">rows,cols = img.shape[:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># 2.1 创建变换矩阵</span></span><br><span class=\"line\">pts1 = np.float32([[<span class=\"number\">50</span>,<span class=\"number\">50</span>],[<span class=\"number\">200</span>,<span class=\"number\">50</span>],[<span class=\"number\">50</span>,<span class=\"number\">200</span>]])</span><br><span class=\"line\">pts2 = np.float32([[<span class=\"number\">100</span>,<span class=\"number\">100</span>],[<span class=\"number\">200</span>,<span class=\"number\">50</span>],[<span class=\"number\">100</span>,<span class=\"number\">250</span>]])</span><br><span class=\"line\">M = cv.getAffineTransform(pts1,pts2)</span><br><span class=\"line\"><span class=\"comment\"># 2.2 完成仿射变换</span></span><br><span class=\"line\">dst = cv.warpAffine(img,M,(cols,rows))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(dst[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;仿射后结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926161027173.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"透射变换\">透射变换</h2>\r\n<p><a href=\"https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/8746342\"><code>透射变换</code></a>是视角变化的结果，是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191023130051717.png\" style=\"zoom:67%;\" /></p>\r\n<p>它的本质是将图像投影到一个新的视平面，其通用变换公式为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{matrix}x&#39;&amp;y&#39;&amp;z&#39;\\end{matrix}\\right]=\\left[\\begin{matrix}u&amp;v&amp;w\\end{matrix}\\right]\\left[\\begin{matrix}a_{00}\\quad a_{01}\\quad a_{02}\\\\a_{10}\\quad a_{11}\\quad a_{12}\\\\\\underbrace{a_{20}\\quad a_{21}\\quad a_{22}}_T\\end{matrix}\\right]\r\n\\]</span> 其中<span class=\"math inline\">\\((u,v)\\)</span>是原始图像的像素坐标，<span class=\"math inline\">\\(w\\)</span>取值为1，<span class=\"math inline\">\\((x=x&#39;/z&#39;,y=y&#39;/z&#39;)\\)</span>是透射变换后的结果。<span class=\"math inline\">\\(T\\)</span>矩阵称为透视变换矩阵， <span class=\"math display\">\\[\r\nT=\r\n\\left[\\begin{matrix}a_{00}&amp;a_{01}&amp;a_{02}\\\\a_{10}&amp;a_{11}&amp;a_{12}\\\\a_{20}&amp; a_{21}&amp; a_{22}\\end{matrix}\\right]=\r\n\\left[\\begin{matrix}T_{1}&amp;T_{2}\\\\T_{3}&amp;a_{22}\\end{matrix}\\right]\r\n\\]</span> 其中：<span class=\"math inline\">\\(T1\\)</span>是图像进行线性变换，<span class=\"math inline\">\\(T2\\)</span>对图像进行平移，<span class=\"math inline\">\\(T3\\)</span>表示对图像进行投射变换，一般<span class=\"math inline\">\\(a_{22}\\)</span>取为1。</p>\r\n<p>在<code>opencv</code>中，先找到四个点(其中任意三个点不共线)，然后获取透射变换矩阵<span class=\"math inline\">\\(T\\)</span>，再进行透射变换。通过函数<code>cv.getPerspectiveTransform</code>找到透射变换矩阵，将<code>cv.warpPerspective</code>应用于此<code>3x3</code>变换矩阵。</p>\r\n<h3 id=\"示例代码-4\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&quot;./image/image2.jpg&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 透射变换</span></span><br><span class=\"line\">rows,cols = img.shape[:<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"comment\"># 2.1 创建变换矩阵</span></span><br><span class=\"line\">pts1 = np.float32([[<span class=\"number\">56</span>,<span class=\"number\">65</span>],[<span class=\"number\">368</span>,<span class=\"number\">52</span>],[<span class=\"number\">28</span>,<span class=\"number\">387</span>],[<span class=\"number\">389</span>,<span class=\"number\">390</span>]])</span><br><span class=\"line\">pts2 = np.float32([[<span class=\"number\">100</span>,<span class=\"number\">145</span>],[<span class=\"number\">300</span>,<span class=\"number\">100</span>],[<span class=\"number\">80</span>,<span class=\"number\">290</span>],[<span class=\"number\">310</span>,<span class=\"number\">300</span>]])</span><br><span class=\"line\"></span><br><span class=\"line\">T = cv.getPerspectiveTransform(pts1,pts2)</span><br><span class=\"line\"><span class=\"comment\"># 2.2 进行变换</span></span><br><span class=\"line\">dst = cv.warpPerspective(img,T,(cols,rows))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(dst[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;透射后结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926162913916.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"图像金字塔\">图像金字塔</h2>\r\n<p><a href=\"https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/306277\">图像金字塔</a>是图像多尺度表达的一种，是一种以多分辨率来解释图像的有效但概念简单的结构。一幅图像的图像金字塔是一系列以金字塔形状（自下而上）逐步降低，且来源于同一张原始图的图像分辨率集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。我们将一层一层的图像比喻成金字塔，层级越高，则图像越小，分辨率越低。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.pyrUp(img)       <span class=\"comment\">#对图像进行上采样</span></span><br><span class=\"line\">cv.pyrDown(img)        <span class=\"comment\">#对图像进行下采样</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"示例代码-5\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&quot;./image/image2.jpg&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 进行图像采样</span></span><br><span class=\"line\">up_img = cv.pyrUp(img)  <span class=\"comment\"># 上采样操作</span></span><br><span class=\"line\">img_1 = cv.pyrDown(img)  <span class=\"comment\"># 下采样操作</span></span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">cv.imshow(<span class=\"string\">&#x27;enlarge&#x27;</span>, up_img)</span><br><span class=\"line\">cv.imshow(<span class=\"string\">&#x27;original&#x27;</span>, img)</span><br><span class=\"line\">cv.imshow(<span class=\"string\">&#x27;shrink&#x27;</span>, img_1)</span><br><span class=\"line\">cv.waitKey(<span class=\"number\">0</span>)</span><br><span class=\"line\">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926114816933.png\"  style=\"zoom: 50%;\" /></p>\r\n<h1 id=\"形态学操作\">形态学操作</h1>\r\n<p>形态学转换是基于图像形状的一些简单操作。它通常在二进制图像上执行。腐蚀和膨胀是两个基本的形态学运算符。然后它的变体形式如开运算，闭运算，礼帽黑帽等。</p>\r\n<h2 id=\"连通性\">连通性</h2>\r\n<p>在图像中，最小的单位是像素，每个像素周围有8个邻接像素，常见的邻接关系有3种：4邻接、8邻接和D邻接。分别如下图所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926185646667-1684373842950-11.png\"  style=\"zoom: 50%;\" /></p>\r\n<ul>\r\n<li>4邻接：像素<span class=\"math inline\">\\(p(x,y)\\)</span>的4邻域是<code>(x+1,y);(x-1,y);(x,y+1);(x,y-1)</code>，用<span class=\"math inline\">\\(N_4(p)\\)</span>表示像素p的4邻接</li>\r\n<li>D邻接：像素<span class=\"math inline\">\\(p(x,y)\\)</span>的D邻域是<code>(x+1,y+1);(x+1,y-1);(x-1,y+1);(x-1,y-1)</code>，用<span class=\"math inline\">\\(N_D(p)\\)</span>表示像素p的D邻域</li>\r\n<li>8邻接：像素<span class=\"math inline\">\\(p(x,y)\\)</span>的8邻域是4邻域的点+D邻域的点，用<span class=\"math inline\">\\(N_8(p)\\)</span>表示像素p的8邻域</li>\r\n</ul>\r\n<p><strong>连通性</strong>是描述区域和边界的重要概念，两个像素连通的两个必要条件是：</p>\r\n<ol type=\"1\">\r\n<li>两个像素的位置是否相邻</li>\r\n<li>两个像素的灰度值是否满足特定的相似性准则(或者是否相等)</li>\r\n</ol>\r\n<p>根据连通性的定义，有4连通、8连通和m连通三种。</p>\r\n<ul>\r\n<li><p>4连通：对于具有值V的像素p和q，如果q在集合<span class=\"math inline\">\\(N_4(p)\\)</span>中，则称这两个像素是4连通。</p></li>\r\n<li><p>8连通：对于具有值V的像素p和q，如果q在集合<span class=\"math inline\">\\(N_8(p)\\)</span>中，则称这两个像素是8连通。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190926185504256-1684374493446-13.png\"  style=\"zoom:50%;\" /></p></li>\r\n<li><p>m连通：对于具有值V的像素p和q，如果q在集合<span class=\"math inline\">\\(N_4(p)\\)</span>中或q在集合<span class=\"math inline\">\\(N_D(p)\\)</span>中，并且<span class=\"math inline\">\\(N_4(p)\\)</span>与<span class=\"math inline\">\\(N_4(q)\\)</span>的交集为空(没有值V的像素)，则称这两个像素是m连通。</p></li>\r\n</ul>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927101630929-1684374613256-15.png\"  style=\"zoom: 90%;\" /></p>\r\n<h2 id=\"腐蚀和膨胀\">腐蚀和膨胀</h2>\r\n<p>腐蚀和膨胀都是针对白色部分（高亮部分）而言的。</p>\r\n<ol type=\"1\">\r\n<li>腐蚀是原图中的高亮区域被蚕食，效果图拥有比原图更小的高亮区域；腐蚀是求局部最小值的操作，作用是消除物体边界点，使目标缩小，可以消除小于结构元素的噪声点。</li>\r\n<li>膨胀是使图像中高亮部分扩张，效果图拥有比原图更大的高亮区域；膨胀是求局部最大值的操作，作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。</li>\r\n</ol>\r\n<p><strong>腐蚀的具体操作是：</strong>用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为1，则该像素为1，否则为0。如下图所示，结构A被结构B腐蚀后</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927105316401-1684375461882-17.png\"  style=\"zoom: 67%;\" /></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.erode(img,kernel,iterations)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img：要处理的图像</li>\r\n<li>kernel：核结构</li>\r\n<li>iterations：腐蚀的次数，默认是1</li>\r\n</ul>\r\n<p><strong>膨胀的具体操作是：</strong>用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为0，则该像素为0，否则为1。如下图所示，结构A被结构B腐蚀后</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927110711458-1684375683181-19.png\"  style=\"zoom:67%;\" /></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.dilate(img,kernel,iterations)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>img：要处理的图像</p></li>\r\n<li><p>kernel：核结构</p></li>\r\n<li><p>iterations：腐蚀的次数，默认是1</p></li>\r\n</ul>\r\n<h3 id=\"示例代码-6\">示例代码</h3>\r\n<p>使用一个<span class=\"math inline\">\\(5\\times5\\)</span>的卷积核实现腐蚀和膨胀的运算</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&quot;./image/image3.png&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 创建核结构</span></span><br><span class=\"line\">kernel = np.ones((<span class=\"number\">5</span>, <span class=\"number\">5</span>), np.uint8)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 图像腐蚀和膨胀</span></span><br><span class=\"line\">erosion = cv.erode(img, kernel) <span class=\"comment\"># 腐蚀</span></span><br><span class=\"line\">dilate = cv.dilate(img,kernel) <span class=\"comment\"># 膨胀</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 4 图像展示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">3</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(erosion)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;腐蚀后结果&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">2</span>].imshow(dilate)</span><br><span class=\"line\">axes[<span class=\"number\">2</span>].set_title(<span class=\"string\">&quot;膨胀后结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927151844574-1684375808449-21.png\" style=\"zoom:67%;\" /></p>\r\n<h2 id=\"开闭运算\">开、闭运算</h2>\r\n<p>开运算和闭运算是将腐蚀和膨胀按照一定的次序进行处理。 但这两者并不是可逆的，即先开后闭并不能得到原来的图像。</p>\r\n<ol type=\"1\">\r\n<li><p>开运算是先腐蚀后膨胀，作用是消除噪点，去除小的干扰块，而不影响原来的图像。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927142206425-1684376263939-23.png\" style=\"zoom: 67%;\" /></p></li>\r\n<li><p>闭运算是先膨胀后腐蚀，作用是消除闭合物体里面的孔洞，填充闭合区域。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927142923777-1684376306646-25.png\"  style=\"zoom:67%;\" /></p></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.morphologyEx(img, op, kernel)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img：要处理的图像</li>\r\n<li>op: 处理方式：若进行开运算，则设为cv.MORPH_OPEN，若进行闭运算，则设为cv.MORPH_CLOSE</li>\r\n<li>Kernel：核结构</li>\r\n</ul>\r\n<h3 id=\"示例代码-7\">示例代码</h3>\r\n<p>使用<span class=\"math inline\">\\(10\\times10\\)</span>的卷积核实现开、闭运算。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img1 = cv.imread(<span class=\"string\">&quot;./image/image5.png&quot;</span>)</span><br><span class=\"line\">img2 = cv.imread(<span class=\"string\">&quot;./image/image6.png&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 创建核结构</span></span><br><span class=\"line\">kernel = np.ones((<span class=\"number\">10</span>, <span class=\"number\">10</span>), np.uint8)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像的开闭运算</span></span><br><span class=\"line\">cvOpen = cv.morphologyEx(img1,cv.MORPH_OPEN,kernel) <span class=\"comment\"># 开运算</span></span><br><span class=\"line\">cvClose = cv.morphologyEx(img2,cv.MORPH_CLOSE,kernel)<span class=\"comment\"># 闭运算</span></span><br><span class=\"line\"><span class=\"comment\"># 4 图像展示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">2</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>))</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">0</span>].imshow(img1)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">1</span>].imshow(cvOpen)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;开运算结果&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">0</span>].imshow(img2)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">1</span>].imshow(cvClose)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;闭运算结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927153400823-1684376402734-27.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"礼帽和黑帽\">礼帽和黑帽</h2>\r\n<ol type=\"1\">\r\n<li>礼帽运算是原图像与开运算的结果图之差<span class=\"math inline\">\\(dst=tophat(src,element)=src-open(src,element)\\)</span>，\r\n<ul>\r\n<li>因为开运算带来的结果是放大了裂缝或者局部低亮度的区域。</li>\r\n<li>礼帽运算后的效果图突出了比原图轮廓周围的区域更明亮的区域，这一操作和选择的核的大小相关。</li>\r\n<li>作用：用来分离比邻近点亮一些的斑块。当一幅图像具有大幅的背景的时候，而微小物品比较有规律的情况下，可以使用礼帽运算进行背景提取。</li>\r\n</ul></li>\r\n<li>黑帽运算是闭运算的结果图与原图像之差<span class=\"math inline\">\\(dst=blackhat(src,element)=close(src,element)-src\\)</span>，\r\n<ul>\r\n<li>黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，</li>\r\n<li>作用：用来分离比邻近点暗一些的斑块。</li>\r\n</ul></li>\r\n</ol>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.morphologyEx(img, op, kernel)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>img：要处理的图像</p></li>\r\n<li><p>op：处理方式：</p></li>\r\n<li><p>Kernel：核结构</p></li>\r\n</ul>\r\n<h3 id=\"示例代码-8\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img1 = cv.imread(<span class=\"string\">&quot;./image/image5.png&quot;</span>)</span><br><span class=\"line\">img2 = cv.imread(<span class=\"string\">&quot;./image/image6.png&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 创建核结构</span></span><br><span class=\"line\">kernel = np.ones((<span class=\"number\">10</span>, <span class=\"number\">10</span>), np.uint8)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像的礼帽和黑帽运算</span></span><br><span class=\"line\">cvOpen = cv.morphologyEx(img1,cv.MORPH_TOPHAT,kernel) <span class=\"comment\"># 礼帽运算</span></span><br><span class=\"line\">cvClose = cv.morphologyEx(img2,cv.MORPH_BLACKHAT,kernel)<span class=\"comment\"># 黑帽运算</span></span><br><span class=\"line\"><span class=\"comment\"># 4 图像显示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">2</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>))</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">0</span>].imshow(img1)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">1</span>].imshow(cvOpen)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>,<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;礼帽运算结果&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">0</span>].imshow(img2)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;原图&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">1</span>].imshow(cvClose)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>,<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;黑帽运算结果&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190927154018177-1684377075287-29.png\"  style=\"zoom:67%;\" /></p>\r\n<h1 id=\"图像平滑\">图像平滑</h1>\r\n<p><a href=\"https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91/8827890\"><code>图像平滑</code></a>从信号处理的角度看就是去除其中的高频信息，保留低频信息。因此可以对图像实施低通滤波。低通滤波可以去除图像中的噪声，对图像进行平滑。根据滤波器的不同可分为均值滤波，高斯滤波，中值滤波， 双边滤波。</p>\r\n<h2 id=\"图像噪声\">图像噪声</h2>\r\n<p>由于图像采集、处理、传输等过程不可避免的会受到噪声的污染，妨碍人们对图像理解及分析处理。常见的图像噪声有高斯噪声、椒盐噪声等。</p>\r\n<h3 id=\"椒盐噪声\">椒盐噪声</h3>\r\n<p><a href=\"https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958\"><code>椒盐噪声</code></a>也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素。</p>\r\n<p>椒盐噪声的成因可能是影像讯号受到突如其来的强烈干扰而产生、类比数位转换器或位元传输错误等。例如失效的感应器导致像素值为最小值，饱和的感应器导致像素值为最大值。</p>\r\n<h3 id=\"高斯噪声\">高斯噪声</h3>\r\n<p><a href=\"https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0/8587563\">高斯噪声</a>是指噪声密度函数服从高斯分布的一类噪声。在数字图像中的高斯噪声的主要来源出现在采集期间， 由于不良照明和/或高温引起的传感器噪声。</p>\r\n<p>高斯随机变量<span class=\"math inline\">\\(x\\)</span>的概率密度函数 <span class=\"math display\">\\[\r\np(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma^2}}\r\n\\]</span> 其中<span class=\"math inline\">\\(z\\)</span>表示灰度值，<span class=\"math inline\">\\(\\mu\\)</span>表示<span class=\"math inline\">\\(x\\)</span>的平均值或期望值，<span class=\"math inline\">\\(\\sigma\\)</span>表示<span class=\"math inline\">\\(x\\)</span>的标准差。标准差的平方<span class=\"math inline\">\\(\\sigma^2\\)</span>称为<span class=\"math inline\">\\(x\\)</span>的方差。高斯函数的曲线如下图所示。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/441dc1bf121e7b13c6376b5839a3cd7c_b.png\" style=\"zoom:67%;\" /></p>\r\n<h2 id=\"均值滤波\">均值滤波</h2>\r\n<p>采用<strong>均值滤波模板</strong>对图像噪声进行滤除。令<span class=\"math inline\">\\(S_{xy}\\)</span>表示中心在<span class=\"math inline\">\\((x, y)\\)</span>点，尺寸为<span class=\"math inline\">\\(m\\times n\\)</span> 的矩形子图像窗口的坐标组。 均值滤波器可表示为 <span class=\"math display\">\\[\r\n\\hat{f}=\\frac{1}{mn}\\sum_{(s,t)\\in S_{xy}}g(s,t)\r\n\\]</span> 由一个归一化卷积框完成的。它只是用卷积框覆盖区域所有像素的平均值来代替中心元素。</p>\r\n<p>例如，<span class=\"math inline\">\\(3\\times3\\)</span>标准化的均值滤波如下所示： <span class=\"math display\">\\[\r\nK=\\frac{1}{9}\\left[\\begin{matrix}1&amp;1&amp;1\\\\1&amp;1&amp;1\\\\1&amp;1&amp;1\\end{matrix}\\right]\r\n\\]</span> 均值滤波的优点是算法简单，计算速度较快，缺点是在去噪的同时去除了很多细节部分，将图像变得模糊。</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.blur(src, ksize, anchor, borderType)</span><br></pre></td></tr></table></figure>\r\n<p>参数:</p>\r\n<ul>\r\n<li>src：输入图像</li>\r\n<li>ksize：卷积核的大小</li>\r\n<li>anchor：默认值 (-1,-1) ，表示核中心</li>\r\n<li>borderType：边界类型</li>\r\n</ul>\r\n<h3 id=\"示例代码-9\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/dogsp.jpeg&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 均值滤波</span></span><br><span class=\"line\">blur = cv.blur(img,(<span class=\"number\">5</span>,<span class=\"number\">5</span>))</span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">121</span>),plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;原图&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.subplot(<span class=\"number\">122</span>),plt.imshow(blur[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;均值滤波后结果&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928102258185-1684384223434-35.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"高斯滤波\">高斯滤波</h2>\r\n<p>二维高斯是构建高斯滤波器的基础，其概率分布函数为 <span class=\"math display\">\\[\r\nG(x,y) = \r\n\\frac{1}{\\sigma_x\\sqrt{2\\pi}}e^{-\\frac{(x-\\mu)^2}{2\\sigma_y^2}}\\frac{1}{\\sigma_y\\sqrt{2\\pi}}e^{-\\frac{(y-\\mu)^2}{2\\sigma_y^2}}=\r\n\\frac{1}{2\\pi\\sigma^2}e^{-\\frac{(x^2+y^2)}{2\\sigma^2}}\r\n\\]</span> 上述公式做了一些取值的处理：我们令<span class=\"math inline\">\\(\\sigma_x=\\sigma_y\\)</span>，越接近中心，取值越大，越远离中心，取值越小。计算平滑结果时，将“中心点”作为原点（<span class=\"math inline\">\\(\\mu=0\\)</span>），其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928104118332-1684385364117-37.png\"  style=\"zoom:67%;\" /></p>\r\n<p><strong>高斯平滑的流程：</strong></p>\r\n<ul>\r\n<li>确定权重矩阵\r\n<ul>\r\n<li>假定中心点的坐标是（0,0），距离它最近的8个点的坐标（<span class=\"math inline\">\\(3\\times3\\)</span>的卷积核）</li>\r\n</ul></li>\r\n<li>计算权重矩阵，\r\n<ul>\r\n<li>设定<span class=\"math inline\">\\(\\sigma\\)</span>的值，根据高斯概率分布函数<span class=\"math inline\">\\(G(x,y)\\)</span>计算这9个点，</li>\r\n<li>计算这9个点的总和，</li>\r\n<li>将9个值分别除以权重总和，得到最终的权重矩阵。</li>\r\n</ul></li>\r\n<li>计算高斯模糊\r\n<ul>\r\n<li>假设现有9个像素点，灰度值（0-255）</li>\r\n<li>每个点乘以对应的权重值</li>\r\n<li>将这9个值加起来，就是中心点的高斯模糊的值。</li>\r\n</ul></li>\r\n<li>对所有点重复这个过程，就得到了高斯模糊后的图像。</li>\r\n</ul>\r\n<p>如果原图是彩色图片，对<code>RGB</code>三个通道分别做高斯平滑。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv2.GaussianBlur(src,ksize,sigmaX,sigmay,borderType)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>src：输入图像</li>\r\n<li>ksize：高斯卷积核的大小</li>\r\n<li>sigmaX：水平方向的标准差</li>\r\n<li>sigmaY：垂直方向的标准差，默认值为0，表示与sigmaX相同</li>\r\n<li>borderType：填充边界类型</li>\r\n</ul>\r\n<h3 id=\"示例代码-10\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/dogGasuss.jpeg&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 高斯滤波</span></span><br><span class=\"line\">blur = cv.GaussianBlur(img,(<span class=\"number\">3</span>,<span class=\"number\">3</span>),<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">121</span>),plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;原图&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.subplot(<span class=\"number\">122</span>),plt.imshow(blur[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;高斯滤波后结果&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928111903926-1684386634283-39.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"中值滤波\">中值滤波</h2>\r\n<p>中值滤波是一种典型的非线性滤波技术，基本思想是用像素点邻域灰度值的中值来代替该像素点的灰度值。它对椒盐噪声（salt-and-pepper noise）来说尤其有用，因为它不依赖于邻域内那些与典型值差别很大的值。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.medianBlur(src, ksize )</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>src：输入图像</li>\r\n<li>ksize：卷积核的大小</li>\r\n</ul>\r\n<h3 id=\"示例代码-11\">示例代码</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">from</span> matplotlib <span class=\"keyword\">import</span> pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 图像读取</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./image/dogsp.jpeg&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># 2 中值滤波</span></span><br><span class=\"line\">blur = cv.medianBlur(img,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像展示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">plt.subplot(<span class=\"number\">121</span>),plt.imshow(img[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;原图&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.subplot(<span class=\"number\">122</span>),plt.imshow(blur[:,:,::-<span class=\"number\">1</span>]),plt.title(<span class=\"string\">&#x27;中值滤波后结果&#x27;</span>)</span><br><span class=\"line\">plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190928102319410-1684386742771-41.png\" style=\"zoom:67%;\" /></p>\r\n",
            "tags": [
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/OpenCV/OpenCV%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/",
            "url": "https://liujk6525.github.io/OpenCV/OpenCV%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/",
            "title": "OpenCV基本操作",
            "date_published": "2023-05-17T12:09:11.000Z",
            "content_html": "<p><strong>Imgproc（图像处理模块）</strong></p>\r\n<p>图像处理模块包括：图像的读取、显示、保存、几何运算等。</p>\r\n<span id=\"more\"></span>\r\n<h1 id=\"图像的基础操作\">图像的基础操作</h1>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"图像读取显示保存\">图像读取、显示、保存</h2>\r\n<h3 id=\"读取图像\">读取图像</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 以灰度图的形式读取图像，可以使用1、0或者-1来替代下面三个标志</span></span><br><span class=\"line\">img = cv.imread(<span class=\"string\">&#x27;./messi5.jpg&#x27;</span>,<span class=\"number\">0</span>) </span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li><p>要读取的图像，./表示当前文件夹</p></li>\r\n<li><p>读取方式的标志</p>\r\n<ul>\r\n<li><p>cv.IMREAD*COLOR：以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。</p></li>\r\n<li><p>cv.IMREAD*GRAYSCALE：以灰度模式加载图像</p></li>\r\n<li><p>cv.IMREAD_UNCHANGED：包括alpha通道的加载图像模式。</p></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"显示图像\">显示图像</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># opencv中显示</span></span><br><span class=\"line\">cv.imshow(<span class=\"string\">&#x27;./image&#x27;</span>,img)</span><br><span class=\"line\">cv.waitKey(<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># matplotlib中展示</span></span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>]) <span class=\"comment\"># matplotlib中rgb和opencv是正好反着的</span></span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>显示图像的窗口名称，以字符串类型表示</li>\r\n<li>要加载的图像</li>\r\n</ul>\r\n<p><strong>注意：在调用显示图像的API后，要调用cv.waitKey()给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来</strong>。</p>\r\n<h3 id=\"保存图像\">保存图像</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.imwrite(<span class=\"string\">&#x27;./messigray.png&#x27;</span>,img)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>文件名，保存位置，./表示当前文件夹</li>\r\n<li>要保存的图像</li>\r\n</ul>\r\n<h2 id=\"绘制几何图形\">绘制几何图形</h2>\r\n<h3 id=\"绘制直线\">绘制直线</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.line(img,start,end,color,thickness)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img:要绘制直线的图像</li>\r\n<li>start,end: 直线的起点和终点</li>\r\n<li>color: 线条的颜色</li>\r\n<li>thickness: 线条宽度</li>\r\n</ul>\r\n<h3 id=\"绘制圆形\">绘制圆形</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.circle(img,centerpoint, r, color, thickness)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img:要绘制圆形的图像</li>\r\n<li>centerpoint, r: 圆心和半径</li>\r\n<li>color: 线条的颜色</li>\r\n<li>thickness: 线条宽度，为-1时生成闭合图案并填充颜色</li>\r\n</ul>\r\n<h3 id=\"绘制矩形\">绘制矩形</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.rectangle(img,leftupper,rightdown,color,thickness)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img:要绘制矩形的图像</li>\r\n<li>leftupper, rightdown: 矩形的左上角和右下角坐标</li>\r\n<li>color: 线条的颜色</li>\r\n<li>thickness: 线条宽度</li>\r\n</ul>\r\n<h3 id=\"添加文字\">添加文字</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.putText(img,text,station, font, fontsize,color,thickness,cv.LINE_AA)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>img: 图像</li>\r\n<li>text：要写入的文本数据</li>\r\n<li>station：文本的放置位置</li>\r\n<li>font：字体</li>\r\n<li>fontsize :字体大小</li>\r\n</ul>\r\n<h3 id=\"效果展示\">效果展示</h3>\r\n<p>生成一个全黑的图像，然后在里面绘制图像并添加文字</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"comment\"># 1 创建一个空白的图像</span></span><br><span class=\"line\">img = np.zeros((<span class=\"number\">512</span>,<span class=\"number\">512</span>,<span class=\"number\">3</span>), np.uint8)</span><br><span class=\"line\"><span class=\"comment\"># 2 绘制图形</span></span><br><span class=\"line\">cv.line(img,(<span class=\"number\">0</span>,<span class=\"number\">0</span>),(<span class=\"number\">511</span>,<span class=\"number\">511</span>),(<span class=\"number\">255</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>),<span class=\"number\">5</span>)</span><br><span class=\"line\">cv.rectangle(img,(<span class=\"number\">384</span>,<span class=\"number\">0</span>),(<span class=\"number\">510</span>,<span class=\"number\">128</span>),(<span class=\"number\">0</span>,<span class=\"number\">255</span>,<span class=\"number\">0</span>),<span class=\"number\">3</span>)</span><br><span class=\"line\">cv.circle(img,(<span class=\"number\">447</span>,<span class=\"number\">63</span>), <span class=\"number\">63</span>, (<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">255</span>), -<span class=\"number\">1</span>)</span><br><span class=\"line\">font = cv.FONT_HERSHEY_SIMPLEX</span><br><span class=\"line\">cv.putText(img,<span class=\"string\">&#x27;OpenCV&#x27;</span>,(<span class=\"number\">10</span>,<span class=\"number\">500</span>), font, <span class=\"number\">4</span>,(<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>),<span class=\"number\">2</span>,cv.LINE_AA)</span><br><span class=\"line\"><span class=\"comment\"># 3 图像展示</span></span><br><span class=\"line\">plt.imshow(img[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">plt.title(<span class=\"string\">&#x27;匹配结果&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20190925154009533.png\" style=\"zoom: 50%;\" /></p>\r\n<h2 id=\"获取并修改像素点\">获取并修改像素点</h2>\r\n<p>可以通过行和列的坐标值获取该像素点的像素值。对于BGR图像，它返回一个蓝，绿，红值的数组。对于灰度图像，仅返回相应的强度值。使用相同的方法对像素值进行修改。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 获取某个像素点的值</span></span><br><span class=\"line\">px = img[<span class=\"number\">100</span>,<span class=\"number\">100</span>]</span><br><span class=\"line\"><span class=\"comment\"># 仅获取蓝色通道的强度值</span></span><br><span class=\"line\">blue = img[<span class=\"number\">100</span>,<span class=\"number\">100</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"comment\"># 修改某个位置的像素值</span></span><br><span class=\"line\">img[<span class=\"number\">100</span>,<span class=\"number\">100</span>] = [<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>]</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"图像的属性\">图像的属性</h2>\r\n<p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191016151042764-1684327382077-6.png\"  style=\"zoom:50%;\" /></p>\r\n<h2 id=\"图像通道的拆分与合并\">图像通道的拆分与合并</h2>\r\n<p>有时需要在B，G，R通道图像上单独工作,此时需要将<code>BGR</code>图像分割为单个通道。或者可能需要将这些单独的通道合并到BGR图像。可以通过以下方式完成。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 通道拆分</span></span><br><span class=\"line\">b,g,r = cv.split(img)</span><br><span class=\"line\"><span class=\"comment\"># 通道合并</span></span><br><span class=\"line\">img = cv.merge((b,g,r))</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"色彩空间的改变\">色彩空间的改变</h2>\r\n<p><code>OpenCV</code>中有150多种颜色空间转换方法。最广泛使用的转换方法有两种，<span class=\"math inline\">\\(BGR \\leftrightarrow Gray\\)</span>和<span class=\"math inline\">\\(BGR \\leftrightarrow HSV\\)</span>。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cv.cvtColor(input_image，flag)</span><br></pre></td></tr></table></figure>\r\n<p>参数：</p>\r\n<ul>\r\n<li>input_image: 进行颜色空间转换的图像</li>\r\n<li>flag: 转换类型\r\n<ul>\r\n<li>cv.COLOR_BGR2GRAY : <span class=\"math inline\">\\(BGR \\leftrightarrow Gray\\)</span></li>\r\n<li>cv.COLOR_BGR2HSV: <span class=\"math inline\">\\(BGR \\leftrightarrow HSV\\)</span></li>\r\n</ul></li>\r\n</ul>\r\n<h1 id=\"算数操作\">算数操作</h1>\r\n<h2 id=\"图像加法\">图像加法</h2>\r\n<p>使用<code>OpenCV</code>的<code>cv.add()</code>函数把两幅图像相加，或者可以简单地通过numpy操作添加两个图像，如<span class=\"math inline\">\\(res = img_1 + img_2\\)</span>。两个图像应该具有相同的大小和类型，或者第二个图像可以是标量值。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = np.uint8([<span class=\"number\">250</span>])</span><br><span class=\"line\">y = np.uint8([<span class=\"number\">10</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span>( cv.add(x,y) ) <span class=\"comment\"># 250+10 = 260 =&gt; 255</span></span><br><span class=\"line\">[[<span class=\"number\">255</span>]]</span><br><span class=\"line\"><span class=\"built_in\">print</span>( x+y )          <span class=\"comment\"># 250+10 = 260 % 256 = 4</span></span><br><span class=\"line\">[<span class=\"number\">4</span>]</span><br></pre></td></tr></table></figure>\r\n<p>**注意：<code>OpenCV</code>的加法是饱和操作，而<code>Numpy</code>添加是模运算。这种区别在对两幅图像进行加法时会很明显。<code>OpenCV</code> 的结果会更好一点。所以我们尽量使用 <code>OpenCV</code>中的函数。</p>\r\n<p>将两幅图像进行加法操作来比较其中的区别：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img1 = cv.imread(<span class=\"string\">&quot;./view.jpg&quot;</span>)</span><br><span class=\"line\">img2 = cv.imread(<span class=\"string\">&quot;./rain.jpg&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2 加法操作</span></span><br><span class=\"line\">img3 = cv.add(img1,img2) <span class=\"comment\"># cv中的加法</span></span><br><span class=\"line\">img4 = img1+img2 <span class=\"comment\"># 直接相加</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">fig,axes=plt.subplots(nrows=<span class=\"number\">1</span>,ncols=<span class=\"number\">2</span>,figsize=(<span class=\"number\">10</span>,<span class=\"number\">8</span>),dpi=<span class=\"number\">100</span>)</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].imshow(img3[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">0</span>].set_title(<span class=\"string\">&quot;cv中的加法&quot;</span>)</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].imshow(img4[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">axes[<span class=\"number\">1</span>].set_title(<span class=\"string\">&quot;直接相加&quot;</span>)</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p>结果如下所示：</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191016154714377.png\" style=\"zoom:67%;\" /></p>\r\n<h2 id=\"图像融合\">图像融合</h2>\r\n<p>这其实也是加法，但是不同的是两幅图像的权重不同，这就会给人一种混合或者透明的感觉。图像混合的计算公式如下：</p>\r\n<p><span class=\"math display\">\\[\r\ng(x)=(1−\\alpha)f_0(x)+\\alpha f_1(x)+\\gamma\r\n\\]</span> 通过修改<span class=\"math inline\">\\(\\alpha\\)</span>的值<span class=\"math inline\">\\((0\\rightarrow1)\\)</span>，可以实现非常炫酷的混合。</p>\r\n<p>现在我们把两幅图混合在一起。第一幅图的权重是0.7，第二幅图的权重是0.3。函数<code>cv2.addWeighted()</code>可以按下面的公式对图片进行混合操作。</p>\r\n<p><span class=\"math display\">\\[\r\ndst = (1-\\alpha)\\cdot img_1 + \\alpha\\cdot img_2 + \\gamma\r\n\\]</span> 这里<span class=\"math inline\">\\(\\gamma\\)</span>取为0。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2 <span class=\"keyword\">as</span> cv</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 1 读取图像</span></span><br><span class=\"line\">img1 = cv.imread(<span class=\"string\">&quot;view.jpg&quot;</span>)</span><br><span class=\"line\">img2 = cv.imread(<span class=\"string\">&quot;rain.jpg&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 2 图像混合</span></span><br><span class=\"line\">img3 = cv.addWeighted(img1,<span class=\"number\">0.7</span>,img2,<span class=\"number\">0.3</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3 图像显示</span></span><br><span class=\"line\">plt.figure(figsize=(<span class=\"number\">8</span>,<span class=\"number\">8</span>))</span><br><span class=\"line\">plt.imshow(img3[:,:,::-<span class=\"number\">1</span>])</span><br><span class=\"line\">plt.show()</span><br></pre></td></tr></table></figure>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/image-20191016161128720.png\" style=\"zoom:%67%;\" /></p>\r\n<p><strong>注意：</strong>这里都要求两幅图像是相同大小的。</p>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1Fo4y1d7JL?p=11&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>黑马程序员人工智能教程_10小时学会图像处理OpenCV入门教程</code></a></p>\r\n",
            "tags": [
                "Jupyter Notebook"
            ]
        },
        {
            "id": "https://liujk6525.github.io/OpenCV/OpenCV%E7%AE%80%E4%BB%8B/",
            "url": "https://liujk6525.github.io/OpenCV/OpenCV%E7%AE%80%E4%BB%8B/",
            "title": "OpenCV简介",
            "date_published": "2023-05-17T10:59:27.000Z",
            "content_html": "<h1 id=\"图像处理简介\">图像处理简介</h1>\r\n<h2 id=\"图像\">图像</h2>\r\n<p><a href=\"https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F/773234\"><code>图像</code></a>是人类视觉的基础，是自然景物的客观反映，是人类认识世界和人类本身的重要源泉。“图”是物体反射或透射光的分布，“像“是人的视觉系统所接受的图在人脑中所形版的印象或认识，照片、绘画、剪贴画、地图、书法作品、手写汉学、传真、卫星云图、影视画面、X光片、脑电图、心电图等都是图像</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"模拟图像和数字图像\">模拟图像和数字图像</h2>\r\n<p>图像起源于1826年前后法国科学家<code>Joseph Nicéphore Niépce</code>发明的第一张可永久保存的照片，属于模拟图像。模拟图像又称连续图像，它通过某种物理量（如光、电等）的强弱变化来记录图像亮度信息，所以是<strong>连续变换的</strong>。模拟信号的特点是容易受干扰，如今已经基本全面被数字图像替代。</p>\r\n<p>在第一次世界大战后，1921年美国科学家发明了<code>Bartlane System</code>，并从伦敦传到纽约传输了第一幅数字图像，其亮度用<strong>离散数值表示</strong>，将图片编码成5个灰度级，如下图所示，通过海底电缆进行传输。在发送端图片被编码并使用打孔带记录，通过系统传输后在接收方使用特殊的打印机恢复成图像。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/Snipaste_2019-09-24_11-19-33.png\"  style=\"zoom: 67%;\" /></p>\r\n<p>1950年左右，计算机被发明，数字图像处理学科正式诞生。</p>\r\n<p>计算机采用0/1编码的系统，数字图像是利用0/1来记录信息，我们平常接触的图像都是8位数图像，包含0～255灰度，其中0代表最黑，1代表最白。如下展现的是一个灰度图。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/Snipaste_2019-09-24_11-46-55.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"图像的分类\">图像的分类</h2>\r\n<h3 id=\"二值图像\">二值图像：</h3>\r\n<p>一幅二值图像的二维矩阵仅由0、1两个值构成，0代表黑色，1代白色。由于每一像素（矩阵中每一元素）取值仅有0、1两种可能，所以计算机中二值图像的数据类型通常为1个二进制位。二值图像通常用于文字、线条图的扫描识别（OCR）和掩膜图像的存储。</p>\r\n<h3 id=\"灰度图\">灰度图：</h3>\r\n<p>每个像素只有一个采样颜色的图像，这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色；但是，灰度图像在黑色与白色之间还有许多级的颜色深度。灰度图像经常是在单个电磁波频谱如可见光内测量每个像素的亮度得到的，用于显示的灰度图像通常用每个采样像素8位的非线性尺度来保存，这样可以有<span class=\"math inline\">\\(2^8=256\\)</span>级灰度（如果用<span class=\"math inline\">\\(16\\)</span>位，则有<span class=\"math inline\">\\(2^16=65536\\)</span>级）。</p>\r\n<h3 id=\"彩色图\"><strong>彩色图</strong>：</h3>\r\n<p>每个像素通常是由红（R）、绿（G）、蓝（B）三个分量来表示的，分量介于（0~255）。<code>RGB</code>图像与索引图像一样都可以用来表示彩色图像。与索引图像一样，它分别用红（R）、绿（G）、蓝（B）三原色的组合来表示每个像素的颜色。但与索引图像不同的是，<code>RGB</code>图像每一个像素的颜色值（由<code>RGB</code>三原色表示）直接存放在图像矩阵中，由于每一像素的颜色需由R、G、B三个分量来表示，M、N分别表示图像的行列数，三个M x N的二维矩阵分别表示各个像素的R、G、B三个颜色分量。<code>RGB</code>图像的数据类型一般为8位无符号整形，通常用于表示和存放真彩色图像。</p>\r\n<h1 id=\"opencv简介\"><code>OpenCV</code>简介</h1>\r\n<p><code>OpenCV</code>是一款由Intel公司俄罗斯团队发起并参与和维护的一个计算机视觉处理开源软件库，支持与计算机视觉和机器学习相关的众多算法，并且正在日益扩展。</p>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/Snipaste_2019-09-23_16-41-04.png\"  style=\"zoom:67%;\" /></p>\r\n<h2 id=\"opencv-python\"><code>OpenCV-Python</code></h2>\r\n<p><code>OpenCV-Python</code>是原始<code>OpenCV</code> C++实现的Python包装器。同时它使用<code>Numpy</code>，这是一个高度优化的数据库操作库，具有<code>MATLAB</code>风格的语法。所有<code>OpenCV</code>数组结构都转换为<code>Numpy</code>数组。这也使得与使用<code>Numpy</code>的其他库（如<code>SciPy</code>和<code>Matplotlib</code>）集成更容易。</p>\r\n<h2 id=\"opencv部署\"><code>OpenCV</code>部署</h2>\r\n<ol type=\"1\">\r\n<li>安装<code>OpenCV</code>之前需要先安装<a href=\"https://pypi.org/project/numpy/\"><code>numpy</code></a>, <a href=\"https://pypi.org/project/matplotlib/\"><code>matplotlib</code></a>。</li>\r\n<li>创建Python虚拟环境</li>\r\n<li>安装<a href=\"https://pypi.org/project/opencv-python/\"><code>OpenCV-Python</code></a>, 由于一些经典的算法被申请了版权，新版本有很大的限制，所以选用3.4.3以下的版本</li>\r\n</ol>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install opencv-python==3.4.2.17</span><br></pre></td></tr></table></figure>\r\n<p>测试是否安装成功，运行以下代码无报错，则说明安装成功。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"comment\"># 读一个图片并进行显示(图片路径需自己指定)</span></span><br><span class=\"line\">lena=cv2.imread(<span class=\"string\">&quot;1.jpg&quot;</span>)</span><br><span class=\"line\">cv2.imshow(<span class=\"string\">&quot;image&quot;</span>,lena)</span><br><span class=\"line\">cv2.waitKey(<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\r\n<p>需要利用SIFT和SURF等进行特征提取时，还需要安装：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install opencv-contrib-python==<span class=\"number\">3.4</span><span class=\"number\">.2</span><span class=\"number\">.17</span></span><br></pre></td></tr></table></figure>\r\n<h1 id=\"opencv的模块\"><code>OpenCV</code>的模块</h1>\r\n<p><img src=\"/imgs/$%7Bfiilename%7D/Snipaste_2019-09-23_16-42-18.png\"  style=\"zoom: 50%;\" /></p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 26%\" />\r\n<col style=\"width: 60%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">模块</th>\r\n<th style=\"text-align: left;\">功能</th>\r\n<th style=\"text-align: left;\">描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\"><strong>Core</strong></td>\r\n<td style=\"text-align: left;\">核心模块，包含最基础的操作</td>\r\n<td style=\"text-align: left;\">绘图函数、数组操作相关函数</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\"><strong>HighGUI</strong></td>\r\n<td style=\"text-align: left;\">高层图像用户界面</td>\r\n<td style=\"text-align: left;\">视频与图像的读取、显示、存储等接口</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\"><strong>Imgproc</strong></td>\r\n<td style=\"text-align: left;\">图像处理模块</td>\r\n<td style=\"text-align: left;\">图像处理的基础方法：包括图像滤波、图像的几何变换、平滑、阈值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\"><strong>Featured2d</strong></td>\r\n<td style=\"text-align: left;\">2D特征检测模块</td>\r\n<td style=\"text-align: left;\">用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">Objdectect</td>\r\n<td style=\"text-align: left;\">目标检测模块</td>\r\n<td style=\"text-align: left;\">基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification（级联分类）和Latent SVM等</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">Video</td>\r\n<td style=\"text-align: left;\">视频处理模块</td>\r\n<td style=\"text-align: left;\">针对视频处理，如背景分离，前景检测、对象跟踪等</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">Calib3d</td>\r\n<td style=\"text-align: left;\">3D重建模块</td>\r\n<td style=\"text-align: left;\">主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等。</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">ML</td>\r\n<td style=\"text-align: left;\">机器学习模块</td>\r\n<td style=\"text-align: left;\">SVM，决策树，Boosting等</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">FLANN</td>\r\n<td style=\"text-align: left;\">最近邻搜索模块</td>\r\n<td style=\"text-align: left;\">包含快速近似最近邻搜索FLANN 和聚类Clustering算法</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">Stitching</td>\r\n<td style=\"text-align: left;\">图像拼接模块</td>\r\n<td style=\"text-align: left;\">实现了图像拼接功能</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">Photo</td>\r\n<td style=\"text-align: left;\">计算图像学</td>\r\n<td style=\"text-align: left;\">包含图像修复和图像去噪两部分</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">G-API</td>\r\n<td style=\"text-align: left;\">G-API模块</td>\r\n<td style=\"text-align: left;\">包含超高效的图像处理pipeline引擎</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h1 id=\"参考\">参考</h1>\r\n<p><a href=\"https://www.bilibili.com/video/BV1Fo4y1d7JL?p=4&amp;vd_source=fe8e916be2bd597efffd8dfd95249141\"><code>黑马程序员人工智能教程_10小时学会图像处理OpenCV入门教程</code></a></p>\r\n",
            "tags": [
                "Jupyter Notebook"
            ]
        }
    ]
}