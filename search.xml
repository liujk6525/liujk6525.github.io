<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基于混合粒子群算法的TSP算法</title>
    <url>/TSP%E9%97%AE%E9%A2%98/%E5%9F%BA%E4%BA%8E%E6%B7%B7%E5%90%88%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95%E7%9A%84TSP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="理论基础">理论基础</h1>
<h2 id="基本粒子群算法">基本粒子群算法</h2>
<p>粒子群算法，也称粒子群优化算法或鸟群觅食算法（Particle Swarm Optimization，PSO），它通过追随当前搜索到的最优值来寻找全局最优。这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。</p>
<span id="more"></span>
<h3 id="基本原理">基本原理</h3>
<p>PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值(fitness value)，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。</p>
<p>粒子位置的更新方式如下所示</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511062229130.png" alt="粒子位置额更新方式" style="zoom: 67%;" /></p>
<p><span class="math inline">\(PSO\)</span>初始化为一群随机粒子(随机解)。然后通过迭代找到最优解。在每一次迭代中，粒子通过跟踪两个“极值”来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值P<sub>best</sub>。另一个极值是整个种群目前找到的最优解，这个极值是全局极值g<sub>best</sub>。另外也可以不用整个种群而只是用其中一部分作为粒子的邻居，那么在所有邻居中的极值就是局部极值。</p>
<p>假设在一个D维的目标搜索空间中，有N个粒子组成一个种群，其中</p>
<p>第i个粒子为一个D维的向量 <span class="math display">\[
X_i = (x_{i1},x_{i2},x_{i3},...x_{iD}),\quad i=1,2,3,...,N
\]</span> 第i个粒子的“飞行”速度也是一个D维的向量 <span class="math display">\[
V_i = (v_{i1},v_{i2},v_{i3},...v_{iD}),\quad i=1,2,3,...,N
\]</span> 第i个粒子迄今为止搜索到的最优位置称为个体极值 <span class="math display">\[
P_{best}=(p_{i1},p_{i2},p_{i3},...p_{iD}),\quad i=1,2,3,...,N
\]</span> 整个粒子群迄今为止搜索到的最优位置称为全局极值 <span class="math display">\[
g_{best}=(p_{g1},p_{g2},p_{g3},...p_{gD})
\]</span> 在找到这两个最优值时，粒子根据如下公式更新自己的速度和位置 <span class="math display">\[
v_{id}=w*v_{id}+c_1r_1(p_{id}-x_{id})+c_2r_2(p_{gd}-x_{id})\\
x_{id}=x_{id}+v_{id}
\]</span></p>
<p>式中，w为惯性权重(inertia weight)，c<sub>1</sub>,c<sub>2</sub>为学习因子，也称为加速常量(acceleration constants)，r<sub>1</sub>r<sub>2</sub>为[0,1]范围内的均匀随机数</p>
<p>w*v<sub>id</sub> 为“惯性”或者”动量“部分，反映了粒子的运动习惯，代表粒子有维持自己先前速度的趋势。</p>
<p>c<sub>1</sub>r<sub>1</sub>(p<sub>id</sub>-x<sub>id</sub>)为“认知”部分，反映了粒子对自身历史经验的记忆或回忆，代表了粒子有向自身历史最佳位置逼近的趋势。</p>
<p>c<sub>2</sub>r<sub>2</sub>(p<sub>gd</sub>-x<sub>id</sub>)为“社会”部分，反映了粒子间协同合作与知识共享的群体历史经验，代表了粒子有向群体或邻域历史最佳位置逼近的趋势。</p>
<h3 id="pso算法的流程">PSO算法的流程</h3>
<ol type="1">
<li>初始化粒子群，包括群体规模N，每个粒子的位置x<sub>i</sub>和速度v<sub>i</sub>；</li>
<li>计算每个粒子的适应度Fitness(i)；</li>
<li>对每个粒子，将其适应值Fitness(i)与其经过的最优值P<sub>best</sub>(i)作比较，如果较好，则将其替换掉原来的P<sub>best</sub>(i)；</li>
<li>对每个粒子，将其适应值Fitness(i)与其经过的全局最优值g<sub>best</sub>(i)作比较，如果较好，则将其替换掉原来的g<sub>best</sub>(i)；</li>
<li>根据公式更新粒子的速度v<sub>i</sub>和位置x<sub>i</sub>；</li>
<li>如果满足结束条件退出，否则返回第2步。</li>
</ol>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511055154081.png" alt="PSO算法流程图" style="zoom:80%;" /></p>
<h2 id="混合粒子群算法">混合粒子群算法</h2>
<p>标准粒子群算法通过追随个体极值和群体极值完成极值寻优，虽然操作简单，且能够快速收敛，但是随着迭代次数的不断增加，在种群收敛集中的同时，各粒子也越来越相似，可能在局部最优解周边无法跳出。</p>
<p>混合粒子群算法摒弃了传统粒子群算法中的通过跟踪极值来更新粒子位置的方法，而是引入了<code>遗传算法</code>中的交叉和变异操作，通过粒子同个体极值和群体极值的交叉以及粒子自身变异的方式来搜索最优解。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511070402553.png" alt="混合粒子群算法流程图" style="zoom:80%;" /></p>
<h1 id="问题描述">问题描述</h1>
<p>TSP问题，具体描述参考<a href="https://liujk6525.github.io/posts/15650/"><code>基于遗传算法的TSP算法</code></a>，这边不在赘叙。</p>
<h1 id="代码实现">代码实现</h1>
<h2 id="适应值变化">适应值变化</h2>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511154328042.png" alt="适应值变化图" style="zoom:80%;" /></p>
<h2 id="苹果位置图">苹果位置图</h2>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511160009530.png" alt="苹果分布图" style="zoom:80%;" /></p>
<h2 id="路径规划图">路径规划图</h2>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230511154532035.png" alt="路径规划图" style="zoom: 80%;" /></p>
<h2 id="最优解">最优解</h2>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511155618486.png" alt="最优解" style="zoom:80%;" /></p>
<h1 id="参考">参考</h1>
<p>[1]史峰. MATLAB智能算法30个案例分析[M]. 北京航空航天大学出版社, 2011.</p>
]]></content>
      <categories>
        <category>TSP问题</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>路径规划</tag>
      </tags>
  </entry>
  <entry>
    <title>基于遗传算法的TSP算法</title>
    <url>/TSP%E9%97%AE%E9%A2%98/%E5%9F%BA%E4%BA%8E%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E7%9A%84TSP%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="理论基础">理论基础</h2>
<h3 id="遗传算法">遗传算法</h3>
<p>遗传算法（Genetic Algorithm, GA）起源于对生物系统所进行的计算机模拟研究。它是模仿自然界生物进化机制发展起来的随机全局搜索和优化方法，借鉴了达尔文的进化论和孟德尔的遗传学说。其本质是一种高效、并行、全局搜索的方法。 <span id="more"></span></p>
<h3 id="tsp问题">TSP问题</h3>
<p>TSP (traveling salesman problem,旅行商问题) 是典型的NP完全问题，即其最坏情况下的时间复杂度随着问题规模的增大按指数方式增长，到目前为止还未找到一个多项式时间的有效算法。</p>
<p>​ TSP问题可描述为：已知n个城市相互之间的距离，某一旅行商从某个城市出发访问每个城市一次且仅一次，最后回到出发城市，如何安排才使其所走路线最短。简言之，就是寻找一条最短的遍历n个城市的路径，或者说搜索自然子集X={1,2,….n} ( X的元素表示对n个 城市的编号 ) 的一个排列π(X)={V<sub>1</sub>,V<sub>2</sub>,…,V<sub>n</sub>},使 <span class="math display">\[
T_d = \sum_{i=1}^{n-1}{d(V_i,V_(i+1))}+d(V_n,V_1)
\]</span> 取最小值，其中 <span class="math display">\[
d(V_i,V_i+1)
\]</span> 表示城市V<sub>i</sub>到城市V<sub>i+1</sub>的距离。 ## 问题描述</p>
<p>通过搭建的双目视觉检测系统将苹果的三维坐标获取到后，需要对其进行路径规划，即寻找出一条最短的遍历所有目标苹果的路径</p>
<p>表1 14个苹果的位置坐标</p>
<table>
<thead>
<tr class="header">
<th>目标苹果编号</th>
<th>X坐标</th>
<th>Y坐标</th>
<th>Z坐标</th>
<th>目标苹果编号</th>
<th>X坐标</th>
<th>Y坐标</th>
<th>Z坐标</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>16.47</td>
<td>96.10</td>
<td>45.25</td>
<td>8</td>
<td>17.20</td>
<td>96.29</td>
<td>48.62</td>
</tr>
<tr class="even">
<td>2</td>
<td>16.47</td>
<td>94.44</td>
<td>44.25</td>
<td>9</td>
<td>16.30</td>
<td>97.38,</td>
<td>42.98</td>
</tr>
<tr class="odd">
<td>3</td>
<td>20.09</td>
<td>92.54</td>
<td>45.63</td>
<td>10</td>
<td>14.05</td>
<td>98.12,</td>
<td>41.86</td>
</tr>
<tr class="even">
<td>4</td>
<td>22.39</td>
<td>93.37</td>
<td>47.21</td>
<td>11</td>
<td>16.53</td>
<td>97.38</td>
<td>,48.52</td>
</tr>
<tr class="odd">
<td>5</td>
<td>25.23</td>
<td>97.24</td>
<td>44.29</td>
<td>12</td>
<td>21.52</td>
<td>95.59</td>
<td>46.25</td>
</tr>
<tr class="even">
<td>6</td>
<td>22.00</td>
<td>96.05</td>
<td>48.45</td>
<td>13</td>
<td>19.41</td>
<td>97.13</td>
<td>45.71</td>
</tr>
<tr class="odd">
<td>7</td>
<td>20.47</td>
<td>97.02</td>
<td>47.56</td>
<td>14</td>
<td>20.09</td>
<td>92.55</td>
<td>44.44</td>
</tr>
</tbody>
</table>
<h2 id="解决思路及步骤">解决思路及步骤</h2>
<p>遗传算法TSP问题的流程图</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230510164303229.png"  style="zoom:80%;" /></p>
<ol type="1">
<li>编码</li>
</ol>
<p>​ 对于n个苹果的TSP问题，染色体分为n段，例如检测到10个苹果{1,2,3,4,5,6,7,8,9,10}，则|1|0|2|4|5|6|8|7|9|3就是一个合法的染色体。</p>
<ol start="2" type="1">
<li>种群初始化</li>
</ol>
<p>​ 编码后，需要初始化一个种群作为起始解，初始化种群的数目一般根据经验得到，种群的数量按苹果的规模确定，参考的取值为50~200。</p>
<ol start="3" type="1">
<li>适应度函数</li>
</ol>
<p>​ 设k<sub>1</sub>|k<sub>2</sub>|k<sub>i</sub>|…|k<sub>n</sub>|为一个采用整数编码的染色体，d(k<sub>i</sub>,k<sub>j</sub>)为苹果k<sub>i</sub>到苹果k<sub>j</sub>的欧式距离，则该个体的适应度为 <span class="math display">\[
fitness = \frac{1}{\sum_{i=1}^{n-1}{d(K_i,K_(i+1))}+d(K_n,K_1)}
\]</span> 即适应度函数恰好遍历了n个苹果，再回到第一个苹果的距离的倒数。优化的目标就是选择适应度函数值尽可能大的染色体。</p>
<ol start="4" type="1">
<li>选择操作</li>
</ol>
<p>​ 从旧群体中以一定概率选择个体到新群体中，个体被选中的概率跟适应度值有关，个体适应度值越大，被选中的概率越大。</p>
<ol start="5" type="1">
<li>交又操作 部分映射杂交，确定交叉操作的父代，将父代样本两两分组，每组重复以下过程。</li>
</ol>
<p>​ 假定城市数为10)，产生两个[1,10]区间内的随机整数和r<sub>1</sub>和r<sub>2</sub>，确定两个位置，对两位置的中间数据进行交叉，如r<sub>1</sub>=4,r<sub>2</sub>=7 (其实就是把四和七中间的位置给互换，包括四七位置本身)</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">10</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">9</td>
</tr>
</tbody>
</table>
<p>交叉后为</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"><em>1</em></td>
<td style="text-align: center;"><em>6</em></td>
<td style="text-align: center;"><em>3</em></td>
<td style="text-align: center;"><em>8</em></td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;">*</td>
</tr>
<tr class="even">
<td style="text-align: center;">10</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">*</td>
<td style="text-align: center;"><em>3</em></td>
<td style="text-align: center;"><em>7</em></td>
<td style="text-align: center;"><em>4</em></td>
<td style="text-align: center;"><em>2</em></td>
<td style="text-align: center;">*</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">9</td>
</tr>
</tbody>
</table>
<p>从表格中可以看到：同一个个体中有重复的编号，处理办法就是把不重复的数据保留，有重复的数据采用部分映射的方法消除冲突。就是利用四七段的映射关系来确定，比如第一个个体的九位置，它本来的数据是8的，现在这个数据8跑到六位置了，而原来的六位置的数据是4，所以现在的九位置变成4，最后在看这个个体缺少哪个数据，给补上就是了。</p>
<ol start="6" type="1">
<li>变异操作</li>
</ol>
<p>​ 随机选取两个点，将其对换位置。</p>
<p>​ 产生两个[1,10]范围内的随机整数r<sub>1</sub>和r<sub>2</sub>，确定两个位置，将其对换位置，如r<sub>1</sub>=4,r<sub>2</sub>=7</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<p>变异后为</p>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>9</td>
<td>5</td>
<td>1</td>
<td><em>2</em></td>
<td>7</td>
<td>4</td>
<td><em>3</em></td>
<td>10</td>
<td>8</td>
<td>6</td>
</tr>
</tbody>
</table>
<ol start="7" type="1">
<li>逆转操作</li>
</ol>
<p>​ 为改善遗传算法的局部搜索能力。这里的“进化”是指逆转算子的单方向性，即只有经逆转后，适应度值有提高的才接受下来，否则逆转无效。</p>
<p>​ 产生两个[1,10]区间内的随机整数片r<sub>1</sub>和r<sub>2</sub>，确定两个位置，将其对换位置，如r<sub>1</sub>=4，r<sub>2</sub>=7</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th style="text-align: center;">6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
<th style="text-align: center;">10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">9</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">10</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">6</td>
</tr>
</tbody>
</table>
<p>逆转后</p>
<table>
<thead>
<tr class="header">
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>9</td>
<td>5</td>
<td>1</td>
<td><em>4</em></td>
<td><em>7</em></td>
<td><em>3</em></td>
<td>2</td>
<td>10</td>
<td>8</td>
<td>6</td>
</tr>
</tbody>
</table>
<p>​ 对每个个体进行交叉变异，然后代人适应度函数进行评估，选择出适应值大的个体进行下一代的交叉和变异以及逆转操作。</p>
<p>循环操作：判断是否满足设定的最大遗传代数,不满足则跳入适应度值的计算；否则，结束遗传操作。</p>
<h2 id="代码实现">代码实现</h2>
<h3 id="适应值变化">适应值变化</h3>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230510183559745.png"  style="zoom:80%;" /></p>
<h3 id="苹果位置图">苹果位置图</h3>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230510185112226.png"  style="zoom:80%;" /></p>
<h3 id="路径规划图">路径规划图</h3>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511155819983.png"  style="zoom:80%;" /></p>
<h2 id="最优解">最优解</h2>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511155901209.png"  style="zoom:80%;" /></p>
<hr />
<h2 id="参考文献">参考文献</h2>
<p>[1]史峰. MATLAB智能算法30个案例分析[M]. 北京航空航天大学出版社, 2011.</p>
]]></content>
      <categories>
        <category>TSP问题</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
        <tag>路径规划</tag>
      </tags>
  </entry>
  <entry>
    <title>聚类算法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="聚类cluster算法"><a href="https://baike.baidu.com/item/%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/1252197?fr=aladdin">聚类（Cluster）算法</a></h1>
<h2 id="k-means"><a href="https://baike.baidu.com/item/K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/15779627?fromtitle=K-MEANS%E7%AE%97%E6%B3%95&amp;fromid=594631&amp;fr=aladdin">K-Means</a></h2>
<p>以空间中k个点为中心进行聚类，对最靠近他们的对象归类。通过迭代的方法，逐次更新各聚类中心的值，直至得到最好的聚类结果。</p>
<p>同一聚类中的对象相似度较高；而不同聚类中的对象相似度较小。</p>
<p>算法流程：</p>
<ol type="1">
<li><p>先从没有标签的元素集合A中随机取k个元素，作为 k个子集各自的重心。</p></li>
<li><p>分别计算剩下的元素到k个子集重心的距离（这里的距离也可以使用欧氏距离），根据距离将这些元素分别划归到最近的子集。</p></li>
<li><p>根据聚类结果，重新计算重心（重心的计算方法是 计算子集中所有元素各个维度的算数平均数）。</p></li>
<li><p>将集合A中全部元素按照新的重心然后再重新聚类。</p></li>
<li><p>重复第4步，直到聚类结果不再发生变化。</p></li>
</ol>
<h2 id="示例代码">示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽视警告</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;kmeans.txt&quot;</span>, delimiter=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 设置k值，这里需要手动设置K值</span></span><br><span class="line">k=<span class="number">4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并训练模型</span></span><br><span class="line">model = KMeans(n_clusters=k,n_init=<span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">model.fit(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类中心点坐标</span></span><br><span class="line">centers = model.cluster_centers_</span><br><span class="line"><span class="built_in">print</span>(centers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测结果</span></span><br><span class="line">result = model.predict(data)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出各个数据点，用不同颜色表示分类</span></span><br><span class="line">mark = [<span class="string">&#x27;^r&#x27;</span>, <span class="string">&#x27;vb&#x27;</span>, <span class="string">&#x27;pg&#x27;</span>, <span class="string">&#x27;+c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,d <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    plt.plot(d[<span class="number">0</span>], d[<span class="number">1</span>], mark[result[i]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出各个分类的中心点</span></span><br><span class="line">mark = [<span class="string">&#x27;*r&#x27;</span>, <span class="string">&#x27;*b&#x27;</span>, <span class="string">&#x27;*g&#x27;</span>, <span class="string">&#x27;*c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,center <span class="keyword">in</span> <span class="built_in">enumerate</span>(centers):</span><br><span class="line">    plt.plot(center[<span class="number">0</span>],center[<span class="number">1</span>], mark[i], markersize=<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">x_min, x_max = data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格矩阵</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class="comment"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line"><span class="comment"># 等高线图</span></span><br><span class="line">cs = plt.contourf(xx, yy, z)</span><br><span class="line"><span class="comment"># 画出各个数据点，用不同颜色表示分类</span></span><br><span class="line">mark = [<span class="string">&#x27;^r&#x27;</span>, <span class="string">&#x27;vb&#x27;</span>, <span class="string">&#x27;pg&#x27;</span>, <span class="string">&#x27;+c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,d <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    plt.plot(d[<span class="number">0</span>], d[<span class="number">1</span>], mark[result[i]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出各个分类的中心点</span></span><br><span class="line">mark = [<span class="string">&#x27;*r&#x27;</span>, <span class="string">&#x27;*b&#x27;</span>, <span class="string">&#x27;*g&#x27;</span>, <span class="string">&#x27;*c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,center <span class="keyword">in</span> <span class="built_in">enumerate</span>(centers):</span><br><span class="line">    plt.plot(center[<span class="number">0</span>],center[<span class="number">1</span>], mark[i], markersize=<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607203700434.png"  style="zoom:50%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607203924280.png"  style="zoom:52%;" /></p>
<h2 id="mini-batch-k-means">Mini Batch K-Means</h2>
<p>采用小批量的数据子集减小计算时间。也就是随机抽取数据子集进行训练算法，结果一般只略差于标准算法。</p>
<p>1：从数据集中随机抽取一些数据形成小批量，把他们分配给最近的质心</p>
<p>2：更新质心，与<strong>K-Means</strong>算法相比，数据的更新是在每一个小的样本集上。</p>
<h2 id="示例代码-1">示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> MiniBatchKMeans</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 忽视警告</span></span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;kmeans.txt&quot;</span>, delimiter=<span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="comment"># 设置k值</span></span><br><span class="line">k = <span class="number">4</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并训练模型</span></span><br><span class="line">model = MiniBatchKMeans(n_clusters=k,n_init=<span class="string">&#x27;auto&#x27;</span>)</span><br><span class="line">model.fit(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分类中心点坐标</span></span><br><span class="line">centers = model.cluster_centers_</span><br><span class="line"><span class="built_in">print</span>(centers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测结果</span></span><br><span class="line">result = model.predict(data)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出各个数据点，用不同颜色表示分类</span></span><br><span class="line">mark = [<span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;og&#x27;</span>, <span class="string">&#x27;oy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,d <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    plt.plot(d[<span class="number">0</span>], d[<span class="number">1</span>], mark[result[i]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出各个分类的中心点</span></span><br><span class="line">mark = [<span class="string">&#x27;*r&#x27;</span>, <span class="string">&#x27;*b&#x27;</span>, <span class="string">&#x27;*g&#x27;</span>, <span class="string">&#x27;*y&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,center <span class="keyword">in</span> <span class="built_in">enumerate</span>(centers):</span><br><span class="line">    plt.plot(center[<span class="number">0</span>],center[<span class="number">1</span>], mark[i], markersize=<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">x_min, x_max = data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格矩阵</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class="comment"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line"><span class="comment"># 等高线图</span></span><br><span class="line">cs = plt.contourf(xx, yy, z)</span><br><span class="line"><span class="comment"># 显示结果</span></span><br><span class="line"><span class="comment"># 画出各个数据点，用不同颜色表示分类</span></span><br><span class="line">mark = [<span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;og&#x27;</span>, <span class="string">&#x27;oy&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,d <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    plt.plot(d[<span class="number">0</span>], d[<span class="number">1</span>], mark[result[i]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出各个分类的中心点</span></span><br><span class="line">mark = [<span class="string">&#x27;*r&#x27;</span>, <span class="string">&#x27;*b&#x27;</span>, <span class="string">&#x27;*g&#x27;</span>, <span class="string">&#x27;*y&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,center <span class="keyword">in</span> <span class="built_in">enumerate</span>(centers):</span><br><span class="line">    plt.plot(center[<span class="number">0</span>],center[<span class="number">1</span>], mark[i], markersize=<span class="number">20</span>)</span><br><span class="line">    </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607205405646.png"  style="zoom:50%;" /></p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230607204231807.png"  style="zoom:50%;" /></p>
<h1 id="dbscandensity-based-spatial-clustering-of-applications-with-noise"><a href="https://baike.baidu.com/item/DBSCAN/4864716?fr=aladdin">DBSCAN（Density-Based Spatial Clustering of Applications with Noise）</a></h1>
<p>能够将具有足够高密度的区域划分为簇，并可在噪声的空间数据库中发现任意形状的<a href="https://baike.baidu.com/item/聚类/593695?fromModule=lemma_inlink">聚类</a>。</p>
<p><span class="math inline">\(\Epsilon\)</span>邻域：给定对象半径<span class="math inline">\(\Epsilon\)</span>内的区域称为该对象的<span class="math inline">\(\Epsilon\)</span>邻域。</p>
<p>核心对象：如果给定<span class="math inline">\(\Epsilon\)</span>邻域内的样本点数大于等于<span class="math inline">\(Minpoints\)</span>，则该对象为核心对象。</p>
<p>直接密度可达：给定一个对象集合<span class="math inline">\(D\)</span>，如果<span class="math inline">\(p\)</span>在<span class="math inline">\(q\)</span>的<span class="math inline">\(\Epsilon\)</span>邻域内， 且<span class="math inline">\(q\)</span>是一个核心对象，则我们说对象<span class="math inline">\(p\)</span>从<span class="math inline">\(q\)</span>触发是直接密度可达的（directly density-reachable）。</p>
<p>密度可达：集合<span class="math inline">\(D\)</span>，存在一个对象链 <span class="math inline">\(p_1,p_2,\cdots ,pn,p_1=q,p_n=p\)</span>，<span class="math inline">\(p_{i+1}\)</span>是从<span class="math inline">\(p_i\)</span>关于𝜀和<span class="math inline">\(Minpoints\)</span>直接密度可达，则称点<span class="math inline">\(p\)</span>是从<span class="math inline">\(q\)</span>关于<span class="math inline">\(\Epsilon\)</span>和<span class="math inline">\(Minpoints\)</span>密度可达的。</p>
<p>密度相连：集合<span class="math inline">\(D\)</span>存在点<span class="math inline">\(o\)</span>，使得点<span class="math inline">\(p、q\)</span>是从<span class="math inline">\(o\)</span>关于<span class="math inline">\(\Epsilon\)</span>和 <span class="math inline">\(Minpoints\)</span>密度可达的，那么点<span class="math inline">\(p、q\)</span>是关于<span class="math inline">\(\Epsilon\)</span>和 <span class="math inline">\(Minpoints\)</span>密度相连的。</p>
<p>算法流程：</p>
<ol type="1">
<li><p>指定合适的<span class="math inline">\(\Epsilon\)</span>和 <span class="math inline">\(Minpoints\)</span>。</p></li>
<li><p>计算所有的样本点，如果点<span class="math inline">\(p\)</span>的<span class="math inline">\(\Epsilon\)</span>邻域里有超过<span class="math inline">\(Minpoints\)</span>个点，则创建一个以<span class="math inline">\(p\)</span>为核心点的新簇。</p></li>
<li><p>反复寻找这些核心点直接密度可达（之后可能是密度可达） 的点，将其加入到相应的簇，对于核心点发生“密度相连” 状况的簇，给予合并。</p></li>
<li><p>没有新的点可以被添加到任何簇时，算法结束</p></li>
</ol>
<h2 id="示例代码-2">示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;kmeans.txt&quot;</span>, delimiter=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line">result = model.fit_predict(data)</span><br><span class="line">result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出各个数据点，用不同颜色表示分类</span></span><br><span class="line">mark = [<span class="string">&#x27;or&#x27;</span>, <span class="string">&#x27;ob&#x27;</span>, <span class="string">&#x27;og&#x27;</span>, <span class="string">&#x27;oy&#x27;</span>, <span class="string">&#x27;ok&#x27;</span>, <span class="string">&#x27;om&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> i,d <span class="keyword">in</span> <span class="built_in">enumerate</span>(data):</span><br><span class="line">    plt.plot(d[<span class="number">0</span>], d[<span class="number">1</span>], mark[result[i]])</span><br><span class="line">    </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607205310944.png"  style="zoom:50%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">x1, y1 = datasets.make_circles(n_samples=<span class="number">2000</span>, factor=<span class="number">0.5</span>, noise=<span class="number">0.05</span>)</span><br><span class="line">x2, y2 = datasets.make_blobs(n_samples=<span class="number">1000</span>, centers=[[<span class="number">1.2</span>,<span class="number">1.2</span>]], cluster_std=[[<span class="number">.1</span>]])</span><br><span class="line"></span><br><span class="line">x = np.concatenate((x1, x2))</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], marker=<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line">y_pred = DBSCAN(eps = <span class="number">0.2</span>, min_samples=<span class="number">50</span>).fit_predict(x)</span><br><span class="line">plt.scatter(x[:, <span class="number">0</span>], x[:, <span class="number">1</span>], c=y_pred)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607205925872.png"  style="zoom:50%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607205903894.png"  style="zoom:50%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Rt411q7WJ?p=71&amp;vd_source=fe8e916be2bd597efffd8dfd95249141">聚类算法</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>贝叶斯算法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="贝叶斯算法">贝叶斯算法</h1>
<ul>
<li>总体信息：当前总体样本符合某种分布。比如抛硬币符合二项 分布；学生的某一科的成绩符合正态分布。</li>
<li>样本信息：通过抽样得到的部分样本的某种分布。</li>
<li>抽样信息=总体信息+样本信息</li>
<li>先验信息：抽样之前，有关推断问题中未知参数的一些信息， 通常来自于经验或历史资料。</li>
</ul>
<p>基于抽样信息进行统计推断的理论和方法称为经典统计学。</p>
<p>基于抽样信息+先验信息进行统计推断的方法和理 论，称为贝叶斯统计学。</p>
<h2 id="贝叶斯定理"><a href="https://baike.baidu.com/item/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/9683982?fr=aladdin">贝叶斯定理</a></h2>
<p>已知<span class="math inline">\(P(X|H)\)</span>，要求解<span class="math inline">\(P(H|X)\)</span> <span class="math display">\[
P(H|X)=\frac{P(X|H)P(H)}{P(X)}
\]</span></p>
<h2 id="示例代码">示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入算法包以及数据集</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report,confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB,BernoulliNB,GaussianNB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(iris.data, iris.target) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并拟合模型</span></span><br><span class="line">mul_nb = GaussianNB()</span><br><span class="line">mul_nb.fit(x_train,y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 评估</span></span><br><span class="line"><span class="built_in">print</span>(classification_report(mul_nb.predict(x_test),y_test))</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607165131324.png"  style="zoom: 67%;" /></p>
<h2 id="词袋模型bag-of-words">词袋模型(Bag of Words)</h2>
<p>Bag of words model（BoW）最早出现在自然语言处理（Natural Language Processing）和信息检索 （Information Retrieval）领域。</p>
<p>该模型忽略掉文本的语法和语序等要素，将其仅仅看作是若干个词汇的集合，文档中每个单词的出现都是独立的。BoW使用一组无序的单词(words)来表达一段文字或一个文档。</p>
<p>简单例子</p>
<p>首先给出两个简单的文本文档如下：</p>
<p>John likes to watch movies. Mary likes too.</p>
<p>John also likes to watch football games.</p>
<p>对于上述两个文档中出现的单词，构建如下一个词典 (dictionary)：</p>
<p>{“John”: 1, “likes”: 2,“to”: 3, “watch”: 4, “movies”: 5,“also”: 6, “football”: 7, “games”: 8,“Mary”: 9, “too”: 10}</p>
<p>上面的词典中包含10个单词, 每个单词有唯一的索引, 那么每个文本可以使用一个10维的向量来表示。</p>
<p>[1, 2, 1, 1, 1, 0, 0, 0, 1, 1]</p>
<p>[1, 1,1, 1, 0, 1, 1, 1, 0, 0]</p>
<p>该向量与原来文本中单词出现的顺序没有关系，而是词典中每个单词在文本中出现的频率。</p>
<h2 id="tf-idf">TF-IDF</h2>
<p>TF（Term Frequency） 词频</p>
<p>IDF （Inverse Document Frequency）逆文档频率</p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Rt411q7WJ?p=60">贝叶斯算法</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>集成学习</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="集成学习ensemble-learning"><a href="https://baike.baidu.com/item/%E5%88%86%E7%B1%BB%E5%99%A8%E9%9B%86%E6%88%90/21512231?fromtitle=%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0&amp;fromid=3440721&amp;fr=aladdin">集成学习（Ensemble Learning）</a></h1>
<p>集成学习就是组合多个学习器，最后可以得到一个更 好的学习器。</p>
<p>集成学习算法：</p>
<ol type="1">
<li><p>个体学习器之间不存在强依赖关系，装袋（Bagging）</p></li>
<li><p>随机森林（Random Forest）</p></li>
<li><p>个体学习器之间存在强依赖关系，提升（Boosting）</p></li>
<li><p>Stacking</p></li>
</ol>
<span id="more"></span>
<h2 id="bagging">Bagging</h2>
<p>Bagging也叫做Bootstrap Aggregating，是在原始 数据集选择S次后得到S个新数据集的一种技术。是一 种有放回抽样。</p>
<p>原始训练数据集<span class="math inline">\(0,1,2,3,4,5,6,7,8,9\)</span></p>
<p>Bagging采样<span class="math inline">\(1,3,5,2,6,4,2,5,7,0——未采样8,9\)</span></p>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入算法包以及数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> BaggingClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">划分数据集</span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">x_data = iris.data[:,:<span class="number">2</span>]</span><br><span class="line">y_data = iris.target</span><br><span class="line"></span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并训练KNN模型</span></span><br><span class="line">knn = neighbors.KNeighborsClassifier()</span><br><span class="line">knn.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">model</span>):</span><br><span class="line">    <span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">    x_min, x_max = x_data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">    y_min, y_max = x_data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成网格矩阵</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                         np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">    z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class="comment"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class="line">    z = z.reshape(xx.shape)</span><br><span class="line">    <span class="comment"># 等高线图</span></span><br><span class="line">    cs = plt.contourf(xx, yy, z)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plot(knn)</span><br><span class="line"><span class="comment"># 样本散点图</span></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.xlabel(<span class="string">&quot;knn&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">knn.score(x_test, y_test) <span class="comment"># KNN模型准确率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并训练bagging_knn模型</span></span><br><span class="line">bagging_knn = BaggingClassifier(knn, n_estimators=<span class="number">100</span>)</span><br><span class="line">bagging_knn.fit(x_train, y_train)</span><br><span class="line">plot(bagging_knn)</span><br><span class="line"><span class="comment"># 样本散点图</span></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;bagging_knn&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">bagging_knn.score(x_test, y_test) <span class="comment"># bagging_knn模型准确率</span></span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607113057905.png"  style="zoom:50%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607113349947.png"  style="zoom:50%;" /></p>
<h2 id="随机森林random-forest"><a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/1974765?fr=aladdin">随机森林（Random Forest）</a></h2>
<p>算法流程：</p>
<ol type="1">
<li><p>随机选取样本：在样本集用<strong>bagging</strong>的方式随机选择n个样本。</p></li>
<li><p>随机选取特征：从所有属性d中随机选择k个属性（k&lt;d），然后从k个属性中选择最佳分割属性作为节点建立 CART决策树。</p></li>
<li><p>重复以上两个步骤m次，建立m棵CART决策树。</p></li>
<li><p>这m棵CART决策树形成随机森林，通过投票表决结 果，决定数据属于哪一类。</p></li>
</ol>
<h3 id="示例代码-1">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier <span class="comment"># 集成学习中的随机森林模块</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;LR-testSet2.txt&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">x_data = data[:,:-<span class="number">1</span>]</span><br><span class="line">y_data = data[:,-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_data[:,<span class="number">0</span>],x_data[:,<span class="number">1</span>],c=y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分数据集</span></span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(x_data, y_data, test_size = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>(<span class="params">model</span>):</span><br><span class="line">    <span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">    x_min, x_max = x_data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">    y_min, y_max = x_data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成网格矩阵</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                         np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">    z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class="comment"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class="line">    z = z.reshape(xx.shape)</span><br><span class="line">    <span class="comment"># 等高线图</span></span><br><span class="line">    cs = plt.contourf(xx, yy, z)</span><br><span class="line">    <span class="comment"># 样本散点图</span></span><br><span class="line">    plt.scatter(x_test[:, <span class="number">0</span>], x_test[:, <span class="number">1</span>], c=y_test)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并训练随机森林模型</span></span><br><span class="line">RF = RandomForestClassifier(n_estimators=<span class="number">50</span>)</span><br><span class="line">RF.fit(x_train, y_train)</span><br><span class="line">plot(RF)</span><br><span class="line">RF.score(x_test, y_test)</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607114037530.png"  style="zoom:50%;" /></p>
<h2 id="boosting"><a href="https://baike.baidu.com/item/Boosting/1403912?fr=aladdin">Boosting</a></h2>
<p>AdaBoost （Adaptive Boosting）算法，它的自适应在于，前一个基本分类器被错误分类的样本的权值会增大，而正确分类的样本的权值会减小，并再次用来训练下一个基本分类器。同时，在每一轮迭代中，加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数才确定最终的强分类器。</p>
<p>算法流程：</p>
<ol type="1">
<li><p>初始化训练数据的权值分布<span class="math inline">\(D1\)</span>。假设有<span class="math inline">\(N\)</span>个训练样本数据，则每一个训练样本最开始时，都被赋予 相同的权值<span class="math inline">\(w~1~=1/N\)</span>。</p></li>
<li><p>训练弱分类器<span class="math inline">\(h_i\)</span>。</p>
<ul>
<li><p>如果某个训练样本点，被弱分类器<span class="math inline">\(h_i\)</span>准确地分类，那么在构造下一个训练集中，它对应的权值要减小；</p></li>
<li><p>如果某个训练样本点，被弱分类器<span class="math inline">\(h_i\)</span>错误分类，那么它的权值就应该增大。权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</p></li>
</ul></li>
<li><p>将各个训练得到的弱分类器组合成一个强分类器。各个弱分类器的训练过程结束后，</p>
<ul>
<li>加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，</li>
<li>降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</li>
</ul></li>
</ol>
<h3 id="示例代码-2">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> AdaBoostClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_gaussian_quantiles</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成2维正态分布，生成的数据按分位数分为两类，500个样本,2个样本特征</span></span><br><span class="line">x1, y1 = make_gaussian_quantiles(n_samples=<span class="number">500</span>, n_features=<span class="number">2</span>,n_classes=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 生成2维正态分布，生成的数据按分位数分为两类，400个样本,2个样本特征均值都为3</span></span><br><span class="line">x2, y2 = make_gaussian_quantiles(mean=(<span class="number">3</span>, <span class="number">3</span>), n_samples=<span class="number">500</span>, n_features=<span class="number">2</span>, n_classes=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 将两组数据合成一组数据</span></span><br><span class="line">x_data = np.concatenate((x1, x2))</span><br><span class="line">y_data = np.concatenate((y1, - y2 + <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># AdaBoost模型</span></span><br><span class="line">model = AdaBoostClassifier(DecisionTreeClassifier(max_depth=<span class="number">3</span>),n_estimators=<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">x_min, x_max = x_data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = x_data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格矩阵</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取预测值</span></span><br><span class="line">z = model.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line"><span class="comment"># 等高线图</span></span><br><span class="line">cs = plt.contourf(xx, yy, z)</span><br><span class="line"><span class="comment"># 样本散点图</span></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型准确率</span></span><br><span class="line">model.score(x_data,y_data)</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607153300730.png"  style="zoom:50%;" /></p>
<h2 id="stacking">Stacking</h2>
<p>使用多个不同的分类器对训练集进预测，把预测 得到的结果作为一个次级分类器的输入。次级分 类器的输出是整个模型的预测结果。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607153502918.png"  style="zoom:67%;" /></p>
<h3 id="示例代码-3">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets  </span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection  </span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier  </span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line"><span class="keyword">from</span> mlxtend.classifier <span class="keyword">import</span> StackingClassifier</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据集</span></span><br><span class="line">iris = datasets.load_iris()  </span><br><span class="line"><span class="comment"># 只要第1,2列的特征</span></span><br><span class="line">x_data, y_data = iris.data[:, <span class="number">1</span>:<span class="number">3</span>], iris.target  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义三个不同的分类器</span></span><br><span class="line">clf1 = KNeighborsClassifier(n_neighbors=<span class="number">1</span>)  </span><br><span class="line">clf2 = DecisionTreeClassifier() </span><br><span class="line">clf3 = LogisticRegression()  </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义一个次级分类器</span></span><br><span class="line">lr = LogisticRegression()  </span><br><span class="line">sclf = StackingClassifier(classifiers=[clf1, clf2, clf3],   </span><br><span class="line">                          meta_classifier=lr)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> clf,label <span class="keyword">in</span> <span class="built_in">zip</span>([clf1, clf2, clf3, sclf],</span><br><span class="line">                      [<span class="string">&#x27;KNN&#x27;</span>,<span class="string">&#x27;Decision Tree&#x27;</span>,<span class="string">&#x27;LogisticRegression&#x27;</span>,<span class="string">&#x27;StackingClassifier&#x27;</span>]):  </span><br><span class="line">    scores = model_selection.cross_val_score(clf, x_data, y_data, cv=<span class="number">3</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Accuracy: %0.2f [%s]&quot;</span> % (scores.mean(), label)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化   </span></span><br><span class="line">sclf.fit(x_train,y_train)</span><br><span class="line">plot(sclf)</span><br><span class="line">plt.scatter(x_data[:,<span class="number">0</span>],x_data[:,<span class="number">1</span>],c=y_data)    </span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607155449811.png"  style="zoom:50%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Rt411q7WJ/?p=55&amp;spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=fe8e916be2bd597efffd8dfd95249141">集成学习</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<h1 id="决策树-decision-tree"><a href="https://baike.baidu.com/item/%E5%86%B3%E7%AD%96%E6%A0%91/10377049?fr=aladdin">决策树 （Decision Tree）</a></h1>
<p>比较适合分析离散数据。 如果是连续数据要先转成离散数据再做分析</p>
<h2 id="熵entropy">熵（entropy）</h2>
<p>1948年，香浓提出了“<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E7%86%B5/7302318?fr=aladdin">信息熵</a>”的概念，</p>
<p><strong>一条信息的信息量大小和它的不确定性有直接的关系， 要搞清楚一件非常非常不确定的事情，或者是一无所知的事情，需要了解大量信息。—&gt;信息量的度量就等于不确定性的多少。</strong></p>
<span id="more"></span>
<p>信息熵公式： <span class="math display">\[
H[x]=-\sum_{x}p(x)logp(x)
\]</span></p>
<h2 id="id3算法"><a href="https://baike.baidu.com/item/ID3%E7%AE%97%E6%B3%95/5522381?fr=aladdin">ID3算法</a></h2>
<p>决策树会选择最大化信息增益来对结点进行划分。</p>
<p>信息增益（Information Gain）计算： <span class="math display">\[
Info(D)=-\sum_{i=1}^{m}p_ilog(p_i)
\]</span></p>
<p><span class="math display">\[
Info_A(D)=-\sum_{j=1}^{v}\frac{|D_j|}{|D|}\times Info(D_j)
\]</span></p>
<p><span class="math display">\[
Gain(A)=Info(D)-Info_A(D)
\]</span></p>
<table>
<thead>
<tr class="header">
<th>RID</th>
<th>age</th>
<th>income</th>
<th>student</th>
<th>credit_rating</th>
<th>class_buys_computer</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>youth</td>
<td>high</td>
<td>no</td>
<td>fair</td>
<td>no</td>
</tr>
<tr class="even">
<td>2</td>
<td>youth</td>
<td>high</td>
<td>no</td>
<td>excellent</td>
<td>no</td>
</tr>
<tr class="odd">
<td>3</td>
<td>middle_aged</td>
<td>high</td>
<td>no</td>
<td>fair</td>
<td>yes</td>
</tr>
<tr class="even">
<td>4</td>
<td>senior</td>
<td>medium</td>
<td>no</td>
<td>fair</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>5</td>
<td>senior</td>
<td>low</td>
<td>yes</td>
<td>fair</td>
<td>yes</td>
</tr>
<tr class="even">
<td>6</td>
<td>senior</td>
<td>low</td>
<td>yes</td>
<td>excellent</td>
<td>no</td>
</tr>
<tr class="odd">
<td>7</td>
<td>middle_aged</td>
<td>low</td>
<td>yes</td>
<td>excellent</td>
<td>yes</td>
</tr>
<tr class="even">
<td>8</td>
<td>youth</td>
<td>medium</td>
<td>no</td>
<td>fair</td>
<td>no</td>
</tr>
<tr class="odd">
<td>9</td>
<td>youth</td>
<td>low</td>
<td>yes</td>
<td>fair</td>
<td>yes</td>
</tr>
<tr class="even">
<td>10</td>
<td>senior</td>
<td>medium</td>
<td>yes</td>
<td>fair</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>11</td>
<td>youth</td>
<td>medium</td>
<td>yes</td>
<td>excellent</td>
<td>yes</td>
</tr>
<tr class="even">
<td>12</td>
<td>middle_aged</td>
<td>medium</td>
<td>no</td>
<td>excellent</td>
<td>yes</td>
</tr>
<tr class="odd">
<td>13</td>
<td>middle_aged</td>
<td>high</td>
<td>yes</td>
<td>fair</td>
<td>yes</td>
</tr>
<tr class="even">
<td>14</td>
<td>senior</td>
<td>medium</td>
<td>no</td>
<td>excellent</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>计算<strong>age</strong>的信息增益: <span class="math display">\[
Info(D)=-\frac{9}{14}log_2(\frac{9}{14})-\frac{5}{14}log_2(\frac{5}{14})=0.94
\]</span></p>
<p><span class="math display">\[
Info_{age}(D)=\frac{5}{14}(-\frac{2}{5}log_2\frac{2}{5}-\frac{3}{5}log_2\frac{3}{5})+
\frac{4}{14}(-\frac{4}{4}log_2\frac{4}{4}-\frac{0}{4}log_2\frac{0}{4})+
\frac{5}{14}(-\frac{3}{5}log_2\frac{3}{5}-\frac{2}{5}log_2\frac{2}{5})
\]</span></p>
<p><span class="math display">\[
Gain(age)=Info(D)-Info_A(D)=0.94-0.694=0.246
\]</span></p>
<p>其他的也是类似计算。</p>
<h2 id="c4.5算法"><a href="https://baike.baidu.com/item/C4.5%E7%AE%97%E6%B3%95/20814636">C4.5算法</a></h2>
<p>信息增益的方法倾向于首先选择因子数较多的变量 。</p>
<p>信息增益的改进：增益率 <span class="math display">\[
SplitInfo_A(D)=-\sum_{j=1}^{v}\frac{|D_j|}{|D|}\times log_2(\frac{|D_j|}{|D|})
\]</span></p>
<p><span class="math display">\[
GainRatio(A)=\frac{Gain(A)}{SpliInfo_A(D)}
\]</span></p>
<h2 id="cart算法"><a href="https://baike.baidu.com/item/CART/17679070">CART算法</a></h2>
<p>CART决策树的生成就是递归地构建二叉决策树的过程。</p>
<p>CART用基尼（Gini）系数最小化准则来进行特征选择，生成二叉树。</p>
<p>Gini系数计算： <span class="math display">\[
Gini(D)=1-\sum_{i=1}^{m}p_i^2
\]</span></p>
<p><span class="math display">\[
Gini_A(D)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)
\]</span></p>
<p><span class="math display">\[
\Delta Gini(A)=Gini(D)-Gini_A(D)
\]</span></p>
<p>优点：小规模数据集有效</p>
<p>缺点： 处理连续变量不好 类别较多时，错误增加的比较快 不能处理大量数据</p>
<h2 id="线性二分类示例代码">线性二分类示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree <span class="comment"># 决策树模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;LR-testSet.csv&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">x_data = data[:,:-<span class="number">1</span>]</span><br><span class="line">y_data = data[:,-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_data[:,<span class="number">0</span>],x_data[:,<span class="number">1</span>],c=y_data) </span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建决策树模型</span></span><br><span class="line">model = tree.DecisionTreeClassifier()</span><br><span class="line"><span class="comment"># 输入数据建立模型</span></span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">x_min, x_max = x_data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = x_data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格矩阵</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class="comment"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line"><span class="comment"># 等高线图</span></span><br><span class="line">cs = plt.contourf(xx, yy, z)</span><br><span class="line"><span class="comment"># 样本散点图</span></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试与评估</span></span><br><span class="line">predictions = model.predict(x_data)</span><br><span class="line"><span class="built_in">print</span>(classification_report(predictions,y_data))</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607084609741.png"  style="zoom:50%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230606214438933.png"  style="zoom:67%;" /></p>
<h2 id="非线性二分类示例代码">非线性二分类示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;LR-testSet2.txt&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">x_data = data[:,:-<span class="number">1</span>]</span><br><span class="line">y_data = data[:,-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">plt.scatter(x_data[:,<span class="number">0</span>],x_data[:,<span class="number">1</span>],c=y_data) <span class="comment"># s散点图</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment">#分割数据</span></span><br><span class="line">x_train,x_test,y_train,y_test = train_test_split(x_data, y_data) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建决策树模型</span></span><br><span class="line"><span class="comment"># max_depth，树的深度</span></span><br><span class="line"><span class="comment"># min_samples_split 内部节点再划分所需最小样本数</span></span><br><span class="line">model = tree.DecisionTreeClassifier(max_depth=<span class="number">7</span>,min_samples_split=<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 拟合模型</span></span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">x_min, x_max = x_data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = x_data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格矩阵</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">z = model.predict(np.c_[xx.ravel(), yy.ravel()])<span class="comment"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line"><span class="comment"># 等高线图</span></span><br><span class="line">cs = plt.contourf(xx, yy, z)</span><br><span class="line"><span class="comment"># 样本散点图</span></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试并评估</span></span><br><span class="line">predictions = model.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(classification_report(predictions,y_test))</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607084429752.png"  style="zoom: 50%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607084526669.png"  style="zoom:67%;" /></p>
<h2 id="回归树示例代码">回归树示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> tree</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;data.csv&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">x_data = data[:,<span class="number">0</span>,np.newaxis]</span><br><span class="line">y_data = data[:,<span class="number">1</span>,np.newaxis]</span><br><span class="line">plt.scatter(x_data,y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">model = tree.DecisionTreeRegressor(max_depth=<span class="number">5</span>)</span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line">x_test = np.linspace(<span class="number">20</span>,<span class="number">80</span>,<span class="number">100</span>)</span><br><span class="line">x_test = x_test[:,np.newaxis]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plt.plot(x_data, y_data, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.plot(x_test, model.predict(x_test), <span class="string">&#x27;r&#x27;</span>) </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230607090010220.png"  style="zoom:50%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Rt411q7WJ?p=50&amp;vd_source=fe8e916be2bd597efffd8dfd95249141">决策树</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>KNN算法</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/KNN%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="k最近邻k-nearest-neighborknn分类算法"><a href="https://baike.baidu.com/item/k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/9512781?fr=aladdin">K最近邻（K-Nearest Neighbor，KNN）</a>分类算法</h1>
<ol type="1">
<li>为了判断未知实例的类别，以所有已知类别的实例作为 参照选择参数K</li>
<li>计算未知实例与所有已知实例的距离</li>
<li>选择最近K个已知实例</li>
<li>根据少数服从多数的投票法则(majority-voting)，让 未知实例归类为K个最邻近样本中最多数的类别</li>
</ol>
<span id="more"></span>
<p>欧氏距离 <span class="math display">\[
E(x,y)=\sqrt{\sum_{i=0}^{n}(x_i-y_i)^2}
\]</span> <a href="https://www.cnblogs.com/belfuture/p/5871452.html">其他的距离衡量</a>：余弦值距离（cos），相关度（correlation），曼哈顿距离（Manhattan distance）</p>
<p>算法缺点：</p>
<ul>
<li>算法复杂度较高（需要比较所有已知实例与要分类的实例）</li>
<li>当其样本分布不平衡时，比如其中一类样本过大（实例数量过多）占主导的时候，新的未知实例容易被归类为这个主导样本，因为这类样本实例的数量过大，但这个新的未知实例实际并没有接近目标样本</li>
</ul>
<h2 id="示例代码">示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入算法包以及数据集</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> neighbors</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"><span class="built_in">print</span>(iris)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打乱数据切分数据集</span></span><br><span class="line"><span class="comment"># x_train,x_test,y_train,y_test = train_test_split(iris.data, iris.target, test_size=0.2) #分割数据0.2为测试数据，0.8为训练数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打乱数据</span></span><br><span class="line">data_size = iris.data.shape[<span class="number">0</span>]</span><br><span class="line">index = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(data_size)] </span><br><span class="line">random.shuffle(index)  </span><br><span class="line">iris.data = iris.data[index]</span><br><span class="line">iris.target = iris.target[index]</span><br><span class="line"></span><br><span class="line"><span class="comment">#切分数据集</span></span><br><span class="line">test_size = <span class="number">40</span></span><br><span class="line">x_train = iris.data[test_size:]</span><br><span class="line">x_test =  iris.data[:test_size]</span><br><span class="line">y_train = iris.target[test_size:]</span><br><span class="line">y_test = iris.target[:test_size]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line">model = neighbors.KNeighborsClassifier(n_neighbors=<span class="number">3</span>)</span><br><span class="line">model.fit(x_train, y_train)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试和评估</span></span><br><span class="line">prediction = model.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test, prediction))</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230606202144425.png"  style="zoom: 67%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Rt411q7WJ?p=41&amp;vd_source=fe8e916be2bd597efffd8dfd95249141">KNN算法</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="逻辑回归logistic-regression"><a href="https://baike.baidu.com/item/logistic%E5%9B%9E%E5%BD%92/2981575?fromtitle=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&amp;fromid=17202449&amp;fr=aladdin">逻辑回归（Logistic Regression）</a></h1>
<p>是一种广义的线性回归分析模型，与多重线性回归有很多相同之处。它们的模型形式基本上相同，都具有$ w’x+b$，其区别在于他们的因变量不同，</p>
<ul>
<li>多重线性回归直接将<span class="math inline">\(w&#39;x+b\)</span>作为因变量，</li>
<li>Logistic回归则通过函数L将<span class="math inline">\(w&#39;x+b\)</span>对应一个隐状态<span class="math inline">\(p\)</span>，<span class="math inline">\(p =L(w&#39;x+b)\)</span>，然后根据<span class="math inline">\(p\)</span>与<span class="math inline">\(1-p\)</span>的大小决定因变量的值。</li>
</ul>
<p>如果L是Logistic函数，就是Logistic回归，</p>
<p>如果L是多项式函数就是多项式回归。</p>
<span id="more"></span>
<h2 id="logistic-function">Logistic Function</h2>
<p>定义逻辑回归的预测函数为<span class="math inline">\(ℎ_\theta(x) = 𝑔(\theta^𝑇𝑥)\)</span> ，其中g(x)函数是sigmoid函数。 <span class="math display">\[
g(x)=\frac{1}{1+e^{-x}}
\]</span></p>
<p><span class="math display">\[
h_\theta(x)=\frac{1}{1+e^{-\theta^Tx}}
\]</span></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230606093600860.png"  style="zoom:50%;" /></p>
<ol type="1">
<li>当<span class="math inline">\(\theta^Tx≥0\)</span>，<span class="math inline">\(g(\theta^Tx)≥0.5\)</span></li>
<li>当<span class="math inline">\(\theta^Tx≤0\)</span>，<span class="math inline">\(g(\theta^Tx)≤0.5\)</span></li>
</ol>
<h2 id="逻辑回归的代价函数cost-function">逻辑回归的代价函数（Cost Function）</h2>
<p><span class="math display">\[
Cost(h_\theta(x),y)= 
\begin{cases}
-log(h_\theta(x))\quad\quad\quad if\quad y=1\\
-log(1-h_\theta(x))\quad if\quad y=0
\end{cases}
\]</span></p>
<p><span class="math display">\[
=-ylog(h_\theta(x))-(1-y)log(1-h_\theta(x))
\]</span></p>
<h2 id="梯度下降法gradient-descent">梯度下降法（Gradient Descent）</h2>
<p><span class="math display">\[
J(\theta)=-\frac{1}{m}[\sum_{i=1}^{m}y^{(i)}logh_\theta(x^{(i)})+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]
\]</span></p>
<p>求解 <span class="math inline">\(min_\theta J(\theta)\)</span> <span class="math display">\[
\theta_j:=\theta_j-\alpha\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}
\]</span></p>
<h2 id="准确率精准率召回率f1分数">准确率|精准率|召回率|F<sub>1</sub>分数</h2>
<p>混淆矩阵</p>
<table>
<thead>
<tr class="header">
<th></th>
<th></th>
<th>实际</th>
<th>实际</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td>1</td>
<td>0</td>
</tr>
<tr class="even">
<td>预测</td>
<td>1</td>
<td>TP</td>
<td>FP</td>
</tr>
<tr class="odd">
<td>预测</td>
<td>0</td>
<td>FN</td>
<td>TN</td>
</tr>
</tbody>
</table>
<ul>
<li>P（Positive）：代表1</li>
<li>N（Negative）：代表0</li>
<li>T（True）：代表预测正确</li>
<li>F（False）：代表预测错误</li>
</ul>
<p><strong>准确率：</strong>即预测正确的结果占总样本的百分比 <span class="math display">\[
准确率=\frac{TP+TN}{TP+TN+FP+FN}
\]</span> <strong>精准率（Precision）：</strong>是指在所有被预测为正的样本中实际为正的样本的概率。 <span class="math display">\[
精准率=\frac{TP}{TP+FP}
\]</span> <strong>精准率就是你认为找的是对的实际上多少是对的</strong></p>
<p><strong>召回率（Recall）：</strong>是指在实际为正的样本中被预测为正样本的概率。 <span class="math display">\[
召回率=\frac{TP}{TP+FN}
\]</span> <strong>F<sub>1</sub>分数：</strong>精准率和召回率之间的一个平衡点。 <span class="math display">\[
F_1=\frac{2\times Precision\times Recall}{Precision+Recall}
\]</span></p>
<h2 id="逻辑回归示例代码">逻辑回归示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="comment"># 数据是否需要标准化</span></span><br><span class="line">scale = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;LR-testSet.csv&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">x_data = data[:,:-<span class="number">1</span>]</span><br><span class="line">y_data = data[:,-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot</span>():</span><br><span class="line">    x0 = []</span><br><span class="line">    x1 = []</span><br><span class="line">    y0 = []</span><br><span class="line">    y1 = []</span><br><span class="line">    <span class="comment"># 切分不同类别的数据</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x_data)):</span><br><span class="line">        <span class="keyword">if</span> y_data[i]==<span class="number">0</span>:</span><br><span class="line">            x0.append(x_data[i,<span class="number">0</span>])</span><br><span class="line">            y0.append(x_data[i,<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x1.append(x_data[i,<span class="number">0</span>])</span><br><span class="line">            y1.append(x_data[i,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画图</span></span><br><span class="line">   scatter0 = plt.scatter(x0, y0, c=<span class="string">&#x27;c&#x27;</span>, marker=<span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">    scatter1 = plt.scatter(x1, y1, c=<span class="string">&#x27;y&#x27;</span>, marker=<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">    <span class="comment">#画图例</span></span><br><span class="line">    plt.legend(handles=[scatter0,scatter1],labels=[<span class="string">&#x27;label0&#x27;</span>,<span class="string">&#x27;label1&#x27;</span>],loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">plot()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并拟合模型</span></span><br><span class="line">logistic = linear_model.LogisticRegression()</span><br><span class="line">logistic.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> scale == <span class="literal">False</span>:</span><br><span class="line">    <span class="comment"># 画图决策边界</span></span><br><span class="line">    plot()</span><br><span class="line">    x_test = np.array([[-<span class="number">4</span>],[<span class="number">3</span>]])</span><br><span class="line">    y_test = (-logistic.intercept_ - x_test*logistic.coef_[<span class="number">0</span>][<span class="number">0</span>])/logistic.coef_[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    plt.plot(x_test, y_test, <span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 测试与评估    </span></span><br><span class="line">predictions = logistic.predict(x_data)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_data, predictions))</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230606164354040.png"  style="zoom:50%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230606164557574.png"  style="zoom: 67%;" /></p>
<h2 id="非线性逻辑回归示例代码">非线性逻辑回归示例代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_gaussian_quantiles</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成2维正态分布，生成的数据按分位数分为两类，500个样本,2个样本特征</span></span><br><span class="line"><span class="comment"># 可以生成两类或多类数据</span></span><br><span class="line">x_data, y_data = make_gaussian_quantiles(n_samples=<span class="number">500</span>, n_features=<span class="number">2</span>,n_classes=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并拟合模型</span></span><br><span class="line">logistic = linear_model.LogisticRegression()</span><br><span class="line">logistic.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多项式回归,degree的值可以调节多项式的特征</span></span><br><span class="line">poly_reg  = PolynomialFeatures(degree=<span class="number">5</span>) </span><br><span class="line"><span class="comment"># 特征处理</span></span><br><span class="line">x_poly = poly_reg.fit_transform(x_data)</span><br><span class="line"><span class="comment"># 定义逻辑回归模型</span></span><br><span class="line">logistic = linear_model.LogisticRegression()</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">logistic.fit(x_poly, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据值所在的范围</span></span><br><span class="line">x_min, x_max = x_data[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">y_min, y_max = x_data[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, x_data[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格矩阵</span></span><br><span class="line">xx, yy = np.meshgrid(np.arange(x_min, x_max, <span class="number">0.02</span>),</span><br><span class="line">                     np.arange(y_min, y_max, <span class="number">0.02</span>))</span><br><span class="line"></span><br><span class="line">z = logistic.predict(poly_reg.fit_transform(np.c_[xx.ravel(), yy.ravel()]))<span class="comment"># ravel与flatten类似，多维数据转一维。flatten不会改变原始数据，ravel会改变原始数据</span></span><br><span class="line">z = z.reshape(xx.shape)</span><br><span class="line"><span class="comment"># 等高线图</span></span><br><span class="line">cs = plt.contourf(xx, yy, z)</span><br><span class="line"><span class="comment"># 样本散点图</span></span><br><span class="line">plt.scatter(x_data[:, <span class="number">0</span>], x_data[:, <span class="number">1</span>], c=y_data)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;score:&#x27;</span>,logistic.score(x_poly,y_data))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230606165631817.png"  style="zoom:67%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Rt411q7WJ?p=29">逻辑回归</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归及非线性回归</title>
    <url>/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%8F%8A%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    <content><![CDATA[<h1 id="基本概念">基本概念：</h1>
<p>将数据划分为三部分：<span class="math inline">\(\begin{cases} 训练集(Train):用来训练，构建模型\\ 验证集(Validate):在模型训练阶段，测试模型的好坏\\ 测试集(Test):等模型训练好后，评估模型的好坏 \end{cases}\)</span></p>
<span id="more"></span>
<p>学习方式：<span class="math inline">\(\begin{cases} 监督学习\\ 无监督学习\\ 半监督学习 \end{cases}\)</span></p>
<p>常见应用：<span class="math inline">\(\begin{cases} 回归：预测数据为连续型数值。\\ 分类：预测数据为类别型数据，并且类别已知。\\ 聚类：预测数据为类别型数据，但是类别未知。 \end{cases}\)</span></p>
<h1 id="回归分析regression"><a href="https://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/2625498?fr=aladdin">回归分析（Regression）</a></h1>
<p>回归分析用来建立方程，模拟两个或者多个变量之间如何关联，</p>
<ul>
<li>被预测的变量叫做：因变量/输出</li>
<li>被用来进行预测的变量叫做： 自变量,/输入</li>
</ul>
<p>一元线性回归包含一个自变量和一个因变量，两个变量的关系用一条直线来模拟，如果包含两个以上的自变量，则称作多元回归分析（multiple regression）</p>
<h1 id="一元线性回归"><a href="https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/22770888?fr=aladdin">一元线性回归</a></h1>
<p>一元线性回归：<span class="math inline">\(h_\theta(x)=\theta_0+\theta_1x\)</span></p>
<h2 id="代价函数cost-function"><a href="https://baike.baidu.com/item/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/1783236?fromtitle=%E4%BB%A3%E4%BB%B7%E5%87%BD%E6%95%B0&amp;fromid=7048599&amp;fr=aladdin">代价函数（Cost Function）</a></h2>
<p><strong>最小二乘法</strong></p>
<p>假设真实值为<span class="math inline">\(y\)</span>，预测值<span class="math inline">\(h_\theta(x)\)</span> ，则误差平方为<span class="math inline">\((h_\theta(x)-y)^2\)</span></p>
<p>找到合适的参数，使得误差平方和<span class="math inline">\(J(\theta_0,\theta_1)\)</span>最小。 <span class="math display">\[
J(\theta_0,\theta_1)=\frac{1}{2m}\sum_{i=1}^{m}{(h_\theta(x^{(i)})-y^{(i)})^{2}}
\]</span></p>
<h2 id="梯度下降法gradient-descent"><a href="https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/8641233?fr=aladdin">梯度下降法（Gradient Descent）</a></h2>
<p><strong>最小化目标函数</strong> <span class="math inline">\(\underset{\theta_0,\theta_1}{min}\quad J(\theta_0,\theta_1)\)</span></p>
<p>初始化参数<span class="math inline">\(\theta_0,\theta_1\)</span></p>
<p>不断改变<span class="math inline">\(\theta_0,\theta_1\)</span> ，直到<span class="math inline">\(J(\theta_0,\theta_1)\)</span>到达一个全局最小值，或局部极小值。 <span class="math display">\[
\theta_j:=\theta_j-\alpha\frac{\partial}{\partial\theta_j}J(\theta_0,\theta_1)\quad (j=0,1,2\cdots)
\]</span></p>
<h2 id="用梯度下降法求解线性回归">用梯度下降法求解线性回归</h2>
<p><span class="math display">\[
\frac{\partial}{\partial\theta_0}J(\theta_0,\theta_1)=
\frac{1}{m}\sum_{i=1}^{m}{(h_\theta(x^{(i)})-y^{(i)})}
\\
\]</span></p>
<p><span class="math display">\[
\frac{\partial}{\partial\theta_1}J(\theta_0,\theta_1)=
\frac{1}{m}\sum_{i=1}^{m}{(h_\theta(x^{(i)})-y^{(i)})}\times x^{(i)}
\]</span></p>
<p>不断迭代，直到收敛： <span class="math display">\[
\theta_0:=\theta_0-\alpha\frac{1}{m}{\sum_{i=1}^{m}{(h_\theta(x^{(i)})-y^{(i)})}}
\]</span></p>
<p><span class="math display">\[
\theta_1:=\theta_1-\alpha\frac{1}{m}{\sum_{i=1}^{m}{(h_\theta(x^{(i)})-y^{(i)})}}\times x^{(i)}
\]</span></p>
<h2 id="示例代码">示例代码：</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression <span class="comment"># 线性回归模型</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;data.csv&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">x_data = data[:,<span class="number">0</span>]</span><br><span class="line">y_data = data[:,<span class="number">1</span>]</span><br><span class="line">plt.scatter(x_data,y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">x_data = data[:,<span class="number">0</span>,np.newaxis]</span><br><span class="line">y_data = data[:,<span class="number">1</span>,np.newaxis]</span><br><span class="line"><span class="comment"># 创建并拟合模型</span></span><br><span class="line">model = LinearRegression() <span class="comment"># 线性回归</span></span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x_test = [[<span class="number">44.5</span>]]</span><br><span class="line">predict = model.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;predict&#x27;</span>,predict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plt.plot(x_data, y_data, <span class="string">&#x27;b.&#x27;</span>)</span><br><span class="line">plt.plot(x_data, model.predict(x_data), <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230605203607162.png"  style="zoom:50%;" /></p>
<h1 id="多元线性回归multiple-linear-regression"><a href="https://baike.baidu.com/item/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/10702248?fr=aladdin">多元线性回归（Multiple Linear Regression）</a></h1>
<p>多特征时，假设：<span class="math inline">\(h_\theta(x)=\theta_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n\)</span></p>
<p>当真实值<span class="math inline">\(y\)</span>的影响因素不是唯一时，需采用多元线性回归模型。</p>
<p>代价函数： <span class="math display">\[
J(\theta_0,\theta_1,\cdots,\theta_n)=\frac{1}{2m}\sum_{i=1}^{m}(h_\theta(x^{(i)})-y^{(i)})^{2}
\]</span> 梯度下降法： <span class="math display">\[
\theta_j:=\theta_j-\alpha\frac{1}{m}\sum_{i=1}^{m}{(h_\theta(x^{(i)})-y^{(i)})}\times x_j^{(i)}\quad (j=0,1,2\cdots,n)
\]</span> 注意这里的<span class="math inline">\(j=0\)</span>时，<span class="math inline">\(x_0=1\)</span></p>
<h2 id="示例代码-1">示例代码：</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model <span class="comment"># 线性回归模型</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt  </span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据 </span></span><br><span class="line">data = genfromtxt(<span class="string">r&quot;Delivery.csv&quot;</span>,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分数据</span></span><br><span class="line">x_data = data[:,:-<span class="number">1</span>]</span><br><span class="line">y_data = data[:,-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(x_data)</span><br><span class="line"><span class="built_in">print</span>(y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line">model = linear_model.LinearRegression()</span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">x_test = [[<span class="number">102</span>,<span class="number">4</span>]]</span><br><span class="line">predict = model.predict(x_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;predict:&quot;</span>,predict)</span><br><span class="line"></span><br><span class="line">ax = plt.figure().add_subplot(<span class="number">111</span>, projection = <span class="string">&#x27;3d&#x27;</span>) </span><br><span class="line">ax.scatter(x_data[:,<span class="number">0</span>], x_data[:,<span class="number">1</span>], y_data, c = <span class="string">&#x27;r&#x27;</span>, marker = <span class="string">&#x27;o&#x27;</span>, s = <span class="number">100</span>) <span class="comment">#点为红色三角形  </span></span><br><span class="line">x0 = x_data[:,<span class="number">0</span>]</span><br><span class="line">x1 = x_data[:,<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 生成网格矩阵</span></span><br><span class="line">x0, x1 = np.meshgrid(x0, x1)</span><br><span class="line">z = model.intercept_ + x0*model.coef_[<span class="number">0</span>] + x1*model.coef_[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 画3D图</span></span><br><span class="line">ax.plot_surface(x0, x1, z)</span><br><span class="line"><span class="comment">#设置坐标轴  </span></span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;Miles&#x27;</span>)  </span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;Num of Deliveries&#x27;</span>)  </span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;Time&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#显示图像  </span></span><br><span class="line">plt.show()  </span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230605204147960.png"  style="zoom:50%;" /></p>
<h1 id="多项式回归">多项式回归</h1>
<p>假如我们不是要找直线（或者超平面），而是需要找到一 个用多项式所表示的曲线（或者超曲面）</p>
<p>多项式回归：<span class="math inline">\(h_\theta(x)=\theta_0+\theta_1x+\theta_2x^2+\cdots+\theta_nx^n\)</span></p>
<h2 id="示例代码-2">示例代码：</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures </span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line">data = np.genfromtxt(<span class="string">&quot;job.csv&quot;</span>, delimiter=<span class="string">&quot;,&quot;</span>)</span><br><span class="line">x_data = data[<span class="number">1</span>:,<span class="number">1</span>]</span><br><span class="line">y_data = data[<span class="number">1</span>:,<span class="number">2</span>]</span><br><span class="line">plt.scatter(x_data,y_data)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">x_data = x_data[:,np.newaxis]</span><br><span class="line">y_data = y_data[:,np.newaxis]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多项式回归,degree的值可以调节多项式的特征</span></span><br><span class="line">poly_reg  = PolynomialFeatures(degree=<span class="number">5</span>) </span><br><span class="line"><span class="comment"># 特征处理</span></span><br><span class="line">x_poly = poly_reg.fit_transform(x_data)</span><br><span class="line"><span class="comment"># 定义回归模型</span></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">lin_reg.fit(x_poly, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plt.plot(x_data, y_data, <span class="string">&#x27;b.&#x27;</span>)</span><br><span class="line">x_test = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">100</span>)</span><br><span class="line">x_test = x_test[:,np.newaxis]</span><br><span class="line">plt.plot(x_test, lin_reg.predict(poly_reg.fit_transform(x_test)), c=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Truth or Bluff (Polynomial Regression)&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Position level&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Salary&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230605205328029.png"  style="zoom:50%;" /></p>
<h1 id="标准方程法normal-equation">标准方程法（Normal Equation）</h1>
<p>注意这里的符号：<span class="math inline">\(w\)</span>其实就是上面公式里的<span class="math inline">\(\theta\)</span>，就是要求解的那个参数。</p>
<p>假设： <span class="math display">\[
h_w(x)=w_0+w_1x_1+w_2x_2+\cdots+w_nx_n
\]</span></p>
<p><span class="math display">\[
h_w(x)=xw\
\]</span></p>
<p>目标函数: <span class="math display">\[
J(w_0,w_1,\cdots,w_n)=\frac{1}{2m}\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^{2}
\]</span> 又因为 <span class="math display">\[
\sum_{i=1}^{m}(h_w(x^{(i)})-y^{(i)})^{2}=(y-Xw)^T(y-Xw)
\]</span> 所以 <span class="math display">\[
\frac{\partial J(w)}{\partial w}=\frac{\partial(y-Xw)^T(y-Xw)}{\partial w}
\]</span></p>
<p><span class="math display">\[
=\frac{\partial(y^Ty-y^TXw-w^TX^Ty+w^TX^TXw)}{\partial w}
\]</span></p>
<p><span class="math display">\[
=\frac{\partial(y^Ty)}{\partial w}-\frac{\partial(y^TXw)}{\partial w}-\frac{\partial(w^TX^Ty)}{\partial w}+\frac{\partial(w^TX^TXw)}{\partial w}
\]</span></p>
<p><span class="math display">\[
=0-X^Ty-X^Ty+2X^TXw
\]</span></p>
<p>令 <span class="math display">\[
\frac{\partial J(w)}{\partial w}=0
\]</span> 求解： <span class="math display">\[
-2X^Ty+2X^TXw=0
\]</span></p>
<p><span class="math display">\[
X^TXw=X^Ty
\]</span></p>
<p><span class="math display">\[
w=(X^TX)^{-1}X^Ty
\]</span></p>
<h1 id="特征缩放"><a href="https://baike.baidu.com/item/%E7%89%B9%E5%BE%81%E7%BC%A9%E6%94%BE/17415222?fr=aladdin">特征缩放</a></h1>
<h2 id="数据归一化">数据归一化</h2>
<p>数据归一化就是把数据的取值范围处理为<span class="math inline">\(0-1\)</span>，或者<span class="math inline">\(-1-1\)</span>之间。</p>
<p>任意数据转化为0-1之间： <span class="math display">\[
NewValue = \frac{OldValue-min}{max-min}
\]</span> 任意数据转化为-1-1之间： <span class="math display">\[
NewValue=2\times(\frac{OldVaule-min}{max-min}-0.5)
\]</span></p>
<h2 id="均值标准化">均值标准化</h2>
<p><span class="math inline">\(x\)</span>为特征数据，<span class="math inline">\(u\)</span>为数据的平均值，<span class="math inline">\(s\)</span>为数据的方差。 <span class="math display">\[
NewValue=\frac{OldValue-u}{s}
\]</span></p>
<h1 id="过拟合overfitting">过拟合（Overfitting）</h1>
<p>回归问题拟合有以下三种情况：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230605154335888.png"  style="zoom:50%;" /></p>
<p>分类问题有以下三种情况：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230605154600447.png" style="zoom:50%;" /></p>
<p>防止过拟合：减少特征；增加数据量；正则化（Regularized）</p>
<h2 id="正则化">正则化</h2>
<p>L2正则化： <span class="math display">\[
J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m}{h_\theta(x^{(i)}-y^{(i)})^2+\lambda\sum_{j=1}^{n}{\theta_j^2}}]
\]</span> L1正则化： <span class="math display">\[
J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m}{h_\theta(x^{(i)}-y^{(i)})^2+\lambda\sum_{j=1}^{n}{|\theta_j|}}]
\]</span></p>
<h1 id="岭回归ridge-regression"><a href="https://baike.baidu.com/link?url=J428YjCOAduEv-hDj1BM53FvjQEMC1iR9icG161YvlKwmXXmtsgGoFBvkL_VK2T40KfCjPMUpQQ8ePln0cjp50QpceYEGvvCC4iewQhwY0fGCqcS9kwQCLnbARBjd0mT">岭回归（Ridge Regression）</a></h1>
<p>由标准方程法得出， <span class="math display">\[
w = (𝑋^𝑇𝑋)^{-1}𝑋^𝑇y
\]</span> 如果数据的特征比样本点还多，（数据特征<span class="math inline">\(n\)</span>，样本个数<span class="math inline">\(m\)</span>），如果<span class="math inline">\(n&gt;m\)</span>，<span class="math inline">\(𝑋^𝑇𝑋\)</span>不是满秩矩阵，不可逆，计算<span class="math inline">\(𝑋^𝑇𝑋^{-1}\)</span>时会出错。</p>
<p>为了解决这个问题，引入了岭回归的概念。<span class="math inline">\(\lambda\)</span>为岭系数，<span class="math inline">\(I\)</span>为单位矩阵。 <span class="math display">\[
w = (𝑋^𝑇𝑋 + \lambda I)^{-1}𝑋^𝑇y
\]</span> 推导： <span class="math display">\[
J(\theta)=\frac{1}{2}[\sum_{i=1}^{m}{h_\theta(x^{(i)}-y^{(i)})^2+\lambda\sum_{j=1}^{n}{\theta_j^2}}]
\]</span></p>
<p><span class="math display">\[
=\frac{1}{2}(Xw-y)^T(Xw-y)+\lambda w^Tw
\]</span></p>
<p><span class="math display">\[
=\frac{1}{2}(w^TX^TXw-w^TX^Ty-y^TXw+y^Ty)+\lambda w^Tw
\]</span></p>
<p><span class="math display">\[
\frac{\partial J(w)}{\partial w}=X^TXw-X^Ty+\lambda w
\]</span></p>
<p>令 <span class="math display">\[
\frac{\partial J(w)}{\partial w}=0
\]</span></p>
<p><span class="math display">\[
w = (𝑋^𝑇𝑋 + \lambda I)^{-1}𝑋^𝑇y
\]</span></p>
<h2 id="示例代码-3">示例代码：</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据 </span></span><br><span class="line">data = genfromtxt(<span class="string">r&quot;longley.csv&quot;</span>,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分数据</span></span><br><span class="line">x_data = data[<span class="number">1</span>:,<span class="number">2</span>:]</span><br><span class="line">y_data = data[<span class="number">1</span>:,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(x_data)</span><br><span class="line"><span class="built_in">print</span>(y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建模型</span></span><br><span class="line"><span class="comment"># 生成50个值</span></span><br><span class="line">alphas_to_test = np.linspace(<span class="number">0.001</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 创建模型，保存误差值</span></span><br><span class="line">model = linear_model.RidgeCV(alphas=alphas_to_test, store_cv_values=<span class="literal">True</span>)</span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line"><span class="comment"># 岭系数跟loss值的关系</span></span><br><span class="line">plt.plot(alphas_to_test, model.cv_values_.mean(axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 选取的岭系数值的位置</span></span><br><span class="line">plt.plot(model.alpha_, <span class="built_in">min</span>(model.cv_values_.mean(axis=<span class="number">0</span>)),<span class="string">&#x27;ro&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;alphas&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;loss&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">model.predict(x_data[<span class="number">2</span>,np.newaxis])</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230605210828441.png"  style="zoom:50%;" /></p>
<h1 id="lassoleast-absolute-shrinkage-and">[LASSO（Least Absolute Shrinkage and</h1>
<p>Selectionator operator）](https://baike.baidu.com/item/Lasso%E7%AE%97%E6%B3%95/22685468?fromtitle=LASSO&amp;fromid=20366865&amp;fr=aladdin)</p>
<p>LASSO的代价函数： <span class="math display">\[
J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m}{h_\theta(x^{(i)}-y^{(i)})^2+\lambda\sum_{j=1}^{n}{|\theta_j|}}]
\]</span></p>
<h2 id="示例代码-4">示例代码：</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据 </span></span><br><span class="line">data = genfromtxt(<span class="string">r&quot;longley.csv&quot;</span>,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分数据</span></span><br><span class="line">x_data = data[<span class="number">1</span>:,<span class="number">2</span>:]</span><br><span class="line">y_data = data[<span class="number">1</span>:,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(x_data)</span><br><span class="line"><span class="built_in">print</span>(y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并拟合模型</span></span><br><span class="line">model = linear_model.LassoCV()</span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># lasso系数</span></span><br><span class="line"><span class="built_in">print</span>(model.alpha_)</span><br><span class="line"><span class="comment"># 相关系数</span></span><br><span class="line"><span class="built_in">print</span>(model.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">model.predict(x_data[-<span class="number">2</span>,np.newaxis])</span><br></pre></td></tr></table></figure>
<h1 id="弹性网elastic-net">弹性网（Elastic Net）</h1>
<p>在<span class="math inline">\(q\)</span>取不同值情况下的代价函数 <span class="math display">\[
J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m}{h_\theta(x^{(i)}-y^{(i)})^2+\lambda\sum_{j=1}^{n}{|\theta_j|^q}}]
\]</span> <img src="/imgs/$%7Bfiilename%7D/image-20230605164458909.png"  style="zoom:50%;" /></p>
<p>Elastic Net的代价函数： <span class="math display">\[
J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m}{h_\theta(x^{(i)}-y^{(i)})^2+\lambda\sum_{j=1}^{n}{\alpha\theta_j^2+(1-\alpha)|\theta_j|}}]
\]</span></p>
<h2 id="示例代码-5">示例代码：</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> genfromtxt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据 </span></span><br><span class="line">data = genfromtxt(<span class="string">r&quot;longley.csv&quot;</span>,delimiter=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切分数据</span></span><br><span class="line">x_data = data[<span class="number">1</span>:,<span class="number">2</span>:]</span><br><span class="line">y_data = data[<span class="number">1</span>:,<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(x_data)</span><br><span class="line"><span class="built_in">print</span>(y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并拟合模型</span></span><br><span class="line">model = linear_model.ElasticNetCV()</span><br><span class="line">model.fit(x_data, y_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹性网系数</span></span><br><span class="line"><span class="built_in">print</span>(model.alpha_)</span><br><span class="line"><span class="comment"># 相关系数</span></span><br><span class="line"><span class="built_in">print</span>(model.coef_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">model.predict(x_data[-<span class="number">2</span>,np.newaxis])</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Rt411q7WJ?p=23&amp;vd_source=fe8e916be2bd597efffd8dfd95249141">线性回归及其非线性回归</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>跑通ssd.pytorch</title>
    <url>/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E8%B7%91%E9%80%9Assd-pytorch/</url>
    <content><![CDATA[<p><strong>补：</strong></p>
<h1 id="expected-a-cuda-device-type-for-generator-but-found-cpu">Expected a ‘cuda‘ device type for generator but found ‘cpu‘</h1>
<p>后来我在服务器训练的时候，发现出bug了。原来是<code>Pytorch</code>版本的原因，我在<code>faster-rcnn-pytorch</code>这个项目跑的，里面有现成的VOC数据集。但是这个环境<code>Pytorch</code>是1.9。</p>
<ol type="1">
<li><p>修改<code>/root/miniconda3/lib/python3.7/site-packages/torch/utils/data/sampler.py</code>中代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generator = torch.Generator(device=<span class="string">&#x27;cuda&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">yield</span> <span class="keyword">from</span> torch.randperm(n, generator=generator, device=<span class="string">&#x27;cuda&#x27;</span>).tolist()</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>修改<code>train.py</code>中代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_loader = data.DataLoader(dataset, args.batch_size,</span><br><span class="line">                                  num_workers=args.num_workers,</span><br><span class="line">                                  shuffle=<span class="literal">True</span>, collate_fn=detection_collate,</span><br><span class="line">                                  pin_memory=<span class="literal">True</span>, generator=torch.Generator(device=<span class="string">&#x27;cuda&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="w-pthreadpool-cpp.cc90-warningleaking-caffe2-thread-pool-after-fork.function-pthreadpool">[W pthreadpool-cpp.cc:90] Warning:Leaking Caffe2 thread-pool after fork.(function pthreadpool)</h1>
<p>线程撕裂，出现了警告，警告数量为设置的线程数量，如果把线程数改小一些，就不会有警告了，但是会影响运行速度。修改<code>train.py</code>中的代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_loader = data.DataLoader(dataset, args.batch_size,</span><br><span class="line">                                 num_workers=args.num_workers,</span><br><span class="line">                                 shuffle=<span class="literal">True</span>, collate_fn=detection_collate,</span><br><span class="line">                                 pin_memory=<span class="literal">False</span>,generator=torch.Generator(device=<span class="string">&#x27;cuda&#x27;</span>))</span><br></pre></td></tr></table></figure>
<hr />
<p>然后我想在服务器上用<code>visdom</code>看训练结果图，bug出现了。</p>
<h1 id="nameerror-name-viz-is-not-defined">NameError: name ‘viz’ is not defined</h1>
<p>修改<code>train.py</code>中的代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> visdom</span><br><span class="line"><span class="keyword">global</span> viz</span><br><span class="line">viz = visdom.Visdom()</span><br></pre></td></tr></table></figure>
<h1 id="assertionerror-must-define-a-window-to-update">AssertionError: Must define a window to update</h1>
<p>修改<code>train.py</code>中的代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> args.visdom <span class="keyword">and</span> iteration != <span class="number">0</span> <span class="keyword">and</span> (iteration % epoch_size == <span class="number">0</span>):</span><br><span class="line">    epoch += <span class="number">1</span></span><br><span class="line">    update_vis_plot(epoch, loc_loss, conf_loss, epoch_plot, <span class="literal">None</span>,</span><br></pre></td></tr></table></figure>
<h1 id="legacy-autograd-function-with-non-static-forward-method-is-deprecated">Legacy autograd function with non-static forward method is deprecated</h1>
<p>原因是当前版本要求forward过程是静态的，所以需要将原代码进行修改。</p>
<ol type="1">
<li><p>从<a href="https://github.com/sayakbanerjee1999/Single-Shot-Object-Detection-Updated/blob/master/detection.py"><code>Single-Shot-Object-Detection-Updated</code></a>下载<code>detect.py</code>文件，并将其替换掉原来的<code>layers/functions/detection.py</code></p></li>
<li><p>修改<code>ssd.py</code>中的代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> phase == <span class="string">&#x27;test&#x27;</span>:</span><br><span class="line">        self.softmax = nn.Softmax(dim=-<span class="number">1</span>)</span><br><span class="line">        self.detect = Detect()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> self.phase == <span class="string">&quot;test&quot;</span>:</span><br><span class="line">        output = self.detect.apply(self.num_classes, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0.01</span>, <span class="number">0.45</span>,</span><br><span class="line">                                   loc.view(loc.size(<span class="number">0</span>), -<span class="number">1</span>, <span class="number">4</span>),  <span class="comment"># loc preds</span></span><br><span class="line">                                   self.softmax(conf.view(-<span class="number">1</span>, self.num_classes)),  <span class="comment"># conf preds</span></span><br><span class="line">                                   self.priors.<span class="built_in">type</span>(<span class="built_in">type</span>(x.data))  <span class="comment"># default boxes</span></span><br><span class="line">                                   )</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="errno-2-no-such-file-or-directory-test.txt">[Errno 2] No such file or directory: ‘test.txt’</h1>
<p>修改<code>eval.py</code>中的代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imgsetpath = os.path.join(args.voc_root, <span class="string">&#x27;VOC2007&#x27;</span>, <span class="string">&#x27;ImageSets&#x27;</span>, <span class="string">&#x27;Main&#x27;</span>, <span class="string">&#x27;&#123;&#125;.txt&#x27;</span>)</span><br></pre></td></tr></table></figure>
<hr />
<p>做实验对比，所以需要跑通ssd，这里部署的pytroch版本，大佬项目<a href="https://github.com/amdegroot/ssd.pytorch"><code>ssd.pytorch</code></a>，中间踩了不少坑，记录如下</p>
<p>目标：ssd.pytorch</p>
<p>环境：cuda 11.3 | pytorch 1.8.1</p>
<h1 id="修改xml文件的绝对路径">修改xml文件的绝对路径</h1>
<p>这是在之前的电脑打的标签，所以VOC数据集里面的标注文件.xml里面的<code>&lt;path&gt;</code>值还是老路径，</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230531102209091.png"  style="zoom: 67%;" /></p>
<p>这里我更改成新的路径。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230531102832023.png"  style="zoom: 65%;" /></p>
<h1 id="indexerrorinvalid-index-of-a-0-dim-tensor">IndexError:invalid index of a 0-dim tensor…</h1>
<p>修改<code>train.py</code>中代码，<code>.data[0]</code>写法不适用高版本的Pytorch，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loc_loss += loss_l.item()</span><br><span class="line">conf_loss += loss_c.item()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> iteration % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;timer: %.4f sec.&#x27;</span> % (t1 - t0))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;iter &#x27;</span> + <span class="built_in">repr</span>(iteration) + <span class="string">&#x27; || Loss: %.4f ||&#x27;</span> % (loss.item()), end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="stopinteration">StopInteration…</h1>
<p>修改<code>train.py</code>中代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    images, targets = <span class="built_in">next</span>(batch_iterator)</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    batch_iterator = <span class="built_in">iter</span>(data_loader)</span><br><span class="line">    images, targets = <span class="built_in">next</span>(batch_iterator)</span><br></pre></td></tr></table></figure>
<h1 id="indexerror-the-shape-of-the-mask-14-8732-at-index-0does">IndexError: The shape of the mask [14, 8732] at index 0does…</h1>
<p>交换<code>layers/modules/multibox_loss.py</code>中代码位置，修改结果如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loss_c = loss_c.view(num, -1)</span><br><span class="line">loss_c[pos] = 0  # filter out pos boxes for now</span><br></pre></td></tr></table></figure>
<h1 id="lossnan">loss：NAN</h1>
<p>如果lr设置过高，可能会导致训练过程中loss出现NAN的情况。它默认的参数是1e-3，我这里将学习率修改为1e-4。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--lr&#x27;</span>, <span class="string">&#x27;--learning-rate&#x27;</span>, default=<span class="number">1e-4</span>, <span class="built_in">type</span>=<span class="built_in">float</span>,</span><br></pre></td></tr></table></figure>
<h1 id="警告">警告</h1>
<p><strong>UserWarning: size_average and reduce args will be deprecated, please use reduction=‘sum’ instead. warnings.warn(warning.format(ret))</strong></p>
<p>在高版本的Pytorch中，<code>size_average</code>和<code>reduce</code>这两个参数都将不再支持，修改<code>multibox_loss.py</code>中代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_l = F.smooth_l1_loss(loc_p, loc_t, reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss_c = F.cross_entropy(conf_p, targets_weighted, reduction=<span class="string">&#x27;sum&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>UserWarning: volatile was removed and now has no effect. Use ‘with torch.no_grad():’ instead.</strong></p>
<p>版本问题，修改<code>ssd.py</code>中代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">	self.priors = Variable(self.priorbox.forward())</span><br></pre></td></tr></table></figure>
<p><strong>UserWarning: nn.init.xavier_uniform is now deprecated in favor of nn.init.xavier_uniform_ .init.xavier_uniform(param)</strong></p>
<p><code>nn.init.xavier_uniform</code>是以前的版本使用的，在高版本的Pytorch中已经被弃用。修改<code>train.py</code>中代码，修改结果如下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">xavier</span>(<span class="params">param</span>):</span><br><span class="line">    init.xavier_uniform_(param)</span><br></pre></td></tr></table></figure>
<p>可以发现很多警告就是版本不匹配的问题，但我是抱着只要能运行的心态，然而<code>UserWarning</code>又很影响观感，那就直接屏蔽它！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>或者命令行执行<code>xx.py</code>脚本文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -W ignore xx.py</span><br></pre></td></tr></table></figure>
<h1 id="运行train.py文件">运行train.py文件</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -W ignore train.py</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230531115820400.png" style="zoom: 67%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="amdegroot/ssd.pytorch/issues/421"><code>amdegroot/ssd.pytorch/issues/421</code></a></p>
<p><a href="https://blog.csdn.net/qq_39506912/article/details/116926504?spm=1001.2014.3001.5506"><code>SSD训练自己的数据集（pytorch版）</code></a></p>
<p><a href="https://www.cnblogs.com/shaoxx333/p/16181651.html"><code>Pytorch搭建SSD模型踩坑集锦</code></a></p>
<p><a href="https://www.yii666.com/blog/407628.html"><code>SSD训练数据集流程（学习记录）</code></a></p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ssd.pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>torch1.9-跑通ssd.pytorch</title>
    <url>/uncategorized/torch1-9-%E8%B7%91%E9%80%9Assd-pytorch/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>JupyterLab安装与配置</title>
    <url>/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/JupyterLab%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="https://jupyterlab.readthedocs.io/en/latest/index.html"><code>Jupyter Lab</code></a>是一个交互式笔记本，支持运行40多种编程语言。它本质上是一个web应用程序，可以很方便的创建和共享程序文档，支持实时代码，数学方程，可视化和markdown</p>
<p><code>JupyterLab</code>安装和初始配置记录如下：</p>
<span id="more"></span>
<h1 id="安装jupyterlab">安装<code>JupyterLab</code></h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab</span><br></pre></td></tr></table></figure>
<h1 id="下载中文包">下载中文包</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab-language-pack-zh-CN </span><br></pre></td></tr></table></figure>
<h1 id="启动jupyter-lab服务">启动<code>Jupyter Lab</code>服务</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter lab</span><br></pre></td></tr></table></figure>
<ol start="4" type="1">
<li><p>设置中文界面</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230529143831411.png"  style="zoom: 33%;" /></p></li>
</ol>
<h1 id="修改默认打开的工作目录">修改默认打开的工作目录</h1>
<ol type="1">
<li>先执行以下指令生成 <code>JupyteraLab</code> 的配置文件<code>jupyter_lab_config.py</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter lab --generate-config</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>修改<code>C:\\User\liugn\.jupyter_lab_congfig.py</code>配置文件</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230529145410362.png"  style="zoom:50%;" /></p></li>
</ol>
<p>我这里是把工作文件设置在了<code>E:\Pycharm Projects</code></p>
<h1 id="切换虚拟环境">切换虚拟环境</h1>
<p><code>jupyter lab</code>是安装在base环境下的，很多时候要用到其他虚拟环境的特定包。</p>
<ol type="1">
<li>给已创建好的虚拟环境添加<code>ipykernel</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install -n yolov5 ipykernel</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>激活虚拟环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate yolv5</span><br></pre></td></tr></table></figure></li>
<li><p>将虚拟环境写入<code>Jupyter</code>的<code>kernel</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m ipykernel install --name yolov5 --display-name yolov5</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个虚拟环境名称：创建的虚拟环境名称</li>
<li>第二个虚拟环境名称：其在<code>jupyter noteboook</code>的<code>kernel</code>选项中显示的名称</li>
</ul></li>
</ol>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230529151407677.png"  style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>JupyterLab</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetson Nano部署Yolo-v5</title>
    <url>/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/Jetson-Nano%E9%83%A8%E7%BD%B2Yolo-v5/</url>
    <content><![CDATA[<p>手上有一块国产版的Jetson Nano（懂得都懂），部署Yolo-v5；记录以下</p>
<span id="more"></span>
<h1 id="安装jtop">安装Jtop</h1>
<p>Jetson Nano 没有 <code>nvidia-smi</code> 命令，所以用<code>jtop</code>来替代。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jetson-stats</span><br></pre></td></tr></table></figure>
<p>执行命令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jtop</span><br></pre></td></tr></table></figure>
<h1 id="安装jupyterlab">安装JupyterLab</h1>
<ol type="1">
<li><p>先安装以下nodejs，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure></li>
<li><p>安装jupyterlab，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install jupyterlab</span><br></pre></td></tr></table></figure></li>
<li><p>设置密码，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jupyter-lab password</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置文件，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许远程连接</span></span><br><span class="line">c.ServerApp.allow_remote_access = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 允许远程连接者使用root权限</span></span><br><span class="line">c.ServerApp.allow_root = <span class="literal">True</span></span><br><span class="line"><span class="comment"># 服务器监听所有本机IP</span></span><br><span class="line">c.ServerApp.ip = <span class="string">&#x27;0.0.0.0&#x27;</span></span><br><span class="line"><span class="comment"># 启动server不打开浏览器</span></span><br><span class="line">c.ServerApp.open_browser = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 设置通信端口</span></span><br><span class="line">c.ServerApp.port = <span class="number">8080</span></span><br><span class="line"><span class="comment"># c.ServerApp.password 没必要设置，因为上面设置密码步骤时已经生成了密码文件</span></span><br><span class="line"><span class="comment"># c.ServerApp.root_dir 没必要设置jupyter运行所在的文件夹</span></span><br></pre></td></tr></table></figure></li>
<li><p>远程开启<code>JupyterLab</code>，首次登录需要密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nano局域网IP 192.168.55.0</span><br><span class="line">192.168.55.0:8080/lab</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="jupyterlab开机自启">JupyterLab开机自启</h1>
<ol type="1">
<li><p>创建<code>JupyterLab</code>运行脚本<code>autoJupyterLab.sh</code>，我这里把该脚本文件放在/home/nvidia里面了。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">/home/nVidia/.local/bin/jupyter-lab</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>/etc/systemd/system</code>文件夹下创建<code>auto-jupyter.service</code>服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Auto Load JupyterLab</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=your_username</span><br><span class="line">ExecStart=/home/nvidia/autoJupyterLab.sh</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=15s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=default.target</span><br></pre></td></tr></table></figure></li>
<li><p>设置Jupyter Service自启动</p>
<ul>
<li><p>让systemd重新加载service文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br></pre></td></tr></table></figure></li>
<li><p>然后设置auto-jupyter.service开机自启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable auto-jupyter.service</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="关闭图形界面">关闭图形界面</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h1 id="开启图形界面">开启图形界面</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo reboot</span><br></pre></td></tr></table></figure>
<h1 id="命令行连接wifi">命令行连接WiFi</h1>
<ol type="1">
<li>扫描WiFi信号</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli dev wifi</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>连接WiFi</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nmcli dev wifi connect wifi_name password ********</span><br></pre></td></tr></table></figure>
<ol start="3" type="1">
<li>查看连接WiFi后的IP地址</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Jetson Nano</tag>
        <tag>Yolo-v5</tag>
      </tags>
  </entry>
  <entry>
    <title>wii11系统跑通Yolo-v5</title>
    <url>/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/%E8%B7%91%E9%80%9AYolo-v5/</url>
    <content><![CDATA[<p>之前跑Yolo-v5是在服务器跑的，现在把权重文件跑完了，正好最近换了新电脑，在本地部署跑跑看，记录如下：</p>
<p>复现<img src="/imgs/$%7Bfiilename%7D/b3809ce4a80e96cf09f6d500abed0fbd_129107_720_720.jpg"  style="zoom:5%;" />大佬们的项目之前一定要看这个项目所需的配置环境，掉大坑！！！</p>
<p>目标：Yolo-v5 v6.1版本</p>
<p>环境：cuda 11.3 | pytorch 1.8.1</p>
<span id="more"></span>
<h1 id="安装anaconda3">安装Anaconda3</h1>
<p><a href="https://www.anaconda.com/"><code>anaconda官网</code></a></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527104222716.png" alt="image-20230527104222716" style="zoom:33%;" /></p>
<p>直接点击<code>Download</code>下载安装包，双击安装</p>
<p>我把<code>Anaconda</code>安装在D盘了</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527105216332.png"  style="zoom: 67%;" /></p>
<h1 id="安装cuda">安装CUDA</h1>
<p>安装之前先看下自己电脑配置条件，在终端输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527105741395.png"  style="zoom: 50%;" /></p>
<p>可以看到<code>Driver Version: 512.98</code></p>
<p>在对照<a href="https://docs.nvidia.com/cuda/cuda-toolkit-release-notes/index.html"><code>nvidia官网显卡驱动</code></a>给出的版本要求选择CUDA版本，这里我选择的是<code>CUDA 11.3</code></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527110416589.png"  style="zoom: 33%;" /></p>
<p>然后来到<a href="https://developer.nvidia.com/cuda-toolkit-archive"><code>CUDA Toolkit Archive</code></a>，</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527111819649.png"  style="zoom:50%;" /></p>
<p>点击<code>CUDA Toolkit 11.3.1</code>即可跳转到<a href="https://developer.nvidia.com/cuda-11-3-1-download-archive?target_os=Windows&amp;target_arch=x86_64&amp;target_version=10&amp;target_type=exe_local"><code>CUDA Toolkit 11.3 Update 1 Downloads</code></a></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527112055726.png"  style="zoom: 33%;" /></p>
<p>直接点击<code>Download(2.7GB)</code>下载安装包，双击安装</p>
<p>这里选择<code>自定义(c)(高级)</code></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527113136663.png"  style="zoom:50%;" /></p>
<p>选择驱动程序组件时，视情况而定；我这里取消勾选<code>Driver components</code>和<code>Other components</code>，因为当前版本已经安装了。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527113247098.png"  style="zoom:50%;" /></p>
<p>点击<code>下一步</code>，等待安装完成。</p>
<h1 id="配置cudnn">配置cuDNN</h1>
<p>进入Nvidia官网<a href="https://developer.nvidia.com/rdp/cudnn-archive"><code>cuDNN Archive</code></a>，选择<code>for CUDA 11.X</code>的。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527114836975.png" style="zoom:33%;" /></p>
<p>我这里选择的是<code>v8.8.0</code>版本的，点击<code>Local Install for Windows(Zip)</code>下载</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527114635962.png"  style="zoom: 33%;" /></p>
<p>解压后里面有三个文件<span class="math inline">\(bin|include|lib\)</span></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527123944344.png"  style="zoom: 43%;" /></p>
<p>将其复制到CUDA安装目录就好了，我这里把CUDA安装在D盘了。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527124408026.png"  style="zoom:33%;" /></p>
<h1 id="安装pytorch">安装pytorch</h1>
<p>打开<code>Anaconda Prompt</code>，输入如下命令，创建一个虚拟环境，我这里命名为yolov5；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda create -n yolov5 python=3.8</span><br></pre></td></tr></table></figure>
<p>所用到的各种包都是在yolov5这个虚拟环境下配置的，所以需要激活yolov5环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda activate yolov5</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527131627319.png"  style="zoom:50%;" /></p>
<p>进入Pytorch官网<a href="https://pytorch.org/get-started/previous-versions/#installing-previous-versions-of-pytorch"><code>Installing Previous Versions Of Pytorch</code></a></p>
<p><strong>conda install 安装</strong></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527130150777.png"  style="zoom: 50%;" /></p>
<p>我这里是安装的CUDA 11.3，输入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda install pytorch==1.8.1 torchvision==0.9.1 torchaudio==0.8.1 cudatoolkit=11.3 -c pytorch -c conda-forge</span><br></pre></td></tr></table></figure>
<p><code>-c pytorch</code> 表示在pytorch的官网下载；<code>-c conda-forge</code> 表示在conda官网下载</p>
<p>但是pytorch官网只有cpu版本的，conda索性找不到了。好在CUDA是向下兼容的，最后选择用pip install的方式下载了。</p>
<p><strong>pip install 安装</strong></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527130231273.png"  style="zoom: 50%;" /></p>
<p>最后选择的CUDA 11.1，输入以下指令；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install torch==1.8.1+cu111 torchvision==0.9.1+cu111 torchaudio==0.8.1 -f https://download.pytorch.org/whl/torch_stable.html</span><br></pre></td></tr></table></figure>
<p>到这里pytorch环境就配置好了！</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527133453540.png"  style="zoom: 67%;" /></p>
<h1 id="下载yolo-v5源代码">下载Yolo-v5源代码</h1>
<p>Yolo-v5更新的很快，但我当时用服务器跑的时候下载的v6.1版本，所以用git bash下载文件。</p>
<p>我是在<code>Pycharm Projects</code>里面创建一个文件夹<code>Yolov5</code>，然后右击选择<code>Git Bash Here</code></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527134730082.png"  style="zoom: 50%;" /></p>
<p> ifconfigbash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b v6.1 https://github.com/ultralytics/yolov5.git</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527134152555.png"  style="zoom:50%;" /></p>
<p>这样就把源代码下载完成了，我这里把它重命名了<code>yolov5-6.1</code>，</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527135851656.png"  style="zoom: 40%;" /></p>
<p>接下来从requirements.txt安装所需要的包。打开<code>Anaconda Prompt</code>，cd到yolov5-6.1文件夹</p>
<p>我这里是<code>E:\Pycharm Projects\Yolov5\yolov5-6.1</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527140112538.png" alt="image-20230527140112538" style="zoom:50%;" /></p>
<p>到这里就全部部署完成好了，接下来就是把自己的权重文件替换成yolov5的预训练权重文件yolov5.pt。</p>
<p>执行detect.py，测试了一下。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-1317.jpg"  style="zoom: 45%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-1685.jpg"  style="zoom:45%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230527141712871.png"  style="zoom:40%;" /></p>
<p>还是能较好的把可采摘的苹果和被遮挡的苹果识别出来。</p>
]]></content>
      <categories>
        <category>目标检测</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Yolov5</tag>
      </tags>
  </entry>
  <entry>
    <title>git clone连接不上</title>
    <url>/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/git-clone%E8%BF%9E%E6%8E%A5%E4%B8%8D%E4%B8%8A/</url>
    <content><![CDATA[<p>当我用git clone下载代码时，发现老是连接不上,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fatal: unable to access <span class="string">&#x27;https://github.com/.../.git&#x27;</span>: Could not resolve host: github.com</span><br></pre></td></tr></table></figure>
<p>解决办法：</p>
<p>对Git的配置文件<code>.gitconfig</code>设置代理服务器，我的端口是7890</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:192.0.0.1:7890</span><br><span class="line">git config --global https.proxy http:192.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>取消代理在终端输入以下代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy </span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>
<p>顺便说一嘴，<code>./gitconfig</code>配置文件在<code>C:\Users\Liugn</code>文件夹里面。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230526194347960.png"  style="zoom: 67%;" /></p>
<p>发现自己对英文界面的git bash用的不习惯，所以单机右键，点击<code>Options</code></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230526193925599.png"  style="zoom:50%;" /></p>
<p>点击<code>Window</code>，它会切换到对应的界面，点击<code>UI language</code>下拉框选择<code>zh_CN</code></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230526194125757.png"  style="zoom:50%;" /></p>
<p>最后点击<code>Apply</code>就好了。</p>
<p>外观什么的都可以在<code>选项/options</code>中设置，这按个人喜好去配了。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230526195047033.png"  style="zoom:67%;" /></p>
<p>参考</p>
<p><a href="https://github.com/orgs/community/discussions/49456"><code>Recv failure: Connection was reset</code></a></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda--配置文件修改</title>
    <url>/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/Anaconda-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>将envs_dirs设置为自己anaconda安装的目录上（我的是在D:），不然他默认安装到.！！！</p>
<p>因为我的anaconda安装在D盘，如果各位看官有充足的内存够安装在C盘，就当笑笑看啦~</p>
<span id="more"></span>
<h1 id="首先第一步">首先第一步！</h1>
<p>修改 D：Anaconda3文件夹的权限，选中后右击选择属性，然后点击安全，选择<code>User</code>后点击编辑，将下面的权限全打勾，</p>
<p>稍微等待一会时间。</p>
<h1 id="二选一">二选一</h1>
<h2 id="修改.condarc推荐手残党">修改./condarc（推荐，手残党）</h2>
<ol type="1">
<li>直接将.，将下面的内容粘入，</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">envs_dirs:</span><br><span class="line">  - D:\Anaconda3\envs</span><br><span class="line">pkgs_dirs:</span><br><span class="line">  - D:\Anaconda3\pkgs</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li><p>保存并关闭文件。</p></li>
<li><p>打开一个终端，执行指令可查看conda配置信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="修改指令">修改指令</h2>
<ol type="1">
<li><p>打开一个终端，执行添加指令，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --add envs_dirs D:\Anaconda3\envs</span><br><span class="line">conda config --add pkgs_dir  D:\Anaconda3\pkgs</span><br></pre></td></tr></table></figure></li>
<li><p>同样的，执行指令查看配置信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">conda config --show</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>机器人工具箱学习</title>
    <url>/uncategorized/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>人脸识别案例</title>
    <url>/OpenCV/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="基础">基础</h1>
<p>使用机器学习的方法完成人脸检测，首先需要大量的正样本图像（面部图像）和负样本图像（不含面部的图像）来训练分类器。我们需要从其中提取特征。下图中的 Haar 特征会被使用，就像我们的卷积核，每一个特征是一个值，这个值等于黑色矩形中的像素值之后减去白色矩形中的像素值之和。</p>
<span id="more"></span>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191014152218924-1684563500129-1.png"  style="zoom:67%;" /></p>
<p>Haar特征值反映了图像的灰度变化情况。例如：脸部的一些特征能由矩形特征简单的描述，眼睛要比脸颊颜色要深，鼻梁两侧比鼻梁颜色要深，嘴巴比周围颜色要深等。</p>
<p>Haar特征可用于于图像任意位置，大小也可以任意改变，所以矩形特征值是矩形模版类别、矩形位置和矩形大小这三个因素的函数。故类别、大小和位置的变化，使得很小的检测窗口含有非常多的矩形特征。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191014152716626-1684563652425-11.png"  style="zoom: 50%;" /></p>
<p>得到图像的特征后，训练一个决策树构建的adaboost级联决策器来识别是否为人脸。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191014160504382-1684563672078-13.png"  style="zoom:50%;" /></p>
<p>OpenCV中自带已训练好的检测器，包括面部，眼睛，猫脸等，都保存在XML文件中，利用这些文件来识别人脸，眼睛等。</p>
<ol type="1">
<li><p>读取图片，并转换成灰度图</p></li>
<li><p>实例化人脸和眼睛检测的分类器对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实例化级联分类器</span></span><br><span class="line">classifier =cv.CascadeClassifier( <span class="string">&quot;haarcascade_frontalface_default.xml&quot;</span> ) </span><br><span class="line"><span class="comment"># 加载分类器</span></span><br><span class="line">classifier.load(<span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>进行人脸和眼睛的检测</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rect = classifier.detectMultiScale(gray, scaleFactor, minNeighbors, minSize,maxsize)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>Gray: 要进行检测的人脸图像</li>
<li>scaleFactor: 前后两次扫描中，搜索窗口的比例系数</li>
<li>minneighbors：目标至少被检测到minNeighbors次才会被认为是目标</li>
<li>minsize和maxsize: 目标的最小尺寸和最大尺寸</li>
</ul></li>
<li><p>将检测结果绘制出来就可以了。</p></li>
</ol>
<h3 id="示例代码">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1.以灰度图的形式读取图片</span></span><br><span class="line">img = cv.imread(<span class="string">&quot;16.jpg&quot;</span>)</span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.实例化OpenCV人脸和眼睛识别的分类器 </span></span><br><span class="line">face_cas = cv.CascadeClassifier( <span class="string">&quot;haarcascade_frontalface_default.xml&quot;</span> ) </span><br><span class="line">face_cas.load(<span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line"></span><br><span class="line">eyes_cas = cv.CascadeClassifier(<span class="string">&quot;haarcascade_eye.xml&quot;</span>)</span><br><span class="line">eyes_cas.load(<span class="string">&quot;haarcascade_eye.xml&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.调用识别人脸 </span></span><br><span class="line">faceRects = face_cas.detectMultiScale( gray, scaleFactor=<span class="number">1.2</span>, minNeighbors=<span class="number">3</span>, minSize=(<span class="number">32</span>, <span class="number">32</span>)) </span><br><span class="line"><span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects: </span><br><span class="line">    x, y, w, h = faceRect </span><br><span class="line">    <span class="comment"># 框出人脸 </span></span><br><span class="line">    cv.rectangle(img, (x, y), (x + h, y + w),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>) </span><br><span class="line">    <span class="comment"># 4.在识别出的人脸中进行眼睛的检测</span></span><br><span class="line">    roi_color = img[y:y+h, x:x+w]</span><br><span class="line">    roi_gray = gray[y:y+h, x:x+w]</span><br><span class="line">    eyes = eyes_cas.detectMultiScale(roi_gray) </span><br><span class="line">    <span class="keyword">for</span> (ex,ey,ew,eh) <span class="keyword">in</span> eyes:</span><br><span class="line">        cv.rectangle(roi_color,(ex,ey),(ex+ew,ey+eh),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 5. 检测结果的绘制</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;检测结果&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/yangzi2.jpeg"  style="zoom:67%;" /></p>
<p>在视频中对人脸进行检测：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1.读取视频</span></span><br><span class="line">cap = cv.VideoCapture(<span class="string">&quot;movie.mp4&quot;</span>)</span><br><span class="line"><span class="comment"># 2.在每一帧数据中进行人脸识别</span></span><br><span class="line"><span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret==<span class="literal">True</span>:</span><br><span class="line">        gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># 3.实例化OpenCV人脸识别的分类器 </span></span><br><span class="line">        face_cas = cv.CascadeClassifier( <span class="string">&quot;haarcascade_frontalface_default.xml&quot;</span> ) </span><br><span class="line">        face_cas.load(<span class="string">&#x27;haarcascade_frontalface_default.xml&#x27;</span>)</span><br><span class="line">        <span class="comment"># 4.调用识别人脸 </span></span><br><span class="line">        faceRects = face_cas.detectMultiScale(gray, scaleFactor=<span class="number">1.2</span>, minNeighbors=<span class="number">3</span>, minSize=(<span class="number">32</span>, <span class="number">32</span>)) </span><br><span class="line">        <span class="keyword">for</span> faceRect <span class="keyword">in</span> faceRects: </span><br><span class="line">            x, y, w, h = faceRect </span><br><span class="line">            <span class="comment"># 框出人脸 </span></span><br><span class="line">            cv.rectangle(frame, (x, y), (x + h, y + w),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span>) </span><br><span class="line">        cv.imshow(<span class="string">&quot;frame&quot;</span>,frame)</span><br><span class="line">        <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 5. 释放资源</span></span><br><span class="line">cap.release()  </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>视频追踪</title>
    <url>/OpenCV/%E8%A7%86%E9%A2%91%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<h1 id="视频读写">视频读写</h1>
<h2 id="读取视频">读取视频</h2>
<p><strong>创建读取视频的对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cap = cv.VideoCapture(filepath)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>filepath：视频文件路径</p>
<span id="more"></span></li>
</ul>
<p><strong>获取视频的某些属性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">retval = cap.get(propId)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>propId: 从0到18的数字，每个数字表示视频的属性</p>
<p>常用属性有：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191016164053661-1684560896151-1.png"  style="zoom: 33%;" /></p></li>
</ul>
<p><strong>修改视频的属性信息</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cap.<span class="built_in">set</span>(propId，value)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>proid：属性的索引，与上面的表格相对应</li>
<li>value：修改后的属性值</li>
</ul>
<p><strong>判断图像是否读取成功</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isornot = cap.isOpened()</span><br></pre></td></tr></table></figure>
<ul>
<li>若读取成功则返回true，否则返回False</li>
</ul>
<p><strong>获取视频的一帧图像</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret, frame = cap.read()</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>ret：若获取成功返回True，获取失败，返回False</li>
<li>frame：获取到的某一帧的图像</li>
</ul>
<p><strong>将视频释放掉</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cap.realease()</span><br></pre></td></tr></table></figure>
<h3 id="示例代码">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 1.获取视频对象</span></span><br><span class="line">cap = cv.VideoCapture(<span class="string">&#x27;DOG.wmv&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.判断是否读取成功</span></span><br><span class="line"><span class="keyword">while</span>(cap.isOpened()):</span><br><span class="line">    <span class="comment"># 3.获取每一帧图像</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="comment"># 4. 获取成功显示图像</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    <span class="comment"># 5.每一帧间隔为25ms</span></span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">25</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 6.释放视频对象</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destoryAllwindows()</span><br></pre></td></tr></table></figure>
<h1 id="保存视频">保存视频</h1>
<p><strong>创建视频写入的对象</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out = cv2.VideoWriter(filename,fourcc, fps, frameSize)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>filename：视频保存的位置</li>
<li>fourcc：指定视频编解码器的4字节代码</li>
<li>fps：帧率</li>
<li>frameSize：帧大小</li>
</ul>
<p><strong>设置视频的编解码器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">retval = cv2.VideoWriter_fourcc( c1, c2, c3, c4 )</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>c1,c2,c3,c4：是视频编解码器的4字节代码，常用的有：</p>
<ul>
<li><p>在Windows中：DIVX（.avi）</p></li>
<li><p>在OS中：MJPG（.mp4），DIVX（.avi），X264（.mkv）。</p></li>
</ul></li>
</ul>
<p><strong>获取视频的一帧图像</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret, frame = cap.read()</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>ret：若获取成功返回True，获取失败，返回False</li>
<li>frame：获取到的某一帧的图像</li>
</ul>
<p><strong>某一帧图像写入视频</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">out.write()</span><br></pre></td></tr></table></figure>
<p><strong>释放资源</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cap.release()</span><br><span class="line">out.release()</span><br></pre></td></tr></table></figure>
<h3 id="示例代码-1">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 读取视频</span></span><br><span class="line">cap = cv.VideoCapture(<span class="string">&quot;DOG.wmv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 获取图像的属性（宽和高，）,并将其转换为整数</span></span><br><span class="line">frame_width = <span class="built_in">int</span>(cap.get(<span class="number">3</span>))</span><br><span class="line">frame_height = <span class="built_in">int</span>(cap.get(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建保存视频的对象，设置编码格式，帧率，图像的宽高等</span></span><br><span class="line">out = cv.VideoWriter(<span class="string">&#x27;outpy.avi&#x27;</span>,cv.VideoWriter_fourcc(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;J&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;G&#x27;</span>), <span class="number">10</span>, (frame_width,frame_height))</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 4.获取视频中的每一帧图像</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>: </span><br><span class="line">        <span class="comment"># 5.将每一帧图像写入到输出文件中</span></span><br><span class="line">        out.write(frame)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.释放资源</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="视频追踪">视频追踪</h1>
<h2 id="meanshift算法"><code>meanshift算法</code></h2>
<p>假设有一堆点集，还有一个小的窗口，这个窗口可能是圆形的，现在你可能要移动这个窗口到点集密度最大的区域当中。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image1-0784863-1684561795932-3.jpg" style="zoom:67%;" /></p>
<p>最开始的窗口是蓝色圆环的区域，命名为<span class="math inline">\(C1\)</span>。蓝色圆环的圆心用一个蓝色的矩形标注，命名为<span class="math inline">\(C1_o\)</span>。而窗口中所有点的点集构成的质心在蓝色圆形点<span class="math inline">\(C1_r\)</span>处，显然圆环的形心和质心并不重合。所以，移动蓝色的窗口，使得形心与之前得到的质心重合。在新移动后的圆环的区域当中再次寻找圆环当中所包围点集的质心，然后再次移动，通常情况下，形心和质心是不重合的。不断执行上面的移动过程，直到形心和质心大致重合结束。 这样，最后圆形的窗口会落到像素分布最大的地方，也就是图中的绿色圈，命名为<span class="math inline">\(C2\)</span>。</p>
<ol type="1">
<li><p>首先在图像上选定一个目标区域</p></li>
<li><p>计算选定区域的直方图分布，一般是<code>HSV</code>色彩空间的直方图。</p></li>
<li><p>对下一帧图像<span class="math inline">\(b\)</span>同样计算直方图分布。</p></li>
<li><p>计算图像<span class="math inline">\(b\)</span>当中与选定区域直方图分布最为相似的区域，使用<code>meanshift算法</code>将选定区域沿着最为相似的部分进行移动，直到找到最相似的区域，便完成了在图像<span class="math inline">\(b\)</span>中的目标追踪。</p></li>
<li><p>重复3、4的过程，就完成整个视频目标追踪。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image2-0785334-1684562460307-7.gif"  style="zoom: 80%;" /></p></li>
</ol>
<p>通常情况下使用<strong>直方图反向投影</strong>得到的图像和第一帧目标对象的起始位置，目标对象的移动会反映到直方图反向投影图中，<code>meanshift 算法</code>把窗口移动到反向投影图像中灰度密度最大的区域。</p>
<p>直方图反向投影的流程是：</p>
<ol type="1">
<li>假设我们有一张<span class="math inline">\(100\times100\)</span>的输入图像，有一张<span class="math inline">\(10\times10\)</span>的模板图像，</li>
<li>从输入图像的左上角<span class="math inline">\((0,0)\)</span>开始，切割一块<span class="math inline">\((0,0)\)</span>至<span class="math inline">\((10,10)\)</span>的临时图像，</li>
<li>生成临时图像的直方图，</li>
<li>用临时图像的直方图和模板图像的直方图对比，对比结果记为<span class="math inline">\(c\)</span>，</li>
<li>直方图对比结果<span class="math inline">\(c\)</span>，就是结果图像<span class="math inline">\((0,0)\)</span>处的像素值，</li>
<li>切割输入图像从<span class="math inline">\((0,1)\)</span>至<span class="math inline">\((10,11)\)</span>的临时图像，对比直方图，并记录到结果图像，</li>
<li>重复1～5步直到输入图像的右下角，就形成了直方图的反向投影。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.meanShift(probImage, window, criteria)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>probImage: ROI区域，即目标的直方图的反向投影</li>
<li>window： 初始搜索窗口，就是定义ROI的rect</li>
<li>criteria: 确定窗口搜索停止的准则，主要有迭代次数达到设置的最大值，窗口中心的漂移值大于某个设定的限值等。</li>
</ul>
<h3 id="示例代码-2">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 1.获取图像</span></span><br><span class="line">cap = cv.VideoCapture(<span class="string">&#x27;DOG.wmv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取第一帧图像，并指定目标位置</span></span><br><span class="line">ret,frame = cap.read()</span><br><span class="line"><span class="comment"># 2.1 目标位置（行，高，列，宽）</span></span><br><span class="line">r,h,c,w = <span class="number">197</span>,<span class="number">141</span>,<span class="number">0</span>,<span class="number">208</span>  </span><br><span class="line">track_window = (c,r,w,h)</span><br><span class="line"><span class="comment"># 2.2 指定目标的感兴趣区域</span></span><br><span class="line">roi = frame[r:r+h, c:c+w]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 计算直方图</span></span><br><span class="line"><span class="comment"># 3.1 转换色彩空间（HSV）</span></span><br><span class="line">hsv_roi =  cv.cvtColor(roi, cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># 3.2 去除低亮度的值</span></span><br><span class="line"><span class="comment"># mask = cv.inRange(hsv_roi, np.array((0., 60.,32.)), np.array((180.,255.,255.)))</span></span><br><span class="line"><span class="comment"># 3.3 计算直方图</span></span><br><span class="line">roi_hist = cv.calcHist([hsv_roi],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">180</span>],[<span class="number">0</span>,<span class="number">180</span>])</span><br><span class="line"><span class="comment"># 3.4 归一化</span></span><br><span class="line">cv.normalize(roi_hist,roi_hist,<span class="number">0</span>,<span class="number">255</span>,cv.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 目标追踪</span></span><br><span class="line"><span class="comment"># 4.1 设置窗口搜索终止条件：最大迭代次数，窗口中心漂移最小值</span></span><br><span class="line">term_crit = ( cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, <span class="number">10</span>, <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 4.2 获取每一帧图像</span></span><br><span class="line">    ret ,frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4.3 计算直方图的反向投影</span></span><br><span class="line">        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">        dst = cv.calcBackProject([hsv],[<span class="number">0</span>],roi_hist,[<span class="number">0</span>,<span class="number">180</span>],<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4.4 进行meanshift追踪</span></span><br><span class="line">        ret, track_window = cv.meanShift(dst, track_window, term_crit)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4.5 将追踪的位置绘制在视频上，并进行显示</span></span><br><span class="line">        x,y,w,h = track_window</span><br><span class="line">        img2 = cv.rectangle(frame, (x,y), (x+w,y+h), <span class="number">255</span>,<span class="number">2</span>)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;frame&#x27;</span>,img2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cv.waitKey(<span class="number">60</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span>        </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 5. 资源释放        </span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191011180244485-1684561868819-5.png"  style="zoom: 50%;" /></p>
<h1 id="camshift算法">Camshift算法</h1>
<p>检测的窗口的大小是固定的，而狗狗由近及远是一个逐渐变小的过程，固定的窗口是不合适的。所以需要根据目标的大小和角度来对窗口的大小和角度进行修正。</p>
<p>连续自适应<code>MeanShift</code>(Continuously Adaptive Mean-Shift，<a href="https://baike.baidu.com/item/Camshift/5302311">Camshift</a>)算法是对<code>MeanShift算法</code>的改进算法，可随着跟踪目标的大小变化实时调整搜索窗口的大小，具有较好的跟踪效果。</p>
<p>首先应用<code>meanshift</code>，一旦<code>meanshift</code>收敛，它就会更新窗口的大小，还计算最佳拟合椭圆的方向，从而根据目标的位置和大小更新搜索窗口。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image4-1684563103560-9.gif"  style="zoom: 80%;" /></p>
<h3 id="示例代码-3">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 1.获取图像</span></span><br><span class="line">cap = cv.VideoCapture(<span class="string">&#x27;DOG.wmv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.获取第一帧图像，并指定目标位置</span></span><br><span class="line">ret,frame = cap.read()</span><br><span class="line"><span class="comment"># 2.1 目标位置（行，高，列，宽）</span></span><br><span class="line">r,h,c,w = <span class="number">197</span>,<span class="number">141</span>,<span class="number">0</span>,<span class="number">208</span>  </span><br><span class="line">track_window = (c,r,w,h)</span><br><span class="line"><span class="comment"># 2.2 指定目标的感兴趣区域</span></span><br><span class="line">roi = frame[r:r+h, c:c+w]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 计算直方图</span></span><br><span class="line"><span class="comment"># 3.1 转换色彩空间（HSV）</span></span><br><span class="line">hsv_roi =  cv.cvtColor(roi, cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># 3.2 去除低亮度的值</span></span><br><span class="line"><span class="comment"># mask = cv.inRange(hsv_roi, np.array((0., 60.,32.)), np.array((180.,255.,255.)))</span></span><br><span class="line"><span class="comment"># 3.3 计算直方图</span></span><br><span class="line">roi_hist = cv.calcHist([hsv_roi],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">180</span>],[<span class="number">0</span>,<span class="number">180</span>])</span><br><span class="line"><span class="comment"># 3.4 归一化</span></span><br><span class="line">cv.normalize(roi_hist,roi_hist,<span class="number">0</span>,<span class="number">255</span>,cv.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 目标追踪</span></span><br><span class="line"><span class="comment"># 4.1 设置窗口搜索终止条件：最大迭代次数，窗口中心漂移最小值</span></span><br><span class="line">term_crit = ( cv.TERM_CRITERIA_EPS | cv.TERM_CRITERIA_COUNT, <span class="number">10</span>, <span class="number">1</span> )</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">    <span class="comment"># 4.2 获取每一帧图像</span></span><br><span class="line">    ret ,frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4.3 计算直方图的反向投影</span></span><br><span class="line">        hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line">        dst = cv.calcBackProject([hsv],[<span class="number">0</span>],roi_hist,[<span class="number">0</span>,<span class="number">180</span>],<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4.4 进行camshift追踪</span></span><br><span class="line">   	 	ret, track_window = cv.CamShift(dst, track_window, term_crit)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制追踪结果</span></span><br><span class="line">        pts = cv.boxPoints(ret)</span><br><span class="line">        pts = np.int0(pts)</span><br><span class="line">        img2 = cv.polylines(frame,[pts],<span class="literal">True</span>, <span class="number">255</span>,<span class="number">2</span>)</span><br><span class="line">        cv.imshow(<span class="string">&#x27;frame&#x27;</span>,img2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> cv.waitKey(<span class="number">60</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span>        </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 5. 资源释放        </span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1 id="总结">总结</h1>
<p><code>Meanshift</code>和<code>camshift</code>算法都各有优势，自然也有劣势：</p>
<ul>
<li><code>Meanshift算法</code>：简单，迭代次数少，但无法解决目标的遮挡问题并且不能适应运动目标的的形状和大小变化。</li>
<li><code>camshift算法</code>：可适应运动目标的大小形状的改变，具有较好的跟踪效果，但当背景色和目标颜色接近时，容易使目标的区域变大，最终有可能导致目标跟踪丢失。</li>
</ul>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>图像特征提取与描述</title>
    <url>/OpenCV/%E5%9B%BE%E5%83%8F%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E4%B8%8E%E6%8F%8F%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="角点特征">角点特征</h1>
<p>如下图所示，蓝色框中的区域是一个平面，无论向哪个方向移动蓝色框，都是一样的。对于黑色框中的区域，它是一个边缘。如果沿垂直方向移动，它会改变。但是如果沿水平方向移动就不会改变。而红色框中的角点，无论你向那个方向移动，得到的结果都不同，这说明它是唯一的。 所以说，角点是一个好的图像特征。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008141945745-1684510965118-1.png"  style="zoom: 80%;" /></p>
<span id="more"></span>
<h1 id="harris和shi-tomas算法">Harris和Shi-Tomas算法</h1>
<h2 id="harris角点检测">Harris角点检测</h2>
<p>Harris角点检测的思想是通过图像的局部的小窗口观察图像，角点的特征是窗口沿任意方向移动都会导致图像灰度的明显变化，如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008144647540-1684511183358-3.png"  style="zoom: 33%;" /></p>
<p>将局部窗口向各个方向移动<span class="math inline">\((u,v)\)</span>，并计算所有灰度差异的总和，表达式如下： <span class="math display">\[
E(u,v)=\sum_{x,y}w(x,y)[I(x+u,y+v)-I(x,y)]^2
\]</span> 其中<span class="math inline">\(E(u,v)\)</span>是局部窗口的图像灰度，<span class="math inline">\(I(x+u,y+v)\)</span>是平移后的图像灰度，<span class="math inline">\(w(x,y)\)</span>是窗口函数，该可以是矩形窗口，也可以是对每一个像素赋予不同权重的高斯窗口，如下所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008153014984-1684511417820-5.png"  style="zoom: 50%;" /></p>
<p>角点检测中使<span class="math inline">\(E(u,v)\)</span>的值最大。利用一阶泰勒展开有： <span class="math display">\[
I(x+u,y+v)=I(x,y)+I_xu+I_yv
\]</span> 其中<span class="math inline">\(I_x\)</span>和<span class="math inline">\(I_y\)</span>是沿<span class="math inline">\(x\)</span>和<span class="math inline">\(y\)</span>方向的导数，可用<code>sobel算子</code>计算 <span class="math display">\[
E(u,v)=\sum_{x,y}w(x,y)[I(x+u,y+v)-I(x,y)]^2
\]</span> <span class="math display">\[
=\sum_{x,y}w(x,y)[I(x,y)+I_xu+I_yv-I(x,y)]^2
\]</span></p>
<p><span class="math display">\[
=\sum_{x,y}w(x,y)[I_x^2u^2+2I_xI_yuv+I_y^2v^2]
\]</span></p>
<p><span class="math display">\[
=\sum_{x,y}w(x,y)\left[\begin{matrix}u&amp;v\end{matrix}\right]
\left[\begin{matrix}I_x^2&amp;I_xI_y\\I_xI_y&amp;I_y^2\end{matrix}\right]
\left[\begin{matrix}u\\v\end{matrix}\right]
\]</span></p>
<p><span class="math display">\[
=\left[\begin{matrix}u&amp;v\end{matrix}\right]\underbrace{\sum_{x,y}w(x,y)
\left[\begin{matrix}I_x^2&amp;I_xI_y\\I_xI_y&amp;I_y^2\end{matrix}\right]}_M
\left[\begin{matrix}u\\v\end{matrix}\right]=\left[\begin{matrix}u&amp;v\end{matrix}\right]M
\left[\begin{matrix}u\\v\end{matrix}\right]
\]</span></p>
<p><span class="math inline">\(M\)</span>矩阵决定了<span class="math inline">\(E(u,v)\)</span>的取值，下面我们利用<span class="math inline">\(M\)</span>来求角点，<span class="math inline">\(M\)</span>是<span class="math inline">\(I_x\)</span>和<span class="math inline">\(I_y\)</span>的二次项函数，可以表示成椭圆的形状，椭圆的长短半轴由<span class="math inline">\(M\)</span>的特征值<span class="math inline">\(\lambda_1\)</span>和<span class="math inline">\(\lambda_2\)</span>决定，方向由特征矢量决定，如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008160908338-1684512358754-7.png"  style="zoom: 60%;" /></p>
<p>椭圆函数特征值与图像中的角点、直线（边缘）和平面之间的关系如下图所示。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008161040473-1684512385628-9.png"  style="zoom: 45%;" /></p>
<p>共可分为三种情况：</p>
<ol type="1">
<li>图像中的直线。一个特征值大，另一个特征值小，<span class="math inline">\(\lambda_1&gt;&gt;\lambda_2\)</span>或 <span class="math inline">\(\lambda_2&gt;&gt;\lambda_1\)</span>。椭圆函数值在某一方向上大，在其他方向上小。</li>
<li>图像中的平面。两个特征值都小，且近似相等；椭圆函数数值在各个方向上都小。</li>
<li>图像中的角点。两个特征值都大，且近似相等，椭圆函数在所有方向都增大</li>
</ol>
<p>Harris给出的角点计算方法并不需要计算具体的特征值，而是计算一个<strong>角点响应值<span class="math inline">\(R\)</span></strong>来判断角点。<span class="math inline">\(R\)</span>的计算公式是 <span class="math display">\[
R=detM-\alpha(traceM)^2\\
detM=\lambda_1\lambda_2\\
traceM=\lambda_1+\lambda_2
\]</span> 式中，<span class="math inline">\(detM\)</span>为矩阵<span class="math inline">\(M\)</span>的行列式；<span class="math inline">\(traceM\)</span>为矩阵<span class="math inline">\(M\)</span>的迹；<span class="math inline">\(\alpha\)</span>为常数，取值范围为0.04~0.06。</p>
<p>如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008161904372-1684512700094-11.png"  style="zoom: 50%;" /></p>
<ul>
<li>当R为大数值的正数时是角点</li>
<li>当R为大数值的负数时是边界</li>
<li>当R为小数是认为是平坦区域</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst=cv.cornerHarris(src, blockSize, ksize, k)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img：数据类型为 ﬂoat32 的输入图像。</li>
<li>blockSize：角点检测中要考虑的邻域大小。</li>
<li>ksize：<code>sobel算子</code>求导使用的核大小。</li>
<li>k：角点检测方程中的自由参数，取值参数为 [0.04，0.06]。</li>
</ul>
<h3 id="示例代码">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像，并转换成灰度图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/chessboard.jpg&#x27;</span>)</span><br><span class="line">gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 2 角点检测</span></span><br><span class="line"><span class="comment"># 2.1 输入图像必须是 float32</span></span><br><span class="line">gray = np.float32(gray)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 最后一个参数在 0.04 到 0.05 之间</span></span><br><span class="line">dst = cv.cornerHarris(gray,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0.04</span>)</span><br><span class="line"><span class="comment"># 3 设置阈值，将角点绘制出来，阈值根据图像进行选择</span></span><br><span class="line">img[dst&gt;<span class="number">0.001</span>*dst.<span class="built_in">max</span>()] = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>]</span><br><span class="line"><span class="comment"># 4 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;Harris角点检测&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008164344988-1684512767151-13.png"  style="zoom: 33%;" /></p>
<p>Harris角点检测的优缺点：</p>
<p>优点：</p>
<ul>
<li>旋转不变性，椭圆转过一定角度但是其形状保持不变（特征值保持不变）</li>
<li>对于图像灰度的仿射变化具有部分的不变性，由于仅仅使用了图像的一介导数，对于图像灰度平移变化不变；对于图像灰度尺度变化不变</li>
</ul>
<p>缺点：</p>
<ul>
<li>对尺度很敏感，不具备几何尺度不变性。</li>
<li>提取的角点是像素级的</li>
</ul>
<h2 id="shi-tomasi角点检测">Shi-Tomasi角点检测</h2>
<p><code>Shi-Tomasi算法</code>是对<code>Harris算法</code>的改进，具体地：若矩阵M的两个特征值<span class="math inline">\(\lambda_1,\lambda_2\)</span>中较小的一个大于阈值，则认为他是角点，即： <span class="math display">\[
R=min(\lambda_1,\lambda_2)
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">corners = cv2.goodFeaturesToTrack ( image, maxcorners, qualityLevel, minDistance )</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>Image：输入灰度图像</li>
<li>maxCorners：获取角点数的数目。</li>
<li>qualityLevel：指出最低可接受的角点质量水平，在0-1之间。</li>
<li>minDistance：角点之间最小的欧式距离，避免得到相邻特征点。</li>
</ul>
<p>返回：</p>
<ul>
<li>Corners: 搜索到的角点，在这里所有低于质量水平的角点被排除掉，然后把合格的角点按质量排序，然后将质量较好的角点附近（小于最小欧式距离）的角点删掉，最后找到maxCorners个角点返回。</li>
</ul>
<h3 id="示例代码-1">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/tv.jpg&#x27;</span>) </span><br><span class="line">gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 2 角点检测</span></span><br><span class="line">corners = cv.goodFeaturesToTrack(gray,<span class="number">1000</span>,<span class="number">0.01</span>,<span class="number">10</span>)  </span><br><span class="line"><span class="comment"># 3 绘制角点</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> corners:</span><br><span class="line">    x,y = i.ravel()</span><br><span class="line">    cv.circle(img,(x,y),<span class="number">2</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 4 图像展示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;shi-tomasi角点检测&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008174257711.png"  style="zoom: 45%;" /></p>
<h1 id="sift和surf算法">SIFT和SURF算法</h1>
<h2 id="sift算法"><a href="https://baike.baidu.com/item/SIFT/1396275?fr=aladdin">SIFT算法</a></h2>
<p><code>Harris</code>和<code>Shi-Tomasi</code>角点检测算法具有旋转不变性，但不具有尺度不变性，以下图为例，在左侧小图中可以检测到角点，但是图像被放大后，在使用同样的窗口，就检测不到角点了。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008181535222-1684547971195-2.png"  style="zoom: 80%;" /></p>
<p><strong>尺度不变特征转换</strong>（Scale-invariant feature transform，SIFT）。此算法由 David Lowe在1999年所发表，2004年完善总结。它的实质是在不同的尺度空间上查找关键点(特征点)，并计算出关键点的方向。SIFT所查找到的关键点是一些十分突出，不会因光照，仿射变换和噪音等因素而变化的点，如<strong>角点、边缘点、暗区的亮点及亮区的暗点</strong>等。</p>
<ol type="1">
<li>尺度空间极值检测：搜索所有尺度上的图像位置。通过高斯差分函数来识别潜在的对于尺度和旋转不变的关键点。</li>
<li>关键点定位：在每个候选的位置上，通过一个拟合精细的模型来确定位置和尺度。关键点的选择依据于它们的稳定程度。</li>
<li>关键点方向确定：基于图像局部的梯度方向，分配给每个关键点位置一个或多个方向。所有后面的对图像数据的操作都相对于关键点的方向、尺度和位置进行变换，从而保证了对于这些变换的不变性。</li>
<li>关键点描述：在每个关键点周围的邻域内，在选定的尺度上测量图像局部的梯度。这些梯度作为关键点的描述符，它允许比较大的局部形状的变形或光照变化。</li>
</ol>
<h3 id="尺度空间极值检测">尺度空间极值检测</h3>
<p>在不同的尺度空间是不能使用相同的窗口检测极值点，对小的关键点使用小的窗口，对大的关键点使用大的窗口，为了达到上述目的，使用<strong>尺度空间滤波器</strong>。（高斯核是唯一可以产生多尺度空间的核函数）</p>
<p>一个图像的尺度空间<span class="math inline">\(L(x,y,\sigma)\)</span>定义为原始图像<span class="math inline">\(I(x,y)\)</span>与一个可变尺度的2维高斯函数<span class="math inline">\(G(x,y,\sigma)\)</span><strong>卷积运算</strong> ，即： <span class="math display">\[
L(x,y,\sigma)=G(x,y,\sigma)*I(x,y)
\]</span> 其中<span class="math inline">\(\sigma\)</span>是尺度空间因子，它决定图像的模糊程度。在大尺度下(<span class="math inline">\(\sigma\)</span>值大)表现的是图像的概貌信息，在小尺度下(<span class="math inline">\(\sigma\)</span>值小)表现的是图像的细节信息。</p>
<p>在计算高斯函数的离散近似时，在大概<span class="math inline">\(3\sigma\)</span>距离之外的像素都可以看作不起作用，这些像素的计算也就可以忽略。所以，在实际应用中，只计算<span class="math inline">\((6\sigma+1)\times(6\sigma+1)\)</span>的高斯卷积核就可以保证相关像素影响。</p>
<p>下面构建图像的高斯金字塔，它采用高斯函数对图像进行模糊以及降采样处理得到的， 1. 将图像扩大一倍，在扩大的图像的基础之上构建高斯金字塔， 2. 对该尺寸下图像进行高斯模糊，几幅模糊之后的图像集合构成了一个Octave， 3. 对该Octave下选择一幅图像进行下采样，长和宽分别缩短一倍，图像面积变为原来四分之一。这幅图像就是下一个Octave的初始图像，在初始图像的基础上完成属于这个Octave的高斯模糊处理， 4. 以此类推，完成整个算法。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191009110944907-1684549584975-4.png"  style="zoom: 40%;" /></p>
<p>利用高斯拉普拉斯算子(Laplacian of Gaussian, <code>LoG</code>)，即图像的二阶导数，可以在不同的尺度下检测图像的关键点信息，从而确定图像的特征点。但<code>LoG</code>的计算量大，效率低。所以通过两个相邻高斯尺度空间的图像相减，得到高斯差分(Difference of Gaussians，<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%B7%AE%E5%88%86%E5%87%BD%E6%95%B0/1597793?fr=aladdin">DOG</a>)来近似<code>LoG</code>。</p>
<ol type="1">
<li>构建<strong>高斯差分金字塔</strong>
<ul>
<li>将<strong>高斯金字塔</strong>中每个Octave中相邻两层相减就构成了高斯差分金字塔。</li>
<li>高斯差分金字塔的<strong>第o组第i层图</strong>像是由高斯金字塔的<strong>第o组第i+1层减第o组第i层</strong>得到的。</li>
</ul></li>
</ol>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191009113953721-1684549912508-6.png"  style="zoom: 33%;" /></p>
<ol start="2" type="1">
<li>在不同的尺度空间中搜索局部最大值
<ul>
<li>对于图像中的每一个像素点而言，它需要与自己周围的<span class="math inline">\(8\)</span>邻域，以及尺度空间中上下两层中的相邻的<span class="math inline">\(18(2\times9)\)</span>个点相比。</li>
<li>如果是局部最大值，它就可能是一个关键点。 <img src="/imgs/$%7Bfiilename%7D/image-20191009115023016-1684549955480-8.png" style="zoom:50%;" /></li>
<li>搜索过程从每组的第二层开始，以第二层为当前层，对第二层的<code>DoG</code>图像中的每个点取一个<span class="math inline">\(3\times3\)</span>的立方体，立方体上下层为第一层与第三层。搜索得到的极值点既有位置坐标(<code>DoG</code>的图像坐标)，又有空间尺度坐标(层坐标)。</li>
<li>当第二层搜索完成后，再以第三层作为当前层，其过程与第二层的搜索类似。</li>
<li>当<span class="math inline">\(S=3\)</span>时，每组里面要搜索3层，所以在高斯差分金字塔中就有<span class="math inline">\(S+2\)</span>层，在高斯金字塔中每组有<span class="math inline">\(S+3\)</span>层。</li>
</ul></li>
</ol>
<h3 id="关键点定位">关键点定位</h3>
<p>由于<code>DoG</code>对噪声和边缘比较敏感，因此在高斯差分金字塔中检测到的局部极值点需经过进一步的检验才能精确定位为特征点。</p>
<p>使用尺度空间的泰勒级数展开来获得极值的准确位置， 如果<strong>极值点的灰度值小于阈值</strong>（一般为0.03或0.04）就会被忽略掉。 在 OpenCV 中这种阈值被称为 contrastThreshold。</p>
<p>欠佳的关键点在平行边缘的方向有较大的主曲率，而在垂直于边缘的方向有较小的曲率，两者的比值如果高于某个阈值（在OpenCV中叫做边界阈值），就认为该关键点为边界，将被忽略，一般该阈值为10。</p>
<p>将低对比度和边界的关键点去除，得到的就是我们感兴趣的关键点。</p>
<h3 id="关键点方向确定">关键点方向确定</h3>
<p>为了实现旋转不变性，还需要为每个关键点分配一个方向角度，也就是在高斯尺度图像的邻域结构中求得一个方向基准。</p>
<p>对于任一关键点，采集其所在高斯金字塔图像以<span class="math inline">\(r\)</span>为半径的区域内所有像素的梯度特征（幅值和幅角），<span class="math inline">\(r=3\times1.5\sigma\)</span>，其中<span class="math inline">\(\sigma\)</span>是关键点所在octave的图像的尺度，可以得到对应的尺度图像。</p>
<p>梯度的幅值和方向的计算公式为： <span class="math display">\[
m(x,y)=\sqrt{(L(x+1,y)-L(x-1,y))^2+(L(x,y+1)-L(x,y-1))^2}
\]</span> <span class="math display">\[
\theta(x,y)=\arctan(\frac{L(x,y+1)-L(x,y-1)}{L(x+1,y)-L(x-1,y)}
\]</span> 邻域像素梯度的计算结果如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191009143818527-1684552168908-10.png"  style="zoom:50%;" /></p>
<p>使用直方图统计关键点邻域内像素的梯度幅值和方向。</p>
<ol type="1">
<li><p>将<span class="math inline">\(360^\circ\)</span>分为<span class="math inline">\(36\)</span>柱，每<span class="math inline">\(10^\circ\)</span>为一柱，然后在以<span class="math inline">\(r\)</span>为半径的区域内，将梯度方向在某一个柱内的像素找出来。</p></li>
<li><p>将他们的幅值相加在一起作为柱的高度。因为在r为半径的区域内像素的梯度幅值对中心像素的贡献是不同的，因此还需要对幅值进行加权处理，采用高斯加权，方差为<span class="math inline">\(1.5\sigma\)</span>。 <img src="/imgs/$%7Bfiilename%7D/image-20191009144726492-1684552637576-16.png"  style="zoom:33%;" /></p></li>
<li><p>每个特征点必须分配一个主方向，还需要一个或多个辅方向，增加辅方向的目的是为了增强图像匹配的鲁棒性。辅方向的定义是，当一个柱体的高度大于主方向柱体高度的<span class="math inline">\(80\%\)</span>时，则该柱体所代表的的方向就是给特征点的辅方向。</p></li>
<li><p>直方图的峰值，即最高的柱代表的方向是特征点邻域范围内图像梯度的主方向，但该柱体代表的角度是一个范围，所以我们还要对离散的直方图进行插值拟合，以得到更精确的方向角度值。利用抛物线对离散的直方图进行拟合。 <img src="/imgs/$%7Bfiilename%7D/image-20191009150008701-1684552598604-14.png" style="zoom: 40%;" /></p></li>
</ol>
<p>获得图像关键点主方向后，使用一个带箭头的圆或直接使用箭头表示SIFT区域的三个值：中心表示特征点位置<span class="math inline">\((x,y)\)</span>，半径表示关键点尺度<span class="math inline">\((\sigma)\)</span>，箭头表示方向<span class="math inline">\((\theta)\)</span>。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191025112522974-1684552568027-12.png"  style="zoom:50%;" /></p>
<h3 id="关键点描述">关键点描述</h3>
<p>为每个关键点建立一个描述符，该描述符既具有可区分性，又具有对某些变量的不变性，如光照，视角等。而且描述符不仅仅包含关键点，也包括关键点周围对其有贡献的的像素点。</p>
<p>在关键点所在的高斯尺度图像上生成对应的描述符。以特征点为中心，将其附近邻域划分为<span class="math inline">\(d\times d\)</span>个子区域（一般取<span class="math inline">\(d=4\)</span>)，每个子区域都是一个正方形，边长为<span class="math inline">\(3\sigma\)</span>，考虑到实际计算时，需进行三次线性插值，所以特征点邻域的为<span class="math inline">\(3\sigma(d+1)\times3\sigma(d+1)\)</span>的范围，如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191009161647267-1684552834400-18.png"  style="zoom: 67%;" /></p>
<p>为了保证特征点的旋转不变性，以特征点为中心，将坐标轴旋转为关键点的主方向，如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191009161756423-1684552865043-20.png"  style="zoom:67%;" /></p>
<p>计算子区域内的像素的梯度，并按照<span class="math inline">\(\sigma=0.5d\)</span>进行高斯加权，然后插值计算得到每个种子点的八个方向的梯度，插值方法如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191009162914982-1684552898801-22.png"  style="zoom:67%;" /></p>
<p>每个种子点的梯度都是由覆盖其的<span class="math inline">\(4\)</span>个子区域插值而得的。如图中的红色点，落在第<span class="math inline">\(0\)</span>行和第<span class="math inline">\(1\)</span>行之间，对这两行都有贡献。</p>
<ul>
<li>对第<span class="math inline">\(0\)</span>行第<span class="math inline">\(3\)</span>列种子点的贡献因子为<span class="math inline">\(dr\)</span>，对第<span class="math inline">\(1\)</span>行第<span class="math inline">\(3\)</span>列的贡献因子为<span class="math inline">\(1-dr\)</span>，</li>
<li>对邻近两列的贡献因子为<span class="math inline">\(dc\)</span>和<span class="math inline">\(1-dc\)</span></li>
<li>对邻近两个方向的贡献因子为<span class="math inline">\(do\)</span>和<span class="math inline">\(1-do\)</span>。</li>
</ul>
<p>最终累加在每个方向上的梯度大小为： <span class="math display">\[
weight=w*dr^k(1-dr)^{(1-k)}dc^m(1-dc)^{1-m}do^n(1-do^{1-n})
\]</span> 其中<span class="math inline">\(k,m,n\)</span>为0或为1。 如上统计<span class="math inline">\(4\times4\times8=128\)</span>个梯度信息即为该关键点的特征向量，按照特征点的对每个关键点的特征向量进行排序，就得到了SIFT特征描述向量。</p>
<p><strong>实例化sift</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sift = cv.xfeatures2d.SIFT_create()</span><br></pre></td></tr></table></figure>
<p><strong>利用<code>sift.detectAndCompute()</code>检测关键点并计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp,des = sift.detectAndCompute(gray,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>gray：进行关键点检测的图像，注意是灰度图像</li>
</ul>
<p>返回：</p>
<ul>
<li>kp：关键点信息，包括位置，尺度，方向信息</li>
<li>des：关键点描述符，每个关键点对应128个梯度信息的特征向量</li>
</ul>
<p><strong>将关键点检测结果绘制在图像上</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.drawKeypoints(image, keypoints, outputimage, color, flags)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>image: 原始图像</p></li>
<li><p>keypoints：关键点信息，将其绘制在图像上</p></li>
<li><p>outputimage：输出图片，可以是原始图像</p></li>
<li><p>color：颜色设置，通过修改b、g、r的值,更改画笔的颜色</p></li>
<li><p>flags：绘图功能的标识设置</p>
<ul>
<li><p>cv2.DRAW_MATCHES_FLAGS_DEFAULT：创建输出图像矩阵，使用现存的输出图像绘制匹配对和特征点，对每一个关键点只绘制中间点</p></li>
<li><p>cv2.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG：不创建输出图像矩阵，而是在输出图像上绘制匹配对</p></li>
<li><p>cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS：对每一个特征点绘制带大小和方向的关键点图形</p></li>
<li><p>cv2.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS：单点的特征点不被绘制</p></li>
</ul></li>
</ul>
<h3 id="示例代码-2">示例代码：</h3>
<p>利用SIFT算法在中央电视台的图片上检测关键点，并将其绘制出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/tv.jpg&#x27;</span>)</span><br><span class="line">gray= cv.cvtColor(img,cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 2 sift关键点检测</span></span><br><span class="line"><span class="comment"># 2.1 实例化sift对象</span></span><br><span class="line">sift = cv.xfeatures2d.SIFT_create()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 关键点检测：kp关键点信息包括方向，尺度，位置信息，des是关键点的描述符</span></span><br><span class="line">kp,des=sift.detectAndCompute(gray,<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 2.3 在图像上绘制关键点的检测结果</span></span><br><span class="line">cv.drawKeypoints(img,kp,img,flags=cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)</span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;sift检测&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191009181525538-1684553395070-26.png"  style="zoom: 50%;" /></p>
<h2 id="surf算法">SURF算法</h2>
<p>使用 SIFT 算法进行关键点检测和描述的执行速度比较慢， 需要速度更快的算法。 2006 年 Bay提出了 SURF 算法，是SIFT算法的增强版，它的计算量小，运算速度快，提取的特征与SIFT几乎相同，将其与SIFT算法对比如下：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191016163330835-1684553312569-24.png"  style="zoom:67%;" /></p>
<h1 id="fast和orb算法">Fast和ORB算法</h1>
<h2 id="fast算法"><a href="https://en.wikipedia.org/wiki/Features_from_accelerated_segment_test">Fast算法</a></h2>
<p>Fast(Features from accelerated segment test)是一种角点检测算法，Edward Rosten和Tom Drummond在2006年提出了FAST算法，并在2010年对其进行了修正。该算法的原理是取图像中检测点，以该点为圆心的周围邻域内像素点判断检测点是否为角点，通俗的讲就是<strong>若一个像素周围有一定数量的像素与该点像素值不同，则认为其为角点</strong>。</p>
<ol type="1">
<li><p>在图像中选取一个像素点<span class="math inline">\(p\)</span>，来判断它是不是关键点。<span class="math display">\[I_p\]</span>等于像素点<span class="math inline">\(p\)</span>的灰度值。</p></li>
<li><p>以<span class="math inline">\(r\)</span>为半径画圆，覆盖<span class="math inline">\(p\)</span>点周围的<span class="math inline">\(M\)</span>个像素，通常情况设置<span class="math inline">\(r=3\)</span>，则<span class="math inline">\(M=16\)</span>。 <img src="/imgs/$%7Bfiilename%7D/image17-1684555943527-30.jpg"  style="zoom: 67%;" /></p></li>
<li><p>设置阈值<span class="math inline">\(t\)</span>，如果在这<span class="math inline">\(16\)</span>个像素点中存在<span class="math inline">\(n\)</span>个连续像素点的灰度值都高于<span class="math inline">\(I_p+t\)</span>，或者低于<span class="math inline">\(I_p-t\)</span>，那么像素点<span class="math inline">\(p\)</span>就被认为是一个角点。如上图中的虚线所示，一般取值为<span class="math inline">\(n=12\)</span>。</p></li>
<li><p>采用一种<strong>非特征点判别</strong>的方法：首先对候选点的周围每个<span class="math inline">\(90^\circ\)</span>的点（<span class="math inline">\(1,9,5,13\)</span>）进行测试(先测试<span class="math inline">\(1\)</span>和<span class="math inline">\(9\)</span>，如果它们符合阈值要求再测试<span class="math inline">\(5\)</span>和<span class="math inline">\(13\)</span>)。如果<span class="math inline">\(p\)</span>是角点，那么这四个点中至少有 3 个要符合阈值要求，否则直接剔除。对保留下来的点再继续进行测试。</p></li>
</ol>
<h3 id="机器学习的角点检测器">机器学习的角点检测器</h3>
<ol type="1">
<li><p>选择一组训练图片</p></li>
<li><p>使用<code>FAST算法</code>找出每幅图像的特征点，对图像中的每一个特征点，将其周围的<span class="math inline">\(16\)</span>个像素存储构成一个向量<span class="math inline">\(P\)</span>。 <img src="/imgs/$%7Bfiilename%7D/image-20191010114459269-1684556434454-32.png"  style="zoom:67%;" /></p></li>
<li><p>每一个特征点的 16 像素点都属于下列三类中的一种 $$ S_{px}=</p>
<span class="math display">\[\begin{cases}
d\quad I_{p\rightarrow x}\leq I_{p}-t\quad (darker)\\
s\quad I_{p}-t\leq I_{p\rightarrow x}\leq I_{p}+t\quad (similar)\\
b\quad I_{p}+t\leq I_{p\rightarrow x}\quad (brighter)\\

\end{cases}\]</span>
<p>$$</p></li>
<li><p>根据这些像素点的分类，特征向量<span class="math inline">\(P\)</span>也被分为<span class="math inline">\(3\)</span>个子集(<span class="math inline">\(P_d,P_s,P_b\)</span>)，</p></li>
<li><p>定义一个新的布尔变量<span class="math inline">\(K_p\)</span>，如果<span class="math inline">\(p\)</span>是角点就设置为<span class="math inline">\(True\)</span>，如果不是就设置为<span class="math inline">\(False\)</span>。</p></li>
<li><p>利用特征值向量<span class="math inline">\(p\)</span>，目标值是<span class="math inline">\(K_p\)</span>，训练<span class="math inline">\(ID3\)</span>树（决策树分类器）。</p></li>
<li><p>将构建好的决策树运用于其他图像的快速检测。</p></li>
</ol>
<h3 id="非极大值抑制">非极大值抑制</h3>
<p><strong>在筛选出来的候选角点中有很多是紧挨在一起的，需要通过非极大值抑制来消除这种影响。</strong></p>
<p>为所有的候选角点确定一个打分函数<span class="math inline">\(V\)</span></p>
<ol type="1">
<li><p>分别计算<span class="math inline">\(I_p\)</span>与圆上<span class="math inline">\(16\)</span>个点的像素值差值，取绝对值，</p></li>
<li><p>将这16个绝对值相加，就得到了<span class="math inline">\(V\)</span>的值 <span class="math display">\[
V = \sum_{i}^{16}|I_p-I_i|
\]</span></p></li>
<li><p>比较毗邻候选角点的<span class="math inline">\(V\)</span>值，把<span class="math inline">\(V\)</span>值较小的候选角点去除掉。</p></li>
</ol>
<p><strong>实例化Fast</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fast = =cv.FastFeatureDetector_create( threshold, nonmaxSuppression)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>threshold：阈值t，默认值10</li>
<li>nonmaxSuppression：是否进行非极大值抑制，默认值True</li>
</ul>
<p>返回：</p>
<ul>
<li>Fast：创建的FastFeatureDetector对象</li>
</ul>
<p><strong>利用<code>fast.detect()</code>检测关键点，没有对应的关键点描述</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp = fast.detect(grayImg, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>gray: 进行关键点检测的图像，注意是灰度图像</li>
</ul>
<p>返回：</p>
<ul>
<li>kp: 关键点信息，包括位置，尺度，方向信息</li>
</ul>
<p><strong>将关键点检测结果绘制在图像上</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.drawKeypoints(image, keypoints, outputimage, color, flags)</span><br></pre></td></tr></table></figure>
<h3 id="示例代码-3">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/tv.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 2 Fast角点检测</span></span><br><span class="line"><span class="comment"># 2.1 创建一个Fast对象，传入阈值，注意：可以处理彩色空间图像</span></span><br><span class="line">fast = cv.FastFeatureDetector_create(threshold=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 检测图像上的关键点</span></span><br><span class="line">kp = fast.detect(img,<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 2.3 在图像上绘制关键点</span></span><br><span class="line">img2 = cv.drawKeypoints(img, kp, <span class="literal">None</span>, color=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.4 输出默认参数</span></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;Threshold: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(fast.getThreshold()) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;nonmaxSuppression:&#123;&#125;&quot;</span>.<span class="built_in">format</span>(fast.getNonmaxSuppression()) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;neighborhood: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(fast.getType()) )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;Total Keypoints with nonmaxSuppression: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(kp)) )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.5 关闭非极大值抑制</span></span><br><span class="line">fast.setNonmaxSuppression(<span class="number">0</span>)</span><br><span class="line">kp = fast.detect(img,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>( <span class="string">&quot;Total Keypoints without nonmaxSuppression: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(kp)) )</span><br><span class="line"><span class="comment"># 2.6 绘制为进行非极大值抑制的结果</span></span><br><span class="line">img3 = cv.drawKeypoints(img, kp, <span class="literal">None</span>, color=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 绘制图像</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img2[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;加入非极大值抑制&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(img3[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;未加入非极大值抑制&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191010120822413-1684557401983-34.png"  style="zoom: 50%;" /></p>
<h2 id="orb-算法"><a href="https://medium.com/data-breach/introduction-to-orb-oriented-fast-and-rotated-brief-4220e8ec40cf">ORB 算法</a></h2>
<p>ORB（Oriented Fast and Rotated Brief）可以用来对图像中的关键点快速创建特征向量，并用这些特征向量来识别图像中的对象。</p>
<p>ORB算法结合了Fast和Brief算法，提出了构造金字塔，为Fast特征点添加了方向，从而使得关键点具有了尺度不变性和旋转不变性。</p>
<ol type="1">
<li>构造尺度金字塔
<ul>
<li>金字塔共有<span class="math inline">\(n\)</span>层，与SIFT不同的是，每一层仅有一幅图像。第<span class="math inline">\(s\)</span>层的尺度为<span class="math inline">\(\sigma_s=\sigma_0^s\)</span>， <span class="math inline">\(\sigma_0\)</span>是初始尺度，默认为<span class="math inline">\(1.2\)</span>，原图在第<span class="math inline">\(0\)</span>层。第<span class="math inline">\(s\)</span>层图像的大小<span class="math inline">\(Size = (H*\frac{1}{\sigma_s})\times(W*\frac{1}{\sigma_s})\)</span></li>
</ul></li>
<li>在不同的尺度上利用<code>Fast算法</code>检测特征点
<ul>
<li>采用Harris角点响应函数，根据角点的响应值排序，选取前<span class="math inline">\(N\)</span>个特征点，作为本尺度的特征点。</li>
</ul></li>
<li>计算特征点的主方向
<ul>
<li><p>计算以特征点为圆心，半径为<span class="math inline">\(r\)</span>的圆形邻域内的灰度质心位置，将从特征点位置到质心位置的方向做特征点的主方向。 <span class="math display">\[
m_{pq}=\sum_{x,y}x^py^qI(x,y)
\]</span> 质心位置： <span class="math inline">\(C=(\frac{m_{10}}{m_{00}},\frac{m_{01}}{m_{10}})\)</span></p>
<p>主方向： <span class="math inline">\(\theta = arctan(m_{01},m_{10})\)</span></p></li>
</ul></li>
</ol>
<h3 id="brief算法">BRIEF算法</h3>
<p>了解决旋转不变性，将特征点的邻域旋转到主方向上利用<code>Brief算法</code>构建特征描述符，至此就得到了ORB的特征描述向量。</p>
<p><code>Brief算法</code>是一种特征描述子提取算法，并非特征点的提取算法，匹配只需要使用简单的汉明距离(Hamming Distance)利用比特之间的异或操作就可以完成。</p>
<ol type="1">
<li>图像滤波
<ul>
<li>原始图像中存在噪声时，会对结果产生影响，所以需要对图像进行滤波，去除部分噪声。</li>
</ul></li>
<li>选取点对
<ul>
<li><p>以特征点为中心，取<span class="math inline">\(S\times S\)</span>的邻域窗口，在窗口内随机选取<span class="math inline">\(N\)</span>组点对，一般<span class="math inline">\(N=128,256,512\)</span>，默认是<span class="math inline">\(256\)</span>，关于选取随机点对，提供了五种形式</p>
<ul>
<li><span class="math inline">\(x,y\)</span>方向平均分布采样</li>
<li><span class="math inline">\(x,y\)</span>均服从<span class="math inline">\(Gauss(0,\frac{S^2}{25})\)</span>各向同性采样</li>
<li><span class="math inline">\(x\)</span>服从<span class="math inline">\(Gauss(0,\frac{S^2}{25})\)</span>，<span class="math inline">\(y\)</span>服从<span class="math inline">\(Gauss(0,\frac{S^2}{100})\)</span>采样</li>
<li><span class="math inline">\(x,y\)</span>从网格中随机获取</li>
<li><span class="math inline">\(x\)</span>一直在<span class="math inline">\((0,0)\)</span>，<span class="math inline">\(y\)</span>从网格中随机选取</li>
</ul>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191010153907973-1684559140937-36.png"  style="zoom:67%;" /></p></li>
<li><p>图中一条线段的两个端点就是一组点对，其中第二种方法的结果比较好。</p></li>
</ul></li>
<li>构建描述符
<ul>
<li><p>假设<span class="math inline">\(x,y\)</span>是某个点对的两个端点，<span class="math inline">\(p(x),p(y)\)</span>是两点对应的像素值， <span class="math display">\[
t(x,y)=\begin{cases}1 &amp;if&amp;p(x)&gt;p(y)\\ 0&amp; else\end{cases}
\]</span></p></li>
<li><p>对每一个点对都进行上述的二进制赋值，形成<code>Brief</code>的关键点的描述特征向量，该向量一般为<span class="math inline">\(128-512\)</span>位的字符串，其中仅包含<span class="math inline">\(1\)</span>和<span class="math inline">\(0\)</span></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191010161944491-1684559749207-38.png" style="zoom: 50%;" /></p></li>
</ul></li>
</ol>
<p><strong>实例化ORB</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">orb = cv.xfeatures2d.orb_create(nfeatures)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>nfeatures: 特征点的最大数量</li>
</ul>
<p><strong>利用<code>orb.detectAndCompute()</code>检测关键点并计算</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kp,des = orb.detectAndCompute(gray,<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>gray: 进行关键点检测的图像，注意是灰度图像</li>
</ul>
<p>返回：</p>
<ul>
<li>kp: 关键点信息，包括位置，尺度，方向信息</li>
<li>des: 关键点描述符，每个关键点BRIEF特征向量，二进制字符串，</li>
</ul>
<p><strong>将关键点检测结果绘制在图像上</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.drawKeypoints(image, keypoints, outputimage, color, flags)</span><br></pre></td></tr></table></figure>
<h3 id="示例代码-4">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像读取</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/tv.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 ORB角点检测</span></span><br><span class="line"><span class="comment"># 2.1 实例化ORB对象</span></span><br><span class="line">orb = cv.ORB_create(nfeatures=<span class="number">500</span>)</span><br><span class="line"><span class="comment"># 2.2 检测关键点,并计算特征描述符</span></span><br><span class="line">kp,des = orb.detectAndCompute(img,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(des.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 将关键点绘制在图像上</span></span><br><span class="line">img2 = cv.drawKeypoints(img, kp, <span class="literal">None</span>, color=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), flags=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 绘制图像</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.imshow(img2[:,:,::-<span class="number">1</span>])</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191010162532196-1684559841023-40.png"  style="zoom: 45%;" /></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像处理(下)</title>
    <url>/OpenCV/OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E4%B8%8B/</url>
    <content><![CDATA[<h1 id="直方图">直方图</h1>
<h2 id="图像直方图">图像直方图</h2>
<p>在统计学中，<a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%96%B9%E5%9B%BE">直方图</a>是一种对数据分布情况的图形表示，是一种二维统计图表，它的两个 坐标分别是统计样本和该样本对应的某个属性的度量，以长条图(bar)的形式具体表现。因为直方图的长度及宽度很适合用来表现数量上的变化，所以较容易解读差异小的数值。</p>
<span id="more"></span>
<p>图像直方图（Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素个数。这种直方图中，横坐标的左侧为较暗的区域，而右侧为较亮的区域。因此一张较暗图片的直方图中的数据多集中于左侧和中间部分，而整体明亮、只有少量阴影的图像则相反。</p>
<p>假设有一张图像的信息（灰度值<span class="math inline">\(0-255\)</span>），按一定规律将这个范围分割成子区域（也就是 bins）。如下按<span class="math inline">\(bin=16\)</span>分割 <span class="math display">\[
[0,255]=\underbrace{[0,15]}_{b_{1}}\cup\underbrace{[16,30]}_{b_{2}}\cdots\cup\underbrace{[240,255]}_{b_{16}}
\]</span> 再统计<span class="math inline">\(bin(i)\)</span> 的像素数目。得到以<span class="math inline">\(x\)</span>轴表示<span class="math inline">\(bin\)</span>，<span class="math inline">\(y\)</span> 轴表示各个<span class="math inline">\(bin\)</span>中的像素个数的图像直方图</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928144352467-1684457137421-1.png"  style="zoom:67%;" /></p>
<p><strong>注意：</strong></p>
<ul>
<li><p>直方图是根据灰度图进行绘制的，而不是彩色图像。</p></li>
<li><p>直方图是图像中像素强度分布的图形表达方式。   </p></li>
<li><p>它统计了每一个强度值所具有的像素个数。</p></li>
<li><p>不同的图像的直方图可能是相同的</p></li>
</ul>
<h2 id="直方图的计算和绘制">直方图的计算和绘制</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.calcHist(images,channels,mask,histSize,ranges[,hist[,accumulate]])</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>images：原图像。当传入函数时应该用中括号[]括起来，例如：[img]。</li>
<li>channels：如果输入图像是灰度图，它的值就是[0]；如果是彩色图像的话，传入的参数可以是[0]，[1]，[2]。它们分别对应着B，G，R通道。 　　</li>
<li>mask: 掩模图像。要统计整幅图像的直方图就把它设为 None。但是如果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并使用它。　　</li>
<li>histsize：<span class="math inline">\(bin\)</span>的数目。也应该用中括号括起来，例如：[256]。 　　</li>
<li>ranges：像素值范围，通常为[0，256]</li>
</ul>
<h3 id="示例代码">示例代码</h3>
<p>绘制直方图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 直接以灰度图的方式读入</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/cat.jpeg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 2 统计灰度图</span></span><br><span class="line">histr = cv.calcHist([img],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span><br><span class="line"><span class="comment"># 3 绘制灰度图</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.plot(histr)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928155000064-1684458391504-3.png"  style="zoom:67%;" /></p>
<h2 id="掩膜">掩膜</h2>
<p>掩膜是用选定的图像、图形或物体，对要处理的图像进行遮挡，来控制图像处理的区域。</p>
<p>在数字图像处理中，通常使用二维矩阵数组进行掩膜。掩膜是由0和1组成一个二进制图像，利用该掩膜图像要处理的图像进行掩膜，其中1值的区域被处理，0 值区域被屏蔽，不会处理。</p>
<p>使用<code>cv.calcHist()</code>来查找完整图像的直方图。</p>
<p>如果要查找图像某些区域的直方图， 只需在要查找直方图的区域上创建一个白色的掩膜图像，否则创建黑色， 然后将其作为掩码mask传递即可。</p>
<h3 id="示例代码-1">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1. 直接以灰度图的方式读入</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/cat.jpeg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 2. 创建蒙版</span></span><br><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>], np.uint8)</span><br><span class="line">mask[<span class="number">400</span>:<span class="number">650</span>, <span class="number">200</span>:<span class="number">500</span>] = <span class="number">255</span></span><br><span class="line"><span class="comment"># 3.掩模</span></span><br><span class="line">masked_img = cv.bitwise_and(img,img,mask = mask)</span><br><span class="line"><span class="comment"># 4. 统计掩膜后图像的灰度图</span></span><br><span class="line">mask_histr = cv.calcHist([img],[<span class="number">0</span>],mask,[<span class="number">256</span>],[<span class="number">1</span>,<span class="number">256</span>])</span><br><span class="line"><span class="comment"># 5. 图像展示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].imshow(img,cmap=plt.cm.gray)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].imshow(mask,cmap=plt.cm.gray)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].set_title(<span class="string">&quot;蒙版数据&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].imshow(masked_img,cmap=plt.cm.gray)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].set_title(<span class="string">&quot;掩膜后数据&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].plot(mask_histr)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].grid()</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].set_title(<span class="string">&quot;灰度直方图&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928160241831-1684458631460-5.png"  style="zoom:67%;" /></p>
<h1 id="直方图均衡化">直方图均衡化</h1>
<p><a href="https://baike.baidu.com/item/%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1/4950487">直方图均衡化</a>是把原始图像的灰度直方图从比较集中的某个灰度区间变成在更广泛灰度范围内的分布。</p>
<p>直方图均衡化就是对图像进行非线性拉伸，重新分配图像像素值，使一定灰度范围内的像素数量大致相同。</p>
<p>通过这种方法，亮度可以更好地在直方图上分布。这样可以用于增强局部的对比度而不影响整体的对比度</p>
<p><img src="/imgs/$%7Bfiilename%7D/300px-Histogrammeinebnung.png"  style="zoom: 80%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv.equalizeHist(img)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img: 灰度图像</li>
</ul>
<p>返回：</p>
<ul>
<li>dst : 均衡化后的结果</li>
</ul>
<h3 id="示例代码-2">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1. 直接以灰度图的方式读入</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/cat.jpeg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 2. 均衡化处理</span></span><br><span class="line">dst = cv.equalizeHist(img)</span><br><span class="line"><span class="comment"># 3. 结果展示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img,cmap=plt.cm.gray)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(dst,cmap=plt.cm.gray)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;均衡化后结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928163431354-1684460359762-9.png"  style="zoom:67%;" /></p>
<h2 id="自适应的直方图均衡化">自适应的直方图均衡化</h2>
<p>上述的直方图均衡，我们考虑的是图像的全局对比度。在许多情况下，这样做的效果并不好，但，会丢失了很多信息。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191024105039014-1684460404147-11.png"  style="zoom:67%;" /></p>
<p>为了解决这个问题， 需要使用自适应的直方图均衡化。</p>
<ol type="1">
<li>整幅图像会被分成很多小块，这些小块被称为<code>tiles</code></li>
<li>然后再分别对每个小块进行直方图均衡化。 所以在每个区域中， 直方图会集中在某一个小的区域中。如果有噪声的话，噪声会被放大。为了避免这种情况的出现要使用对比度限制。对于每个小块来说，如果直方图中的 <span class="math inline">\(bin\)</span>超过对比度的上限的话，就把其中的像素点均匀分散到其他<span class="math inline">\(bins\)</span>中，然后在进行直方图均衡化。</li>
</ol>
<p><img src="/imgs/$%7Bfiilename%7D/300px-Clahe-redist.svg.png"  style="zoom:90%;" /></p>
<ol start="3" type="1">
<li>最后，为了去除每一个小块之间的边界，再使用双线性差值，对每一小块进行拼接。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.createCLAHE(clipLimit, tileGridSize)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>clipLimit：对比度限制，默认是40</li>
<li>tileGridSize：分块的大小，默认为<span class="math inline">\(8\times8\)</span></li>
</ul>
<h3 id="示例代码-3">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 1. 以灰度图形式读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/cat.jpeg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 2. 创建一个自适应均衡化的对象，并应用于图像</span></span><br><span class="line">clahe = cv.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">cl1 = clahe.apply(img)</span><br><span class="line"><span class="comment"># 3. 图像展示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img,cmap=plt.cm.gray)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(cl1,cmap=plt.cm.gray)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;自适应均衡化后的结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928165605432-1684460980293-17.png"  style="zoom:67%;" /></p>
<p>与均衡化相比，可以看到在猫腿处不再显得暗黑。</p>
<h1 id="边缘检测">边缘检测</h1>
<p><a href="https://baike.baidu.com/item/%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/3221648">边缘检测</a>是图像处理和计算机视觉中的基本问题，边缘检测的目的是标识数字图像中亮度变化明显的点。</p>
<p>边缘检测的方法绝大部分可以划分为两类</p>
<ul>
<li><p><strong>基于搜索：</strong>通过寻找<strong>图像一阶导数中的最大值</strong>来检测边界，然后利用计算结果估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到局部梯度模的最大值，代表算法是<code>Sobel算子</code>和<code>Scharr算子</code>。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929104240226-1684461871286-19.png"  style="zoom:67%;" /></p></li>
<li><p><strong>基于零穿越：</strong>通过寻找<strong>图像二阶导数零穿越</strong>来寻找边界，代表算法是<code>Laplacian算子</code></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929104430480-1684462287627-21.png"  style="zoom:67%;" /></p></li>
</ul>
<h2 id="sobel算子-基于搜索"><a href="https://baike.baidu.com/item/%E7%B4%A2%E8%B4%9D%E5%B0%94%E7%AE%97%E5%AD%90/15805328"><code>Sobel算子</code></a>-基于搜索</h2>
<p>对于不连续的函数，一阶导数可以写作<span class="math inline">\(f&#39;(x)=f(x)-f(x-1)\)</span>或者<span class="math inline">\(f&#39;(x)=f(x+1)-f(x)\)</span>，所以有 <span class="math display">\[
f&#39;(x)=\frac{f(x+1)-f(x-1)}{2}
\]</span> 假设要处理的图像为<span class="math inline">\(I\)</span>，在两个方向求导</p>
<ol type="1">
<li><strong>水平变化</strong>：将图像<span class="math inline">\(I\)</span>与奇数大小的模版进行卷积，结果为<span class="math inline">\(G_x\)</span>。</li>
</ol>
<ul>
<li>比如，当模板大小为<span class="math inline">\(3\times3\)</span>时, <span class="math display">\[
G_x=\left[\begin{matrix}-1&amp;0&amp;+1\\-2&amp;0&amp;+2\\-1&amp;0&amp;+1\end{matrix}\right]*I
\]</span></li>
</ul>
<ol start="2" type="1">
<li><p><strong>垂直变化</strong>：将图像<span class="math inline">\(I\)</span>与奇数大小的模板进行卷积，结果为<span class="math inline">\(G_y\)</span>。</p>
<ul>
<li>比如，当模板大小为<span class="math inline">\(3\times3\)</span>时, <span class="math display">\[
G_y=\left[\begin{matrix}-1&amp;-2&amp;-1\\0&amp;0&amp;0\\+1&amp;+2&amp;+1\end{matrix}\right]*I
\]</span></li>
</ul></li>
</ol>
<p>在图像的每一点，通过公式求出： <span class="math display">\[
G=\sqrt{G_x^2+G_y^2}
\]</span> 统计极大值所在的位置，就是图像的边缘。</p>
<p><strong>注意：</strong></p>
<ul>
<li>当核大小为<span class="math inline">\(3\times3\)</span>时, 以上<code>Sobel</code>卷积核可能产生比较明显的误差，</li>
<li>为解决这一问题，我们使用<code>Scharr</code>函数，但该函数仅作用于大小为<span class="math inline">\(3\times3\)</span>的卷积核。该函数的运算与<code>Sobel</code>函数一样快，但结果却更加精确，其计算方法为:</li>
</ul>
<p><span class="math display">\[
G_x=\left[\begin{matrix}-3&amp;0&amp;+3\\-10&amp;0&amp;+10\\-3&amp;0&amp;+3\end{matrix}\right]*I
\]</span></p>
<p><span class="math display">\[
G_y=\left[\begin{matrix}-3&amp;-10&amp;-3\\0&amp;0&amp;0\\+3&amp;+10&amp;+3\end{matrix}\right]*I
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Sobel_x_or_y = cv2.Sobel(src, ddepth, dx, dy, dst, ksize, scale, delta, borderType)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>src：传入的图像</p></li>
<li><p>ddepth：图像的深度</p></li>
<li><p>dx和dy：指求导的阶数，0表示这个方向上没有求导，取值为0、1。</p></li>
<li><p>ksize：是<code>Sobel算子</code>的大小，即卷积核的大小，默认为3。</p>
<p><strong>注意：</strong>如果ksize=-1，就演变成为<span class="math inline">\(3\times3\)</span>的<code>Scharr算子</code>。</p></li>
<li><p>scale：缩放导数的比例常数，默认情况为没有伸缩系数。</p></li>
<li><p>borderType：图像边界的模式，默认值为cv2.BORDER_DEFAULT。</p></li>
</ul>
<p><code>Sobel函数</code>求导后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以建立的图像位数不够，会有截断。</p>
<p>因此要使用16位有符号的数据类型，即<code>cv2.CV_16S</code>。处理完图像后，再使用<code>cv2.convertScaleAbs()</code>函数将其转回原来的uint8格式，否则图像无法显示。</p>
<p>最后还需要用<code>cv2.addWeighted()</code>函数将两个方向的<code>Sobel算子</code>计算结果组合起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scale_abs = cv2.convertScaleAbs(x)  # 格式转换函数</span><br><span class="line">result = cv2.addWeighted(src1, alpha, src2, beta) # 图像混合</span><br></pre></td></tr></table></figure>
<h3 id="示例代码-4">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/horse.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 2 计算Sobel卷积结果</span></span><br><span class="line">x = cv.Sobel(img, cv.CV_16S, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">y = cv.Sobel(img, cv.CV_16S, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 3 将数据进行转换</span></span><br><span class="line">Scale_absX = cv.convertScaleAbs(x)  <span class="comment"># convert 转换  scale 缩放</span></span><br><span class="line">Scale_absY = cv.convertScaleAbs(y)</span><br><span class="line"><span class="comment"># 4 结果合成</span></span><br><span class="line">result = cv.addWeighted(Scale_absX, <span class="number">0.5</span>, Scale_absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 5 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img,cmap=plt.cm.gray),plt.title(<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(result,cmap = plt.cm.gray),plt.title(<span class="string">&#x27;Sobel滤波后结果&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929141752847-1684464763720-23.png" style="zoom:67%;" /></p>
<p>将上述代码中计算<code>sobel算子</code>的部分中将ksize设为-1，就是利用<code>Scharrs算子</code>进行边缘检测。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = cv.Sobel(img, cv.CV_16S, <span class="number">1</span>, <span class="number">0</span>, ksize = -<span class="number">1</span>)</span><br><span class="line">y = cv.Sobel(img, cv.CV_16S, <span class="number">0</span>, <span class="number">1</span>, ksize = -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929141636521-1684464782140-25.png"  style="zoom:67%;" /></p>
<h1 id="laplacian算子-基于零穿越"><a href="https://baike.baidu.com/item/%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E7%AE%97%E5%AD%90/7261323"><code>Laplacian算子</code></a>-基于零穿越</h1>
<p><code>Laplacian</code>是利用二阶导数来检测边缘 。 因为图像是2维, 我们需要在两个方向求导，如下式所示： <span class="math display">\[
\Delta src=\frac{\partial^2src}{\partial x^2}+\frac{\partial^2src}{\partial y^2}
\]</span></p>
<p>不连续函数的二阶导数是： <span class="math display">\[
f&#39;&#39;(x)=f&#39;(x+1)-f&#39;(x)=f(x+1)+f(x-1)-2f(x)
\]</span> 使用的卷积核是： <span class="math display">\[
kernel=\left[\begin{matrix}0&amp;1&amp;0\\1&amp;-4&amp;1\\0&amp;1&amp;0\\\end{matrix}\right]
\]</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">laplacian = cv2.Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>src：需要处理的图像，</li>
<li>ddepth：图像的深度，-1表示采用的是原图像相同的深度，目标图像的深度必须大于等于原图像的深度；</li>
<li>ksize：算子的大小，即卷积核的大小</li>
</ul>
<h3 id="示例代码-5">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/horse.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 2 laplacian转换</span></span><br><span class="line">result = cv.Laplacian(img,cv.CV_16S)</span><br><span class="line">Scale_abs = cv.convertScaleAbs(result)</span><br><span class="line"><span class="comment"># 3 图像展示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img,cmap=plt.cm.gray),plt.title(<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(Scale_abs,cmap = plt.cm.gray),plt.title(<span class="string">&#x27;Laplacian检测后结果&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929145507862.png"  style="zoom:67%;" /></p>
<h1 id="canny算子"><a href="https://baike.baidu.com/item/Canny%E7%AE%97%E5%AD%90/8821789"><code>Canny算子</code></a></h1>
<p>Canny 边缘检测算法是 John F. Canny 于 1986年提出的，被认为是最优的边缘检测算法。</p>
<ol type="1">
<li><p>去除噪声</p>
<ul>
<li>由于边缘检测很容易受到噪声的影响，所以首先使用<span class="math inline">\(5\times5\)</span>高斯平滑滤波器去除噪声，</li>
</ul></li>
<li><p>计算图像梯度</p>
<ul>
<li><p>对平滑后的图像使用<code>Sobel算子</code>计算水平方向和竖直方向的一阶导数<span class="math inline">\(G_x,G_y\)</span>。</p></li>
<li><p>根据这两幅梯度图找到边界的梯度和方向，公式如下: <span class="math display">\[
Edge_Gradient(G)=\sqrt{G_x^2+G_y^2}
\]</span></p>
<p><span class="math display">\[
Angle(\theta)=\tan^{-1}(\frac{G_y}{G_x})
\]</span></p></li>
<li><p>如果某个像素点是边缘，则其梯度方向总是垂直于边缘。梯度方向被归为四类：垂直，水平，和两个对角线方向。</p></li>
</ul></li>
<li><p>非极大值抑制</p>
<ul>
<li>在获得梯度的方向和大小之后，对整幅图像进行扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。</li>
<li>A点位于图像的边缘，在其梯度变化方向，选择像素点B和C，用来检验A点的梯度是否为极大值，若为极大值，则进行保留，否则A点被抑制，最终的结果是具有细边的二进制图像。如下图所示：</li>
</ul>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929153926063.png"  style="zoom:67%;" /></p></li>
<li><p>滞后阈值</p>
<ul>
<li><p>现在要确定真正的边界。 我们设置两个阈值： <code>minVal</code>和<code>maxVal</code>。 当图像的灰度梯度高于<code>maxVal</code>时被认为是真的边界， 低于<code>minVal</code>的边界会被抛弃。如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929155208751.png"  style="zoom:67%;" /></p></li>
<li><p>如上图所示，A高于阈值<code>maxVal</code>所以是真正的边界点，C虽然低于<code>maxVal</code>但高于<code>minVal</code>并且与A相连，所以也被认为是真正的边界点。而B就会被抛弃，因为低于<code>maxVal</code>而且不与真正的边界点相连。</p></li>
</ul></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">canny = cv2.Canny(image, threshold1, threshold2)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>image：灰度图，</li>
<li>threshold1: minval，较小的阈值将间断的边缘连接起来</li>
<li>threshold2: maxval，较大的阈值检测图像中明显的边缘</li>
</ul>
<h3 id="示例代码-6">示例代码：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像读取</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/horse.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 2 Canny边缘检测</span></span><br><span class="line">lowThreshold = <span class="number">0</span></span><br><span class="line">max_lowThreshold = <span class="number">100</span></span><br><span class="line">canny = cv.Canny(img, lowThreshold, max_lowThreshold) </span><br><span class="line"><span class="comment"># 3 图像展示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img,cmap=plt.cm.gray),plt.title(<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(canny,cmap = plt.cm.gray),plt.title(<span class="string">&#x27;Canny检测后结果&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190929160959357.png" style="zoom:67%;" /></p>
<h1 id="模版匹配和霍夫变换">模版匹配和霍夫变换</h1>
<h2 id="模板匹配">模板匹配</h2>
<p>所谓的模板匹配，就是在给定的图片中查找和模板最相似的区域，该算法的输入包括模板和图片，然后按照滑窗的思路不断的移动模板图片，计算其与图像中对应区域的匹配度，最终将匹配度最高的区域选择为最终的结果。</p>
<ol type="1">
<li>准备两幅图像
<ul>
<li>原图像<span class="math inline">\(I\)</span>：在这幅图中，找到与模板相匹配的区域</li>
<li>模板<span class="math inline">\(T\)</span>：与原图像<span class="math inline">\(I\)</span>进行比对的图像块</li>
</ul></li>
<li>滑动模板图像和原图像进行比对
<ul>
<li>将模板块每次移动一个像素 (从左往右，从上往下)，在每一个位置，都计算与模板图像的相似程度。</li>
</ul></li>
<li>对于每一个位置将计算的相似结果保存在结果矩阵<span class="math inline">\(R\)</span>中。
<ul>
<li>如果输入图像的大小为<span class="math inline">\((W\times H)\)</span>且模板图像的大小为<span class="math inline">\((w\times h)\)</span>，则输出矩阵<span class="math inline">\(R\)</span>的大小为<span class="math inline">\((W-w+1,H-h+1)\)</span>，将<span class="math inline">\(R\)</span>显示为图像。</li>
</ul></li>
<li>获得上述图像后，查找最大值所在的位置，那么该位置对应的区域就被认为是最匹配的。对应的区域就是以该点为顶点，长宽和模板图像一样大小的矩阵。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = cv.matchTemplate(img,template,method)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img：要进行模板匹配的图像</li>
<li>Template：模板</li>
<li>method：实现模板匹配的算法，主要有：
<ol type="1">
<li>平方差匹配(CV_TM_SQDIFF)：利用模板与图像之间的平方差进行匹配，最好的匹配是0，匹配越差，匹配的值越大。</li>
<li>相关匹配(CV_TM_CCORR)：利用模板与图像间的乘法进行匹配，数值越大表示匹配程度较高，越小表示匹配效果差。</li>
<li>利用相关系数匹配(CV_TM_CCOEFF)：利用模板与图像间的相关系数匹配，1表示完美的匹配，-1表示最差的匹配。</li>
</ol></li>
</ul>
<p>完成匹配后，使用<code>cv.minMaxLoc()</code>方法查找最大值所在的位置即可。如果使用平方差作为比较方法，则最小值位置是最佳匹配位置。</p>
<h3 id="示例代码-7">示例代码：</h3>
<p>载入要搜索的图像和模板，图像如下所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/wulin2-1684485180064-5.jpeg"  style="zoom:67%;" /></p>
<p>模板如下所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/wulin-0430810-1684485193472-7.jpeg"  style="zoom:67%;" /></p>
<p>通过<code>matchTemplate</code>实现模板匹配，使用<code>minMaxLoc</code>定位最匹配的区域，并用矩形标注最匹配的区域。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像和模板读取</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/wulin2.jpeg&#x27;</span>)</span><br><span class="line">template = cv.imread(<span class="string">&#x27;./image/wulin.jpeg&#x27;</span>)</span><br><span class="line">h,w,l = template.shape</span><br><span class="line"><span class="comment"># 2 模板匹配</span></span><br><span class="line"><span class="comment"># 2.1 模板匹配</span></span><br><span class="line">res = cv.matchTemplate(img, template, cv.TM_CCORR)</span><br><span class="line"><span class="comment"># 2.2 返回图像中最匹配的位置，确定左上角的坐标，并将匹配位置绘制在图像上</span></span><br><span class="line">min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)</span><br><span class="line"><span class="comment"># 使用平方差时最小值为最佳匹配位置</span></span><br><span class="line"><span class="comment"># top_left = min_loc</span></span><br><span class="line">top_left = max_loc</span><br><span class="line">bottom_right = (top_left[<span class="number">0</span>] + w, top_left[<span class="number">1</span>] + h)</span><br><span class="line">cv.rectangle(img, top_left, bottom_right, (<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;匹配结果&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007144614688-1684485615344-9.png"  style="zoom:67%;" /></p>
<p><strong>拓展：</strong>模板匹配不适用于尺度变换，视角变换后的图像，这时我们就要使用关键点匹配算法，比较经典的关键点检测算法包括SIFT和SURF等，主要的思路是首先通过关键点检测算法获取模板和测试图片中的关键点；然后使用关键点匹配算法处理即可，这些关键点可以很好的处理尺度变化、视角变换、旋转变化、光照变化等，具有很好的不变性。</p>
<h2 id="霍夫变换">霍夫变换</h2>
<p>霍夫变换常用来提取图像中的直线和圆等几何形状。在笛卡尔坐标系中，一条直线由两个点<span class="math inline">\(A=(x_1,y_1)\)</span>和<span class="math inline">\(B(x2，y_2)\)</span>确定，如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007153126537.png"  style="zoom:67%;" /></p>
<p>将直线<span class="math inline">\(y=kx+q\)</span>可写成关于<span class="math inline">\((k,q)\)</span>的函数表达式： <span class="math display">\[
\begin{cases}
q=-kx_1+y_1\\
q=-kx_2+y_2
\end{cases}
\]</span> 对应的变换通过图形直观的表示如下：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007154123721.png"  style="zoom:67%;" /></p>
<p>变换后的空间我们叫做霍夫空间。即：<strong>笛卡尔坐标系中的一条直线，对应于霍夫空间中的一个点</strong>。反过来，同样成立，霍夫空间中的一条线，对应于笛卡尔坐标系中一个点，如下所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007154350195.png"  style="zoom:67%;" /></p>
<p>我们再来看下<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>两个点，对应于霍夫空间的情形：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007154546905.png"  style="zoom:67%;" /></p>
<p>在看下三点共线的情况：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007160434136.png"  style="zoom:67%;" /></p>
<p>可以看出如果<strong>在笛卡尔坐标系的点共线，那么这些点在霍夫空间中对应的直线交于一点</strong>。</p>
<p>如果不止存在一条直线时，如下所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007160932077.png"  style="zoom:67%;" /></p>
<p>我们选择尽可能多的直线汇成的点，上图中三条直线汇成的<span class="math inline">\(A\)</span>、<span class="math inline">\(B\)</span>两点，将其对应回笛卡尔坐标系中的直线：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007161219204.png"  style="zoom:67%;" /></p>
<p>到这里我们似乎已经完成了霍夫变换的求解。但如果像下图这种情况时：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007161417485.png"  style="zoom:67%;" /></p>
<p>上图中的直线是<span class="math inline">\(x=2\)</span>，那<span class="math inline">\((k,q)\)</span>怎么确定呢？为了解决这个问题，考虑将笛卡尔坐标系转换为极坐标。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007165431682.png"  style="zoom:67%;" /></p>
<p>在极坐标下是一样的，极坐标中的点对应于霍夫空间的线，这时的霍夫空间不在是参数<span class="math inline">\((k,q)\)</span>的空间，而是<span class="math inline">\((\rho,\theta)\)</span>的空间，<span class="math inline">\(\rho\)</span>是原点到直线的垂直距离，<span class="math inline">\(\theta\)</span>表示直线的垂线与横轴顺时针方向的夹角，垂直线的角度为<span class="math inline">\(0^\circ\)</span>，水平线的角度是<span class="math inline">\(180^\circ\)</span>。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007163203594.png"  style="zoom:67%;" /></p>
<p>只要求得霍夫空间中的交点的位置，即可得到原坐标系下的直线。</p>
<ol type="1">
<li>假设有一个大小为<span class="math inline">\(100\times100\)</span>的图片，首先创建一个<span class="math inline">\(2D\)</span>数组(累加器)，初始化所有值为0，行表示<span class="math inline">\(\rho\)</span>，列表示$$。若角度的精度为<span class="math inline">\(1^\circ\)</span>，那就需要180列。对于<span class="math inline">\(\rho\)</span>，最大值为图片对角线的距离，如果精度要达到像素级别，行数应该与图像的对角线的距离相等。</li>
<li>取直线上的第一个点<span class="math inline">\((x,y)\)</span>，将其带入直线在极坐标中的公式中，然后遍历<span class="math inline">\(\theta\)</span>的取值<span class="math inline">\((0,1,2,\cdots,180)\)</span>，分别求出对应的<span class="math inline">\(\rho\)</span>值，如果这个数值在<strong>累加器</strong>中存在相应的位置，则在该位置上加1。</li>
<li>取直线上的第二个点，重复上述步骤，更新累加器中的值。对图像中的直线上的每个点都直线以上步骤，每次更新累加器中的值。</li>
<li>搜索累加器中的最大值，并找到其对应的<span class="math inline">\((\rho,\theta)\)</span>，就可将图像中的直线表示出来。</li>
</ol>
<p><img src="/imgs/$%7Bfiilename%7D/image70-0440438.gif"  style="zoom: 80%;" /></p>
<h2 id="霍夫线检测">霍夫线检测</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv.HoughLines(img, rho, theta, threshold)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>img：检测的图像<strong>要求是二值化的图像</strong>，所以在调用霍夫变换之前首先要进行二值化，或者进行Canny边缘检测。</p></li>
<li><p>rho、theta：<span class="math inline">\(\rho\)</span> 和<span class="math inline">\(\theta\)</span>的精确度。</p></li>
<li><p>threshold：阈值，只有累加器中的值高于该阈值时才被认为是直线。</p></li>
</ul>
<h3 id="示例代码-8">示例代码</h3>
<p>检测下述图像中的直线：</p>
<p><img src="/imgs/$%7Bfiilename%7D/rili.jpg" style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1.加载图片，转为二值图</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/rili.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">edges = cv.Canny(gray, <span class="number">50</span>, <span class="number">150</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.霍夫直线变换</span></span><br><span class="line">lines = cv.HoughLines(edges, <span class="number">0.8</span>, np.pi / <span class="number">180</span>, <span class="number">150</span>)</span><br><span class="line"><span class="comment"># 3.将检测的线绘制在图像上（注意是极坐标噢）</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">    rho, theta = line[<span class="number">0</span>]</span><br><span class="line">    a = np.cos(theta)</span><br><span class="line">    b = np.sin(theta)</span><br><span class="line">    x0 = a * rho</span><br><span class="line">    y0 = b * rho</span><br><span class="line">    x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (-b))</span><br><span class="line">    y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span> * (a))</span><br><span class="line">    x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (-b))</span><br><span class="line">    y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span> * (a))</span><br><span class="line">    cv.line(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 4. 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;霍夫变换线检测&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191007184301611.png"  style="zoom: 20%;" /></p>
<h2 id="霍夫圆检测">霍夫圆检测</h2>
<p>圆的表示式是：<span class="math inline">\((x-a)^2+(y-b)^2=r\)</span>，其中圆心坐标为<span class="math inline">\((a,b)\)</span>，半径为<span class="math inline">\(r\)</span>，因此标准的霍夫圆检测就是在这三个参数组成的三维空间累加器上进行圆形检测，此时的效率很低。</p>
<p>所以<code>OpenCV</code>中使用<strong>霍夫梯度法</strong>进行圆形的检测，霍夫梯度法是霍夫变换的改进，它的目的是减小霍夫空间的维度，提高效率。</p>
<p>霍夫梯度法将霍夫圆检测范围两个阶段，第一阶段检测圆心，第二阶段利用圆心推导出圆半径。</p>
<ol type="1">
<li>圆心检测的原理：圆心是圆周法线的交汇处，设置一个阈值，在某点的相交的直线的条数大于这个阈值就认为该交汇点为圆心。</li>
<li>圆半径确定原理：圆心到圆周上的距离（半径）是相同的，确定一个阈值，只要相同距离的数量大于该阈值，就认为该距离是该圆心的半径。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">circles = cv.HoughCircles(image, method, dp, minDist, param1=<span class="number">100</span>, param2=<span class="number">100</span>, minRadius=<span class="number">0</span>,maxRadius=<span class="number">0</span> )</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>image：输入图像，应输入灰度图像</li>
<li>method：使用霍夫变换圆检测的算法，它的参数是CV_HOUGH_GRADIENT</li>
<li>dp：霍夫空间的分辨率，dp=1时表示霍夫空间与输入图像空间的大小一致，dp=2时霍夫空间是输入图像空间的一半，以此类推。</li>
<li>minDist：为圆心之间的最小距离，如果检测到的两个圆心之间距离小于该值，则认为它们是同一个圆心。</li>
<li>param1：边缘检测时使用Canny算子的高阈值，低阈值是高阈值的一半。</li>
<li>param2：检测圆心和确定半径时所共有的阈值。</li>
<li>minRadius：所检测到的圆半径的最小值。</li>
<li>maxRadius：所检测到的圆半径的最大值。</li>
</ul>
<p>返回：</p>
<ul>
<li>circles：输出圆向量，包括三个浮点型的元素（圆心横坐标，圆心纵坐标和圆半径）</li>
</ul>
<h3 id="示例代码-9">示例代码</h3>
<p>由于霍夫圆检测对噪声比较敏感，所以首先对图像进行中值滤波。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像，并转换为灰度图</span></span><br><span class="line">planets = cv.imread(<span class="string">&quot;./image/star.jpeg&quot;</span>)</span><br><span class="line">gay_img = cv.cvtColor(planets, cv.COLOR_BGRA2GRAY)</span><br><span class="line"><span class="comment"># 2 进行中值模糊，去噪点</span></span><br><span class="line">img = cv.medianBlur(gay_img, <span class="number">7</span>)  </span><br><span class="line"><span class="comment"># 3 霍夫圆检测</span></span><br><span class="line">circles = cv.HoughCircles(img, cv.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">200</span>, param1=<span class="number">100</span>, param2=<span class="number">30</span>, minRadius=<span class="number">0</span>, maxRadius=<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 4 将检测结果绘制在图像上</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>, :]:  <span class="comment"># 遍历矩阵每一行的数据</span></span><br><span class="line">    <span class="comment"># 绘制圆形</span></span><br><span class="line">    cv.circle(planets, (i[<span class="number">0</span>], i[<span class="number">1</span>]), i[<span class="number">2</span>], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 绘制圆心</span></span><br><span class="line">    cv.circle(planets, (i[<span class="number">0</span>], i[<span class="number">1</span>]), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 5 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.imshow(planets[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;霍夫变换圆检测&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191008105125382.png" style="zoom: 33%;" /></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV图像处理(上)</title>
    <url>/OpenCV/OpenCV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="几何变换">几何变换</h1>
<h2 id="图像缩放">图像缩放</h2>
<p>缩放是对图像的大小进行调整，即使图像放大或缩小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.resize(src,dsize,fx=<span class="number">0</span>,fy=<span class="number">0</span>,interpolation=cv2.INTER_LINEAR)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>src : 输入图像</li>
<li>dsize: 绝对尺寸，直接指定调整后图像的大小</li>
<li>fx,fy: 相对尺寸，将dsize设置为None，然后将fx和fy设置为比例因子即可</li>
<li>interpolation：插值方法，</li>
</ul>
<span id="more"></span>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191016161502727-1684329818370-10.png" style="zoom:67%;" /></p>
<h3 id="示例代码">示例代码</h3>
<p>将图像分别以绝对尺度的方式放大，以相对尺寸的方式缩小。</p>
<p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="comment"># 1. 读取图片</span></span><br><span class="line">img1 = cv.imread(<span class="string">&quot;./image/dog.jpeg&quot;</span>)</span><br><span class="line"><span class="comment"># 2.图像缩放</span></span><br><span class="line"><span class="comment"># 2.1 绝对尺寸</span></span><br><span class="line">rows,cols = img1.shape[:<span class="number">2</span>]</span><br><span class="line">res = cv.resize(img1,(<span class="number">2</span>*cols,<span class="number">2</span>*rows),interpolation=cv.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.2 相对尺寸</span></span><br><span class="line">res1 = cv.resize(img1,<span class="literal">None</span>,fx=<span class="number">0.5</span>,fy=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line"><span class="comment"># 3.1 使用opencv显示图像(不推荐)</span></span><br><span class="line">cv.imshow(<span class="string">&quot;orignal&quot;</span>,img1)</span><br><span class="line">cv.imshow(<span class="string">&quot;enlarge&quot;</span>,res)</span><br><span class="line">cv.imshow(<span class="string">&quot;shrink）&quot;</span>,res1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2 使用matplotlib显示图像</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">3</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(res[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;绝对尺度（放大）&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(img1[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">2</span>].imshow(res1[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">&quot;相对尺度（缩小）&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926143500645-1684329980666-12.png"  style="zoom:67%;" /></p>
<h2 id="图像平移">图像平移</h2>
<p>图像平移将图像按照指定方向和距离，移动到相应的位置。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.warpAffine(img,M,dsize)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>img: 输入图像</p></li>
<li><p>M： 2∗3的移动矩阵</p>
<p>对于(x,y)处的像素点，要把它移动到<span class="math inline">\((x+t_x,y+t_y)\)</span>处时，M矩阵应如下设置：</p>
<p><span class="math inline">\(M=\left[\begin{matrix}1&amp;0&amp;t_x\\0&amp;1&amp;t_y\\&amp;&amp;\end{matrix}\right]\)</span></p>
<p><strong>注意：</strong>将<span class="math inline">\(M\)</span>设置为<code>np.float32</code>类型的<code>Numpy</code>数组。</p></li>
<li><p>dsize: 输出图像的大小</p>
<p><strong>注意：</strong>输出图像的大小，它应该是(宽度，高度)的形式。请记住,width=列数，height=行数。</p></li>
</ul>
<h3 id="示例代码-1">示例代码</h3>
<p>将图像的像素点移动(50,100)的距离。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1. 读取图像</span></span><br><span class="line">img1 = cv.imread(<span class="string">&quot;./image/image2.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 图像平移</span></span><br><span class="line">rows,cols = img1.shape[:<span class="number">2</span>]</span><br><span class="line">M = M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])<span class="comment"># 平移矩阵</span></span><br><span class="line">dst = cv.warpAffine(img1,M,(cols,rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 图像显示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img1[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(dst[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;平移后结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926151127550-1684330295827-14.png"  style="zoom:67%;" /></p>
<h2 id="图像旋转">图像旋转</h2>
<p>图像旋转是指图像按照某个位置转动一定角度的过程，旋转中图像仍保持这原始尺寸。</p>
<p>假设图像逆时针旋转<span class="math inline">\(\theta\)</span>，则根据坐标转换可得:</p>
<p><span class="math display">\[
\left[\begin{matrix}x&#39;&amp;y&#39;&amp;1\end{matrix}\right]=\left[\begin{matrix}x&amp;y&amp;1\end{matrix}\right]\left[\begin{matrix}\cos\theta&amp;-\sin\theta&amp;0\\\sin\theta&amp;\cos\theta&amp;0\\0&amp;0&amp;1\end{matrix}\right]
\]</span> 假设在旋转的时候是以旋转中心为坐标原点的，旋转结束后还需要将坐标原点移到图像左上角，也就是还要进行一次变换。 <span class="math display">\[
\left[\begin{matrix}x&#39;&#39;&amp;y&#39;&#39;&amp;1\end{matrix}\right]=\left[\begin{matrix}x&#39;&amp;y&#39;&amp;1\end{matrix}\right]\left[\begin{matrix}1&amp;0&amp;0\\0&amp;-1&amp;0\\left&amp;top&amp;1\end{matrix}\right]\\
=\left[\begin{matrix}x&#39;&amp;y&#39;&amp;1\end{matrix}\right]\left[\begin{matrix}\cos\theta&amp;-\sin\theta&amp;0\\\sin\theta&amp;\cos\theta&amp;0\\0&amp;0&amp;1\end{matrix}\right]\left[\begin{matrix}1&amp;0&amp;0\\0&amp;-1&amp;0\\left&amp;top&amp;1\end{matrix}\right]
\]</span> 在<code>OpenCV</code>中图像旋转首先根据旋转角度和旋转中心获取旋转矩阵，然后根据旋转矩阵进行变换，即可实现任意角度和任意中心的旋转效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.getRotationMatrix2D(center, angle, scale)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>center：旋转中心</li>
<li>angle：旋转角度</li>
<li>scale：缩放比例</li>
</ul>
<p>返回：</p>
<ul>
<li>M：旋转矩阵</li>
</ul>
<p>调用<code>cv.warpAffine</code>完成图像的旋转</p>
<h3 id="示例代码-2">示例代码</h3>
<p>将图像以中心点旋转<span class="math inline">\(90^\circ\)</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&quot;./image/image2.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 图像旋转</span></span><br><span class="line">rows,cols = img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 2.1 生成旋转矩阵</span></span><br><span class="line">M = cv.getRotationMatrix2D((cols/<span class="number">2</span>,rows/<span class="number">2</span>),<span class="number">90</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 2.2 进行旋转变换</span></span><br><span class="line">dst = cv.warpAffine(img,M,(cols,rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 图像展示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img1[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(dst[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;旋转后结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926152854704.png"  style="zoom:67%;" /></p>
<h2 id="仿射变换">仿射变换</h2>
<p><a href="https://baike.baidu.com/item/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/4289056"><code>仿射变换</code></a>是指在几何中，一个向量空间进行一次线性变换并接上一个平移，变换为另一个向量空间。</p>
<p>图像的仿射变换，如下图所示，原始图像的点A，B和C与仿射图像三个点一一映射, 仍然形成三角形, 但形状已经大大改变，通过这样两组三点（感兴趣点）求出仿射变换， 接下来我们就能把仿射变换应用到图像中所有的点中，就完成了图像的仿射变换。</p>
<p><img src="/imgs/$%7Bfiilename%7D/images.jpeg"  style="zoom: 80%;" /></p>
<p>在<code>OpenCV</code>中，仿射变换的矩阵是一个2×3的矩阵 <span class="math display">\[
M=
\left[\begin{matrix}A&amp;B\end{matrix}\right]=
\left[\begin{matrix}a_{00}\quad a_{01}\quad b_0\\\underbrace{a_{10}\quad a_{11}}_A\quad b_1\end{matrix}\right]
\]</span> 其中子矩阵<span class="math inline">\(A\)</span>是线性变换矩阵，子矩阵<span class="math inline">\(B\)</span>是平移项，对于图像上的任一位置<span class="math inline">\((x,y)\)</span>，仿射变换执行的是如下的操作： <span class="math display">\[
T_{affine}=A
\left[\begin{matrix}x\\y\end{matrix}\right]+B=M
\left[\begin{matrix}x\\y\\1\end{matrix}\right]
\]</span> <strong>注意：</strong>对于图像而言，宽度方向是x，高度方向是y，坐标的顺序和图像像素对应下标一致。所以原点的位置不是左下角而是左上角，y的方向也不是向上，而是向下。</p>
<p>在仿射变换中，原图中所有的平行线在结果图像中同样平行。为了创建这个矩阵我们需要从原图像中找到三个点以及他们在输出图像中的位置。然后<code>cv2.getAffineTransform</code> 会创建一个$ 2$ 的矩阵，最后这个矩阵会被传给函数<code>cv2.warpAffine</code>。</p>
<h3 id="示例代码-3">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像读取</span></span><br><span class="line">img = cv.imread(<span class="string">&quot;./image/image2.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 仿射变换</span></span><br><span class="line">rows,cols = img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 2.1 创建变换矩阵</span></span><br><span class="line">pts1 = np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">100</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span><br><span class="line">M = cv.getAffineTransform(pts1,pts2)</span><br><span class="line"><span class="comment"># 2.2 完成仿射变换</span></span><br><span class="line">dst = cv.warpAffine(img,M,(cols,rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(dst[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;仿射后结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926161027173.png"  style="zoom:67%;" /></p>
<h2 id="透射变换">透射变换</h2>
<p><a href="https://baike.baidu.com/item/%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/8746342"><code>透射变换</code></a>是视角变化的结果，是指利用透视中心、像点、目标点三点共线的条件，按透视旋转定律使承影面（透视面）绕迹线（透视轴）旋转某一角度，破坏原有的投影光线束，仍能保持承影面上投影几何图形不变的变换。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191023130051717.png" style="zoom:67%;" /></p>
<p>它的本质是将图像投影到一个新的视平面，其通用变换公式为：</p>
<p><span class="math display">\[
\left[\begin{matrix}x&#39;&amp;y&#39;&amp;z&#39;\end{matrix}\right]=\left[\begin{matrix}u&amp;v&amp;w\end{matrix}\right]\left[\begin{matrix}a_{00}\quad a_{01}\quad a_{02}\\a_{10}\quad a_{11}\quad a_{12}\\\underbrace{a_{20}\quad a_{21}\quad a_{22}}_T\end{matrix}\right]
\]</span> 其中<span class="math inline">\((u,v)\)</span>是原始图像的像素坐标，<span class="math inline">\(w\)</span>取值为1，<span class="math inline">\((x=x&#39;/z&#39;,y=y&#39;/z&#39;)\)</span>是透射变换后的结果。<span class="math inline">\(T\)</span>矩阵称为透视变换矩阵， <span class="math display">\[
T=
\left[\begin{matrix}a_{00}&amp;a_{01}&amp;a_{02}\\a_{10}&amp;a_{11}&amp;a_{12}\\a_{20}&amp; a_{21}&amp; a_{22}\end{matrix}\right]=
\left[\begin{matrix}T_{1}&amp;T_{2}\\T_{3}&amp;a_{22}\end{matrix}\right]
\]</span> 其中：<span class="math inline">\(T1\)</span>是图像进行线性变换，<span class="math inline">\(T2\)</span>对图像进行平移，<span class="math inline">\(T3\)</span>表示对图像进行投射变换，一般<span class="math inline">\(a_{22}\)</span>取为1。</p>
<p>在<code>opencv</code>中，先找到四个点(其中任意三个点不共线)，然后获取透射变换矩阵<span class="math inline">\(T\)</span>，再进行透射变换。通过函数<code>cv.getPerspectiveTransform</code>找到透射变换矩阵，将<code>cv.warpPerspective</code>应用于此<code>3x3</code>变换矩阵。</p>
<h3 id="示例代码-4">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&quot;./image/image2.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 2 透射变换</span></span><br><span class="line">rows,cols = img.shape[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 2.1 创建变换矩阵</span></span><br><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span><br><span class="line">pts2 = np.float32([[<span class="number">100</span>,<span class="number">145</span>],[<span class="number">300</span>,<span class="number">100</span>],[<span class="number">80</span>,<span class="number">290</span>],[<span class="number">310</span>,<span class="number">300</span>]])</span><br><span class="line"></span><br><span class="line">T = cv.getPerspectiveTransform(pts1,pts2)</span><br><span class="line"><span class="comment"># 2.2 进行变换</span></span><br><span class="line">dst = cv.warpPerspective(img,T,(cols,rows))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(dst[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;透射后结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926162913916.png"  style="zoom:67%;" /></p>
<h2 id="图像金字塔">图像金字塔</h2>
<p><a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E9%87%91%E5%AD%97%E5%A1%94/306277">图像金字塔</a>是图像多尺度表达的一种，是一种以多分辨率来解释图像的有效但概念简单的结构。一幅图像的图像金字塔是一系列以金字塔形状（自下而上）逐步降低，且来源于同一张原始图的图像分辨率集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。我们将一层一层的图像比喻成金字塔，层级越高，则图像越小，分辨率越低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.pyrUp(img)       <span class="comment">#对图像进行上采样</span></span><br><span class="line">cv.pyrDown(img)        <span class="comment">#对图像进行下采样</span></span><br></pre></td></tr></table></figure>
<h3 id="示例代码-5">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像读取</span></span><br><span class="line">img = cv.imread(<span class="string">&quot;./image/image2.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 2 进行图像采样</span></span><br><span class="line">up_img = cv.pyrUp(img)  <span class="comment"># 上采样操作</span></span><br><span class="line">img_1 = cv.pyrDown(img)  <span class="comment"># 下采样操作</span></span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;enlarge&#x27;</span>, up_img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;original&#x27;</span>, img)</span><br><span class="line">cv.imshow(<span class="string">&#x27;shrink&#x27;</span>, img_1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926114816933.png"  style="zoom: 50%;" /></p>
<h1 id="形态学操作">形态学操作</h1>
<p>形态学转换是基于图像形状的一些简单操作。它通常在二进制图像上执行。腐蚀和膨胀是两个基本的形态学运算符。然后它的变体形式如开运算，闭运算，礼帽黑帽等。</p>
<h2 id="连通性">连通性</h2>
<p>在图像中，最小的单位是像素，每个像素周围有8个邻接像素，常见的邻接关系有3种：4邻接、8邻接和D邻接。分别如下图所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926185646667-1684373842950-11.png"  style="zoom: 50%;" /></p>
<ul>
<li>4邻接：像素<span class="math inline">\(p(x,y)\)</span>的4邻域是<code>(x+1,y);(x-1,y);(x,y+1);(x,y-1)</code>，用<span class="math inline">\(N_4(p)\)</span>表示像素p的4邻接</li>
<li>D邻接：像素<span class="math inline">\(p(x,y)\)</span>的D邻域是<code>(x+1,y+1);(x+1,y-1);(x-1,y+1);(x-1,y-1)</code>，用<span class="math inline">\(N_D(p)\)</span>表示像素p的D邻域</li>
<li>8邻接：像素<span class="math inline">\(p(x,y)\)</span>的8邻域是4邻域的点+D邻域的点，用<span class="math inline">\(N_8(p)\)</span>表示像素p的8邻域</li>
</ul>
<p><strong>连通性</strong>是描述区域和边界的重要概念，两个像素连通的两个必要条件是：</p>
<ol type="1">
<li>两个像素的位置是否相邻</li>
<li>两个像素的灰度值是否满足特定的相似性准则(或者是否相等)</li>
</ol>
<p>根据连通性的定义，有4连通、8连通和m连通三种。</p>
<ul>
<li><p>4连通：对于具有值V的像素p和q，如果q在集合<span class="math inline">\(N_4(p)\)</span>中，则称这两个像素是4连通。</p></li>
<li><p>8连通：对于具有值V的像素p和q，如果q在集合<span class="math inline">\(N_8(p)\)</span>中，则称这两个像素是8连通。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190926185504256-1684374493446-13.png"  style="zoom:50%;" /></p></li>
<li><p>m连通：对于具有值V的像素p和q，如果q在集合<span class="math inline">\(N_4(p)\)</span>中或q在集合<span class="math inline">\(N_D(p)\)</span>中，并且<span class="math inline">\(N_4(p)\)</span>与<span class="math inline">\(N_4(q)\)</span>的交集为空(没有值V的像素)，则称这两个像素是m连通。</p></li>
</ul>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927101630929-1684374613256-15.png"  style="zoom: 90%;" /></p>
<h2 id="腐蚀和膨胀">腐蚀和膨胀</h2>
<p>腐蚀和膨胀都是针对白色部分（高亮部分）而言的。</p>
<ol type="1">
<li>腐蚀是原图中的高亮区域被蚕食，效果图拥有比原图更小的高亮区域；腐蚀是求局部最小值的操作，作用是消除物体边界点，使目标缩小，可以消除小于结构元素的噪声点。</li>
<li>膨胀是使图像中高亮部分扩张，效果图拥有比原图更大的高亮区域；膨胀是求局部最大值的操作，作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的孔洞。</li>
</ol>
<p><strong>腐蚀的具体操作是：</strong>用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为1，则该像素为1，否则为0。如下图所示，结构A被结构B腐蚀后</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927105316401-1684375461882-17.png"  style="zoom: 67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.erode(img,kernel,iterations)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img：要处理的图像</li>
<li>kernel：核结构</li>
<li>iterations：腐蚀的次数，默认是1</li>
</ul>
<p><strong>膨胀的具体操作是：</strong>用结构元素中的每一个像素与其覆盖的像素做“与”操作，如果都为0，则该像素为0，否则为1。如下图所示，结构A被结构B腐蚀后</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927110711458-1684375683181-19.png"  style="zoom:67%;" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.dilate(img,kernel,iterations)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>img：要处理的图像</p></li>
<li><p>kernel：核结构</p></li>
<li><p>iterations：腐蚀的次数，默认是1</p></li>
</ul>
<h3 id="示例代码-6">示例代码</h3>
<p>使用一个<span class="math inline">\(5\times5\)</span>的卷积核实现腐蚀和膨胀的运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&quot;./image/image3.png&quot;</span>)</span><br><span class="line"><span class="comment"># 2 创建核结构</span></span><br><span class="line">kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 图像腐蚀和膨胀</span></span><br><span class="line">erosion = cv.erode(img, kernel) <span class="comment"># 腐蚀</span></span><br><span class="line">dilate = cv.dilate(img,kernel) <span class="comment"># 膨胀</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4 图像展示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">3</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img)</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(erosion)</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;腐蚀后结果&quot;</span>)</span><br><span class="line">axes[<span class="number">2</span>].imshow(dilate)</span><br><span class="line">axes[<span class="number">2</span>].set_title(<span class="string">&quot;膨胀后结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927151844574-1684375808449-21.png" style="zoom:67%;" /></p>
<h2 id="开闭运算">开、闭运算</h2>
<p>开运算和闭运算是将腐蚀和膨胀按照一定的次序进行处理。 但这两者并不是可逆的，即先开后闭并不能得到原来的图像。</p>
<ol type="1">
<li><p>开运算是先腐蚀后膨胀，作用是消除噪点，去除小的干扰块，而不影响原来的图像。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927142206425-1684376263939-23.png" style="zoom: 67%;" /></p></li>
<li><p>闭运算是先膨胀后腐蚀，作用是消除闭合物体里面的孔洞，填充闭合区域。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927142923777-1684376306646-25.png"  style="zoom:67%;" /></p></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.morphologyEx(img, op, kernel)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img：要处理的图像</li>
<li>op: 处理方式：若进行开运算，则设为cv.MORPH_OPEN，若进行闭运算，则设为cv.MORPH_CLOSE</li>
<li>Kernel：核结构</li>
</ul>
<h3 id="示例代码-7">示例代码</h3>
<p>使用<span class="math inline">\(10\times10\)</span>的卷积核实现开、闭运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img1 = cv.imread(<span class="string">&quot;./image/image5.png&quot;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&quot;./image/image6.png&quot;</span>)</span><br><span class="line"><span class="comment"># 2 创建核结构</span></span><br><span class="line">kernel = np.ones((<span class="number">10</span>, <span class="number">10</span>), np.uint8)</span><br><span class="line"><span class="comment"># 3 图像的开闭运算</span></span><br><span class="line">cvOpen = cv.morphologyEx(img1,cv.MORPH_OPEN,kernel) <span class="comment"># 开运算</span></span><br><span class="line">cvClose = cv.morphologyEx(img2,cv.MORPH_CLOSE,kernel)<span class="comment"># 闭运算</span></span><br><span class="line"><span class="comment"># 4 图像展示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].imshow(img1)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].imshow(cvOpen)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].set_title(<span class="string">&quot;开运算结果&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].imshow(img2)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].imshow(cvClose)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].set_title(<span class="string">&quot;闭运算结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927153400823-1684376402734-27.png"  style="zoom:67%;" /></p>
<h2 id="礼帽和黑帽">礼帽和黑帽</h2>
<ol type="1">
<li>礼帽运算是原图像与开运算的结果图之差<span class="math inline">\(dst=tophat(src,element)=src-open(src,element)\)</span>，
<ul>
<li>因为开运算带来的结果是放大了裂缝或者局部低亮度的区域。</li>
<li>礼帽运算后的效果图突出了比原图轮廓周围的区域更明亮的区域，这一操作和选择的核的大小相关。</li>
<li>作用：用来分离比邻近点亮一些的斑块。当一幅图像具有大幅的背景的时候，而微小物品比较有规律的情况下，可以使用礼帽运算进行背景提取。</li>
</ul></li>
<li>黑帽运算是闭运算的结果图与原图像之差<span class="math inline">\(dst=blackhat(src,element)=close(src,element)-src\)</span>，
<ul>
<li>黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，</li>
<li>作用：用来分离比邻近点暗一些的斑块。</li>
</ul></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.morphologyEx(img, op, kernel)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>img：要处理的图像</p></li>
<li><p>op：处理方式：</p></li>
<li><p>Kernel：核结构</p></li>
</ul>
<h3 id="示例代码-8">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img1 = cv.imread(<span class="string">&quot;./image/image5.png&quot;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&quot;./image/image6.png&quot;</span>)</span><br><span class="line"><span class="comment"># 2 创建核结构</span></span><br><span class="line">kernel = np.ones((<span class="number">10</span>, <span class="number">10</span>), np.uint8)</span><br><span class="line"><span class="comment"># 3 图像的礼帽和黑帽运算</span></span><br><span class="line">cvOpen = cv.morphologyEx(img1,cv.MORPH_TOPHAT,kernel) <span class="comment"># 礼帽运算</span></span><br><span class="line">cvClose = cv.morphologyEx(img2,cv.MORPH_BLACKHAT,kernel)<span class="comment"># 黑帽运算</span></span><br><span class="line"><span class="comment"># 4 图像显示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">2</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>))</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].imshow(img1)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].imshow(cvOpen)</span><br><span class="line">axes[<span class="number">0</span>,<span class="number">1</span>].set_title(<span class="string">&quot;礼帽运算结果&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].imshow(img2)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">0</span>].set_title(<span class="string">&quot;原图&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].imshow(cvClose)</span><br><span class="line">axes[<span class="number">1</span>,<span class="number">1</span>].set_title(<span class="string">&quot;黑帽运算结果&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190927154018177-1684377075287-29.png"  style="zoom:67%;" /></p>
<h1 id="图像平滑">图像平滑</h1>
<p><a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%B9%B3%E6%BB%91/8827890"><code>图像平滑</code></a>从信号处理的角度看就是去除其中的高频信息，保留低频信息。因此可以对图像实施低通滤波。低通滤波可以去除图像中的噪声，对图像进行平滑。根据滤波器的不同可分为均值滤波，高斯滤波，中值滤波， 双边滤波。</p>
<h2 id="图像噪声">图像噪声</h2>
<p>由于图像采集、处理、传输等过程不可避免的会受到噪声的污染，妨碍人们对图像理解及分析处理。常见的图像噪声有高斯噪声、椒盐噪声等。</p>
<h3 id="椒盐噪声">椒盐噪声</h3>
<p><a href="https://baike.baidu.com/item/%E6%A4%92%E7%9B%90%E5%99%AA%E5%A3%B0/3455958"><code>椒盐噪声</code></a>也称为脉冲噪声，是图像中经常见到的一种噪声，它是一种随机出现的白点或者黑点，可能是亮的区域有黑色像素或是在暗的区域有白色像素。</p>
<p>椒盐噪声的成因可能是影像讯号受到突如其来的强烈干扰而产生、类比数位转换器或位元传输错误等。例如失效的感应器导致像素值为最小值，饱和的感应器导致像素值为最大值。</p>
<h3 id="高斯噪声">高斯噪声</h3>
<p><a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0/8587563">高斯噪声</a>是指噪声密度函数服从高斯分布的一类噪声。在数字图像中的高斯噪声的主要来源出现在采集期间， 由于不良照明和/或高温引起的传感器噪声。</p>
<p>高斯随机变量<span class="math inline">\(x\)</span>的概率密度函数 <span class="math display">\[
p(x) = \frac{1}{\sigma\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma^2}}
\]</span> 其中<span class="math inline">\(z\)</span>表示灰度值，<span class="math inline">\(\mu\)</span>表示<span class="math inline">\(x\)</span>的平均值或期望值，<span class="math inline">\(\sigma\)</span>表示<span class="math inline">\(x\)</span>的标准差。标准差的平方<span class="math inline">\(\sigma^2\)</span>称为<span class="math inline">\(x\)</span>的方差。高斯函数的曲线如下图所示。</p>
<p><img src="/imgs/$%7Bfiilename%7D/441dc1bf121e7b13c6376b5839a3cd7c_b.png" style="zoom:67%;" /></p>
<h2 id="均值滤波">均值滤波</h2>
<p>采用<strong>均值滤波模板</strong>对图像噪声进行滤除。令<span class="math inline">\(S_{xy}\)</span>表示中心在<span class="math inline">\((x, y)\)</span>点，尺寸为<span class="math inline">\(m\times n\)</span> 的矩形子图像窗口的坐标组。 均值滤波器可表示为 <span class="math display">\[
\hat{f}=\frac{1}{mn}\sum_{(s,t)\in S_{xy}}g(s,t)
\]</span> 由一个归一化卷积框完成的。它只是用卷积框覆盖区域所有像素的平均值来代替中心元素。</p>
<p>例如，<span class="math inline">\(3\times3\)</span>标准化的均值滤波如下所示： <span class="math display">\[
K=\frac{1}{9}\left[\begin{matrix}1&amp;1&amp;1\\1&amp;1&amp;1\\1&amp;1&amp;1\end{matrix}\right]
\]</span> 均值滤波的优点是算法简单，计算速度较快，缺点是在去噪的同时去除了很多细节部分，将图像变得模糊。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cv.blur(src, ksize, anchor, borderType)</span><br></pre></td></tr></table></figure>
<p>参数:</p>
<ul>
<li>src：输入图像</li>
<li>ksize：卷积核的大小</li>
<li>anchor：默认值 (-1,-1) ，表示核中心</li>
<li>borderType：边界类型</li>
</ul>
<h3 id="示例代码-9">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像读取</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/dogsp.jpeg&#x27;</span>)</span><br><span class="line"><span class="comment"># 2 均值滤波</span></span><br><span class="line">blur = cv.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;均值滤波后结果&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928102258185-1684384223434-35.png"  style="zoom:67%;" /></p>
<h2 id="高斯滤波">高斯滤波</h2>
<p>二维高斯是构建高斯滤波器的基础，其概率分布函数为 <span class="math display">\[
G(x,y) = 
\frac{1}{\sigma_x\sqrt{2\pi}}e^{-\frac{(x-\mu)^2}{2\sigma_y^2}}\frac{1}{\sigma_y\sqrt{2\pi}}e^{-\frac{(y-\mu)^2}{2\sigma_y^2}}=
\frac{1}{2\pi\sigma^2}e^{-\frac{(x^2+y^2)}{2\sigma^2}}
\]</span> 上述公式做了一些取值的处理：我们令<span class="math inline">\(\sigma_x=\sigma_y\)</span>，越接近中心，取值越大，越远离中心，取值越小。计算平滑结果时，将“中心点”作为原点（<span class="math inline">\(\mu=0\)</span>），其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928104118332-1684385364117-37.png"  style="zoom:67%;" /></p>
<p><strong>高斯平滑的流程：</strong></p>
<ul>
<li>确定权重矩阵
<ul>
<li>假定中心点的坐标是（0,0），距离它最近的8个点的坐标（<span class="math inline">\(3\times3\)</span>的卷积核）</li>
</ul></li>
<li>计算权重矩阵，
<ul>
<li>设定<span class="math inline">\(\sigma\)</span>的值，根据高斯概率分布函数<span class="math inline">\(G(x,y)\)</span>计算这9个点，</li>
<li>计算这9个点的总和，</li>
<li>将9个值分别除以权重总和，得到最终的权重矩阵。</li>
</ul></li>
<li>计算高斯模糊
<ul>
<li>假设现有9个像素点，灰度值（0-255）</li>
<li>每个点乘以对应的权重值</li>
<li>将这9个值加起来，就是中心点的高斯模糊的值。</li>
</ul></li>
<li>对所有点重复这个过程，就得到了高斯模糊后的图像。</li>
</ul>
<p>如果原图是彩色图片，对<code>RGB</code>三个通道分别做高斯平滑。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.GaussianBlur(src,ksize,sigmaX,sigmay,borderType)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>src：输入图像</li>
<li>ksize：高斯卷积核的大小</li>
<li>sigmaX：水平方向的标准差</li>
<li>sigmaY：垂直方向的标准差，默认值为0，表示与sigmaX相同</li>
<li>borderType：填充边界类型</li>
</ul>
<h3 id="示例代码-10">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像读取</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/dogGasuss.jpeg&#x27;</span>)</span><br><span class="line"><span class="comment"># 2 高斯滤波</span></span><br><span class="line">blur = cv.GaussianBlur(img,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;高斯滤波后结果&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928111903926-1684386634283-39.png"  style="zoom:67%;" /></p>
<h2 id="中值滤波">中值滤波</h2>
<p>中值滤波是一种典型的非线性滤波技术，基本思想是用像素点邻域灰度值的中值来代替该像素点的灰度值。它对椒盐噪声（salt-and-pepper noise）来说尤其有用，因为它不依赖于邻域内那些与典型值差别很大的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.medianBlur(src, ksize )</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>src：输入图像</li>
<li>ksize：卷积核的大小</li>
</ul>
<h3 id="示例代码-11">示例代码</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 图像读取</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./image/dogsp.jpeg&#x27;</span>)</span><br><span class="line"><span class="comment"># 2 中值滤波</span></span><br><span class="line">blur = cv.medianBlur(img,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 3 图像展示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;原图&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur[:,:,::-<span class="number">1</span>]),plt.title(<span class="string">&#x27;中值滤波后结果&#x27;</span>)</span><br><span class="line">plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190928102319410-1684386742771-41.png" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV基本操作</title>
    <url>/OpenCV/OpenCV%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p><strong>Imgproc（图像处理模块）</strong></p>
<p>图像处理模块包括：图像的读取、显示、保存、几何运算等。</p>
<span id="more"></span>
<h1 id="图像的基础操作">图像的基础操作</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br></pre></td></tr></table></figure>
<h2 id="图像读取显示保存">图像读取、显示、保存</h2>
<h3 id="读取图像">读取图像</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以灰度图的形式读取图像，可以使用1、0或者-1来替代下面三个标志</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;./messi5.jpg&#x27;</span>,<span class="number">0</span>) </span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li><p>要读取的图像，./表示当前文件夹</p></li>
<li><p>读取方式的标志</p>
<ul>
<li><p>cv.IMREAD*COLOR：以彩色模式加载图像，任何图像的透明度都将被忽略。这是默认参数。</p></li>
<li><p>cv.IMREAD*GRAYSCALE：以灰度模式加载图像</p></li>
<li><p>cv.IMREAD_UNCHANGED：包括alpha通道的加载图像模式。</p></li>
</ul></li>
</ul>
<h3 id="显示图像">显示图像</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opencv中显示</span></span><br><span class="line">cv.imshow(<span class="string">&#x27;./image&#x27;</span>,img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># matplotlib中展示</span></span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>]) <span class="comment"># matplotlib中rgb和opencv是正好反着的</span></span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>显示图像的窗口名称，以字符串类型表示</li>
<li>要加载的图像</li>
</ul>
<p><strong>注意：在调用显示图像的API后，要调用cv.waitKey()给图像绘制留下时间，否则窗口会出现无响应情况，并且图像无法显示出来</strong>。</p>
<h3 id="保存图像">保存图像</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.imwrite(<span class="string">&#x27;./messigray.png&#x27;</span>,img)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>文件名，保存位置，./表示当前文件夹</li>
<li>要保存的图像</li>
</ul>
<h2 id="绘制几何图形">绘制几何图形</h2>
<h3 id="绘制直线">绘制直线</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.line(img,start,end,color,thickness)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img:要绘制直线的图像</li>
<li>start,end: 直线的起点和终点</li>
<li>color: 线条的颜色</li>
<li>thickness: 线条宽度</li>
</ul>
<h3 id="绘制圆形">绘制圆形</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.circle(img,centerpoint, r, color, thickness)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img:要绘制圆形的图像</li>
<li>centerpoint, r: 圆心和半径</li>
<li>color: 线条的颜色</li>
<li>thickness: 线条宽度，为-1时生成闭合图案并填充颜色</li>
</ul>
<h3 id="绘制矩形">绘制矩形</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.rectangle(img,leftupper,rightdown,color,thickness)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img:要绘制矩形的图像</li>
<li>leftupper, rightdown: 矩形的左上角和右下角坐标</li>
<li>color: 线条的颜色</li>
<li>thickness: 线条宽度</li>
</ul>
<h3 id="添加文字">添加文字</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.putText(img,text,station, font, fontsize,color,thickness,cv.LINE_AA)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>img: 图像</li>
<li>text：要写入的文本数据</li>
<li>station：文本的放置位置</li>
<li>font：字体</li>
<li>fontsize :字体大小</li>
</ul>
<h3 id="效果展示">效果展示</h3>
<p>生成一个全黑的图像，然后在里面绘制图像并添加文字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 1 创建一个空白的图像</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"><span class="comment"># 2 绘制图形</span></span><br><span class="line">cv.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br><span class="line">cv.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line">cv.circle(img,(<span class="number">447</span>,<span class="number">63</span>), <span class="number">63</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">font = cv.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv.putText(img,<span class="string">&#x27;OpenCV&#x27;</span>,(<span class="number">10</span>,<span class="number">500</span>), font, <span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>,cv.LINE_AA)</span><br><span class="line"><span class="comment"># 3 图像展示</span></span><br><span class="line">plt.imshow(img[:,:,::-<span class="number">1</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;匹配结果&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20190925154009533.png" style="zoom: 50%;" /></p>
<h2 id="获取并修改像素点">获取并修改像素点</h2>
<p>可以通过行和列的坐标值获取该像素点的像素值。对于BGR图像，它返回一个蓝，绿，红值的数组。对于灰度图像，仅返回相应的强度值。使用相同的方法对像素值进行修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取某个像素点的值</span></span><br><span class="line">px = img[<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line"><span class="comment"># 仅获取蓝色通道的强度值</span></span><br><span class="line">blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 修改某个位置的像素值</span></span><br><span class="line">img[<span class="number">100</span>,<span class="number">100</span>] = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]</span><br></pre></td></tr></table></figure>
<h2 id="图像的属性">图像的属性</h2>
<p>图像属性包括行数，列数和通道数，图像数据类型，像素数等。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191016151042764-1684327382077-6.png"  style="zoom:50%;" /></p>
<h2 id="图像通道的拆分与合并">图像通道的拆分与合并</h2>
<p>有时需要在B，G，R通道图像上单独工作,此时需要将<code>BGR</code>图像分割为单个通道。或者可能需要将这些单独的通道合并到BGR图像。可以通过以下方式完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通道拆分</span></span><br><span class="line">b,g,r = cv.split(img)</span><br><span class="line"><span class="comment"># 通道合并</span></span><br><span class="line">img = cv.merge((b,g,r))</span><br></pre></td></tr></table></figure>
<h2 id="色彩空间的改变">色彩空间的改变</h2>
<p><code>OpenCV</code>中有150多种颜色空间转换方法。最广泛使用的转换方法有两种，<span class="math inline">\(BGR \leftrightarrow Gray\)</span>和<span class="math inline">\(BGR \leftrightarrow HSV\)</span>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv.cvtColor(input_image，flag)</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<ul>
<li>input_image: 进行颜色空间转换的图像</li>
<li>flag: 转换类型
<ul>
<li>cv.COLOR_BGR2GRAY : <span class="math inline">\(BGR \leftrightarrow Gray\)</span></li>
<li>cv.COLOR_BGR2HSV: <span class="math inline">\(BGR \leftrightarrow HSV\)</span></li>
</ul></li>
</ul>
<h1 id="算数操作">算数操作</h1>
<h2 id="图像加法">图像加法</h2>
<p>使用<code>OpenCV</code>的<code>cv.add()</code>函数把两幅图像相加，或者可以简单地通过numpy操作添加两个图像，如<span class="math inline">\(res = img_1 + img_2\)</span>。两个图像应该具有相同的大小和类型，或者第二个图像可以是标量值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = np.uint8([<span class="number">250</span>])</span><br><span class="line">y = np.uint8([<span class="number">10</span>])</span><br><span class="line"><span class="built_in">print</span>( cv.add(x,y) ) <span class="comment"># 250+10 = 260 =&gt; 255</span></span><br><span class="line">[[<span class="number">255</span>]]</span><br><span class="line"><span class="built_in">print</span>( x+y )          <span class="comment"># 250+10 = 260 % 256 = 4</span></span><br><span class="line">[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>**注意：<code>OpenCV</code>的加法是饱和操作，而<code>Numpy</code>添加是模运算。这种区别在对两幅图像进行加法时会很明显。<code>OpenCV</code> 的结果会更好一点。所以我们尽量使用 <code>OpenCV</code>中的函数。</p>
<p>将两幅图像进行加法操作来比较其中的区别：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img1 = cv.imread(<span class="string">&quot;./view.jpg&quot;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&quot;./rain.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 加法操作</span></span><br><span class="line">img3 = cv.add(img1,img2) <span class="comment"># cv中的加法</span></span><br><span class="line">img4 = img1+img2 <span class="comment"># 直接相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">fig,axes=plt.subplots(nrows=<span class="number">1</span>,ncols=<span class="number">2</span>,figsize=(<span class="number">10</span>,<span class="number">8</span>),dpi=<span class="number">100</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(img3[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">0</span>].set_title(<span class="string">&quot;cv中的加法&quot;</span>)</span><br><span class="line">axes[<span class="number">1</span>].imshow(img4[:,:,::-<span class="number">1</span>])</span><br><span class="line">axes[<span class="number">1</span>].set_title(<span class="string">&quot;直接相加&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191016154714377.png" style="zoom:67%;" /></p>
<h2 id="图像融合">图像融合</h2>
<p>这其实也是加法，但是不同的是两幅图像的权重不同，这就会给人一种混合或者透明的感觉。图像混合的计算公式如下：</p>
<p><span class="math display">\[
g(x)=(1−\alpha)f_0(x)+\alpha f_1(x)+\gamma
\]</span> 通过修改<span class="math inline">\(\alpha\)</span>的值<span class="math inline">\((0\rightarrow1)\)</span>，可以实现非常炫酷的混合。</p>
<p>现在我们把两幅图混合在一起。第一幅图的权重是0.7，第二幅图的权重是0.3。函数<code>cv2.addWeighted()</code>可以按下面的公式对图片进行混合操作。</p>
<p><span class="math display">\[
dst = (1-\alpha)\cdot img_1 + \alpha\cdot img_2 + \gamma
\]</span> 这里<span class="math inline">\(\gamma\)</span>取为0。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 读取图像</span></span><br><span class="line">img1 = cv.imread(<span class="string">&quot;view.jpg&quot;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&quot;rain.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 图像混合</span></span><br><span class="line">img3 = cv.addWeighted(img1,<span class="number">0.7</span>,img2,<span class="number">0.3</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3 图像显示</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">plt.imshow(img3[:,:,::-<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/imgs/$%7Bfiilename%7D/image-20191016161128720.png" style="zoom:%67%;" /></p>
<p><strong>注意：</strong>这里都要求两幅图像是相同大小的。</p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Fo4y1d7JL?p=11&amp;vd_source=fe8e916be2bd597efffd8dfd95249141"><code>黑马程序员人工智能教程_10小时学会图像处理OpenCV入门教程</code></a></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV简介</title>
    <url>/OpenCV/OpenCV%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="图像处理简介">图像处理简介</h1>
<h2 id="图像">图像</h2>
<p><a href="https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F/773234"><code>图像</code></a>是人类视觉的基础，是自然景物的客观反映，是人类认识世界和人类本身的重要源泉。“图”是物体反射或透射光的分布，“像“是人的视觉系统所接受的图在人脑中所形版的印象或认识，照片、绘画、剪贴画、地图、书法作品、手写汉学、传真、卫星云图、影视画面、X光片、脑电图、心电图等都是图像</p>
<span id="more"></span>
<h2 id="模拟图像和数字图像">模拟图像和数字图像</h2>
<p>图像起源于1826年前后法国科学家<code>Joseph Nicéphore Niépce</code>发明的第一张可永久保存的照片，属于模拟图像。模拟图像又称连续图像，它通过某种物理量（如光、电等）的强弱变化来记录图像亮度信息，所以是<strong>连续变换的</strong>。模拟信号的特点是容易受干扰，如今已经基本全面被数字图像替代。</p>
<p>在第一次世界大战后，1921年美国科学家发明了<code>Bartlane System</code>，并从伦敦传到纽约传输了第一幅数字图像，其亮度用<strong>离散数值表示</strong>，将图片编码成5个灰度级，如下图所示，通过海底电缆进行传输。在发送端图片被编码并使用打孔带记录，通过系统传输后在接收方使用特殊的打印机恢复成图像。</p>
<p><img src="/imgs/$%7Bfiilename%7D/Snipaste_2019-09-24_11-19-33.png"  style="zoom: 67%;" /></p>
<p>1950年左右，计算机被发明，数字图像处理学科正式诞生。</p>
<p>计算机采用0/1编码的系统，数字图像是利用0/1来记录信息，我们平常接触的图像都是8位数图像，包含0～255灰度，其中0代表最黑，1代表最白。如下展现的是一个灰度图。</p>
<p><img src="/imgs/$%7Bfiilename%7D/Snipaste_2019-09-24_11-46-55.png"  style="zoom:67%;" /></p>
<h2 id="图像的分类">图像的分类</h2>
<h3 id="二值图像">二值图像：</h3>
<p>一幅二值图像的二维矩阵仅由0、1两个值构成，0代表黑色，1代白色。由于每一像素（矩阵中每一元素）取值仅有0、1两种可能，所以计算机中二值图像的数据类型通常为1个二进制位。二值图像通常用于文字、线条图的扫描识别（OCR）和掩膜图像的存储。</p>
<h3 id="灰度图">灰度图：</h3>
<p>每个像素只有一个采样颜色的图像，这类图像通常显示为从最暗黑色到最亮的白色的灰度，尽管理论上这个采样可以任何颜色的不同深浅，甚至可以是不同亮度上的不同颜色。灰度图像与黑白图像不同，在计算机图像领域中黑白图像只有黑色与白色两种颜色；但是，灰度图像在黑色与白色之间还有许多级的颜色深度。灰度图像经常是在单个电磁波频谱如可见光内测量每个像素的亮度得到的，用于显示的灰度图像通常用每个采样像素8位的非线性尺度来保存，这样可以有<span class="math inline">\(2^8=256\)</span>级灰度（如果用<span class="math inline">\(16\)</span>位，则有<span class="math inline">\(2^16=65536\)</span>级）。</p>
<h3 id="彩色图"><strong>彩色图</strong>：</h3>
<p>每个像素通常是由红（R）、绿（G）、蓝（B）三个分量来表示的，分量介于（0~255）。<code>RGB</code>图像与索引图像一样都可以用来表示彩色图像。与索引图像一样，它分别用红（R）、绿（G）、蓝（B）三原色的组合来表示每个像素的颜色。但与索引图像不同的是，<code>RGB</code>图像每一个像素的颜色值（由<code>RGB</code>三原色表示）直接存放在图像矩阵中，由于每一像素的颜色需由R、G、B三个分量来表示，M、N分别表示图像的行列数，三个M x N的二维矩阵分别表示各个像素的R、G、B三个颜色分量。<code>RGB</code>图像的数据类型一般为8位无符号整形，通常用于表示和存放真彩色图像。</p>
<h1 id="opencv简介"><code>OpenCV</code>简介</h1>
<p><code>OpenCV</code>是一款由Intel公司俄罗斯团队发起并参与和维护的一个计算机视觉处理开源软件库，支持与计算机视觉和机器学习相关的众多算法，并且正在日益扩展。</p>
<p><img src="/imgs/$%7Bfiilename%7D/Snipaste_2019-09-23_16-41-04.png"  style="zoom:67%;" /></p>
<h2 id="opencv-python"><code>OpenCV-Python</code></h2>
<p><code>OpenCV-Python</code>是原始<code>OpenCV</code> C++实现的Python包装器。同时它使用<code>Numpy</code>，这是一个高度优化的数据库操作库，具有<code>MATLAB</code>风格的语法。所有<code>OpenCV</code>数组结构都转换为<code>Numpy</code>数组。这也使得与使用<code>Numpy</code>的其他库（如<code>SciPy</code>和<code>Matplotlib</code>）集成更容易。</p>
<h2 id="opencv部署"><code>OpenCV</code>部署</h2>
<ol type="1">
<li>安装<code>OpenCV</code>之前需要先安装<a href="https://pypi.org/project/numpy/"><code>numpy</code></a>, <a href="https://pypi.org/project/matplotlib/"><code>matplotlib</code></a>。</li>
<li>创建Python虚拟环境</li>
<li>安装<a href="https://pypi.org/project/opencv-python/"><code>OpenCV-Python</code></a>, 由于一些经典的算法被申请了版权，新版本有很大的限制，所以选用3.4.3以下的版本</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install opencv-python==3.4.2.17</span><br></pre></td></tr></table></figure>
<p>测试是否安装成功，运行以下代码无报错，则说明安装成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 读一个图片并进行显示(图片路径需自己指定)</span></span><br><span class="line">lena=cv2.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;image&quot;</span>,lena)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>需要利用SIFT和SURF等进行特征提取时，还需要安装：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install opencv-contrib-python==<span class="number">3.4</span><span class="number">.2</span><span class="number">.17</span></span><br></pre></td></tr></table></figure>
<h1 id="opencv的模块"><code>OpenCV</code>的模块</h1>
<p><img src="/imgs/$%7Bfiilename%7D/Snipaste_2019-09-23_16-42-18.png"  style="zoom: 50%;" /></p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 26%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">模块</th>
<th style="text-align: left;">功能</th>
<th style="text-align: left;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>Core</strong></td>
<td style="text-align: left;">核心模块，包含最基础的操作</td>
<td style="text-align: left;">绘图函数、数组操作相关函数</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>HighGUI</strong></td>
<td style="text-align: left;">高层图像用户界面</td>
<td style="text-align: left;">视频与图像的读取、显示、存储等接口</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>Imgproc</strong></td>
<td style="text-align: left;">图像处理模块</td>
<td style="text-align: left;">图像处理的基础方法：包括图像滤波、图像的几何变换、平滑、阈值分割、形态学处理、边缘检测、目标检测、运动分析和对象跟踪等</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Featured2d</strong></td>
<td style="text-align: left;">2D特征检测模块</td>
<td style="text-align: left;">用于提取图像特征以及特征匹配，nonfree模块实现了一些专利算法，如sift特征。</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Objdectect</td>
<td style="text-align: left;">目标检测模块</td>
<td style="text-align: left;">基于Haar、LBP特征的人脸检测，基于HOG的行人、汽车等目标检测，分类器使用Cascade Classification（级联分类）和Latent SVM等</td>
</tr>
<tr class="even">
<td style="text-align: center;">Video</td>
<td style="text-align: left;">视频处理模块</td>
<td style="text-align: left;">针对视频处理，如背景分离，前景检测、对象跟踪等</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Calib3d</td>
<td style="text-align: left;">3D重建模块</td>
<td style="text-align: left;">主要是相机校准和三维重建相关的内容。包含了基本的多视角几何算法，单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等。</td>
</tr>
<tr class="even">
<td style="text-align: center;">ML</td>
<td style="text-align: left;">机器学习模块</td>
<td style="text-align: left;">SVM，决策树，Boosting等</td>
</tr>
<tr class="odd">
<td style="text-align: center;">FLANN</td>
<td style="text-align: left;">最近邻搜索模块</td>
<td style="text-align: left;">包含快速近似最近邻搜索FLANN 和聚类Clustering算法</td>
</tr>
<tr class="even">
<td style="text-align: center;">Stitching</td>
<td style="text-align: left;">图像拼接模块</td>
<td style="text-align: left;">实现了图像拼接功能</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Photo</td>
<td style="text-align: left;">计算图像学</td>
<td style="text-align: left;">包含图像修复和图像去噪两部分</td>
</tr>
<tr class="even">
<td style="text-align: center;">G-API</td>
<td style="text-align: left;">G-API模块</td>
<td style="text-align: left;">包含超高效的图像处理pipeline引擎</td>
</tr>
</tbody>
</table>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1Fo4y1d7JL?p=4&amp;vd_source=fe8e916be2bd597efffd8dfd95249141"><code>黑马程序员人工智能教程_10小时学会图像处理OpenCV入门教程</code></a></p>
]]></content>
      <categories>
        <category>OpenCV</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>轨迹优化-闭式求解</title>
    <url>/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-%E9%97%AD%E5%BC%8F%E6%B1%82%E8%A7%A3/</url>
    <content><![CDATA[<p>如果<a href="https://baike.baidu.com/item/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92/4269159"><code>QP</code></a>问题只有等式约束，没有不等式约束，可以采用<a href="https://zh.wikipedia.org/wiki/%E8%A7%A3%E6%9E%90%E8%A7%A3"><code>闭式求解</code></a>的方式。</p>
<span id="more"></span>
<h1 id="构建等式约束方程">构建等式约束方程</h1>
<p>还是一段复杂的轨迹按照时间划分成<span class="math inline">\(m\)</span>段，一共有<span class="math inline">\(m+1\)</span>个点，其中<span class="math inline">\(0\)</span>是起点，<span class="math inline">\(m\)</span>是目标点，<span class="math inline">\(m-1\)</span>个中间点。每段多项式轨迹都构成 <span class="math display">\[
A_ip_i=d_i,\quad 
A_i=\left[\begin{matrix}
A_0\\A_T
\end{matrix}\right]_i,\quad
d_i=\left[\begin{matrix}
d_0\\d_T
\end{matrix}\right]_i
\]</span></p>
<p>其中，<span class="math inline">\(d_o,d_T\)</span>是第<span class="math inline">\(i\)</span>段多项式轨迹的起点和终点的各阶导数组成的向量。这里只考虑了位置速度和加速度。 <span class="math display">\[
\underbrace{A_{total}}_{6m \times m(n+1)}
\underbrace{
\left[ \begin{matrix}
p_1 \\
\vdots \\
p_m \\
\end{matrix} \right]}_{m(n+1) \times 1} 
= \left[ \begin{matrix}
d_1 \\
\vdots \\
d_m \\
\end{matrix} \right]
=\underbrace{
\left[ \begin{matrix}
p_1(t_0)\\
v_1(t_0)\\
a_1(t_0)\\
p_1(t_1)\\
v_1(t_1)\\
a_1(t_1)\\
\vdots \\
p_m(t_{m-1})\\
v_m(t_{m-1})\\
a_m(t_{m-1})\\
p_m(t_m)\\
v_m(t_m)\\
a_m(t_m)\\
\end{matrix} \right]}_{6m \times 1}
\]</span> 目标是要求解参数<span class="math inline">\(p\)</span> <span class="math display">\[
p=A^{-1}d
\]</span></p>
<h2 id="消除重复变量">消除重复变量</h2>
<p>考虑到连续性(这里假设P、V、A连续)，向量中很多变量重复了 <span class="math display">\[
p_i(t_i)=p_{i+1}(t_i),~~v_i(t_i)=v_{i+1}(t_i),~~a_i(t_i)=a_{i+1}(t_i)
\]</span> 连续性约束不是直接加到等式约束方程中。而是通过一个映射矩阵<span class="math inline">\(M\)</span>将一个变量映射到两个重复的变量上。 <span class="math display">\[
\underbrace{
\left[ \begin{matrix}
d_1 \\
\vdots \\
d_k \\
\end{matrix} \right]}_{6m\times1}=
\underbrace{
\left[ \begin{matrix}
1\\
&amp;1\\
&amp;&amp;1\\
&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;&amp;1\\
&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;1\\
&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\ddots
\end{matrix} \right]}_{M}
\underbrace{
\left[\begin{matrix} 
p(t_0)\\
v(t_0)\\
a(t_0)\\
p(t_1)\\
v(t_1)\\
a(t_1)\\
p(t_2)\\
v(t_2)\\
a(t_2)\\
\vdots\\
p(t_m)\\
v(t_m)\\
a(t_m)\\
\end{matrix} \right]}_{3(m+1)\times 1}
\]</span> 即<span class="math inline">\(d=Md&#39;\)</span></p>
<h2 id="向量元素置换">向量元素置换</h2>
<p>接着把已知参数 <span class="math inline">\(d_F\)</span>和未知参数<span class="math inline">\(d_P\)</span>重新排列，可以左乘一个置换矩阵<span class="math inline">\(C\)</span>，使得<span class="math inline">\(d&#39;=C\left[\begin{matrix}d_F\\d_P\end{matrix}\right]\)</span></p>
<h2 id="转成无约束优化问题">转成无约束优化问题</h2>
<p>所以 <span class="math inline">\(d=MC\left[\begin{matrix}d_F\\d_P\end{matrix}\right]\)</span> <span class="math display">\[
p=A^{-1}d=\underbrace{A^{-1}MC}_K\left[\begin{matrix}d_F\\d_P\end{matrix}\right] = K\left[\begin{matrix}d_F\\d_P\end{matrix}\right]
\]</span> 将<span class="math inline">\(p\)</span>代入优化函数 <span class="math display">\[
\min p^TQp\\
\]</span></p>
<p><span class="math display">\[
=\left[\begin{matrix}d_F\\d_P\end{matrix}\right]^T\underbrace{K^TQK}_R\left[\begin{matrix}d_F\\d_P\end{matrix}\right]
\]</span></p>
<p><span class="math display">\[
=\left[\begin{matrix}d_F\\d_P\end{matrix}\right]^T
\left[\begin{matrix}R_{FF} &amp; R_{FP}\\R_{PF}&amp;R_{PP}\end{matrix}\right]
\left[\begin{matrix}d_F\\d_P\end{matrix}\right]
\]</span></p>
<p><span class="math display">\[
=d_F^TR_{FF}d_F+d_F^TR_{FP}d_P+d_P^TR_{PF}d_F+d_P^TR_{PP}d_P
\]</span></p>
<p><span class="math display">\[
=d_F^TR_{FF}d_F+2d_F^TR_{FP}d_P+d_P^TR_{PP}d_P
\]</span></p>
<p>令优化函数<span class="math inline">\(mibn\)</span>对<span class="math inline">\(d_P\)</span>求导，并且令其导数等于0 <span class="math display">\[
\rightarrow 2d_F^TR_{FP}+2R_{PP}d_P=0\quad(R_{PP}^T=R_{PP})\\
\rightarrow d^*_p = -R_{PP}^{-1}R_{FP}^Td_F
\]</span></p>
<h1 id="总结">总结</h1>
<ol type="1">
<li><p>先确定轨迹阶数(这里是用的5阶，因为A矩阵要为方形阵，所以<span class="math inline">\(6m=m(n+1)\rightarrow n=5\)</span>)，再确定<span class="math inline">\(d\)</span>中的约束量(p、v、a)，进而根据各段的时间分配求得<span class="math inline">\(A_{total}\)</span></p></li>
<li><p>根据连续性约束构造映射矩阵<span class="math inline">\(M\)</span>，并确定<span class="math inline">\(d\)</span>中哪些量是已知的(fix/specified)，哪些量是未知的(free/unspecified)，进而构造置换矩阵<span class="math inline">\(C\)</span>，并求得<span class="math inline">\(K=A^{-1}MC\)</span>。</p></li>
<li><p>计算目标函数中的Q矩阵，并计算<span class="math inline">\(R=K^TQK\)</span>，根据已知参数(fix)的长度将<span class="math inline">\(R\)</span>拆分成<span class="math inline">\(R_{FF},R_{FR},R_{FR},R_{PP}\)</span>四小块。</p></li>
<li><p>根据<span class="math inline">\(d^*_p = -R_{PP}^{-1}R_{FP}^Td_F\)</span>计算<span class="math inline">\(d^*_p\)</span></p></li>
<li><p>根据<span class="math inline">\(p=K\left[\begin{matrix}d_F\\d_p\end{matrix}\right]\)</span>计算得到轨迹参数<span class="math inline">\(p\)</span></p></li>
</ol>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230516211818087.png" style="zoom:80%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230516211938320.png"  style="zoom:80%;" /></p>
<h1 id="参考">参考</h1>
<p>Richter C, Bry A, Roy N. Polynomial trajectory planning for aggressive quadrotor flight in dense indoor environments[C]//Robotics Research: The 16th International Symposium ISRR. Springer International Publishing, 2016: 649-666.</p>
<p><a href="https://blog.csdn.net/q597967420/article/details/79031791?spm=1001.2014.3001.5502"><code>Minimum Snap轨迹规划详解（3）闭式求解</code></a></p>
<p><a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?p=12&amp;vd_source=fe8e916be2bd597efffd8dfd95249141"><code>机器人路径规划、轨迹优化系列课程</code></a></p>
]]></content>
      <categories>
        <category>轨迹优化</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>轨迹优化-MinimumSnap</title>
    <url>/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96/%E8%BD%A8%E8%BF%B9%E4%BC%98%E5%8C%96-MinimumSnap/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<h2 id="二次型">二次型</h2>
<p>含有n个变量<span class="math inline">\(x=x_1,x_2,\cdots,x_{n-1},x_{n}\)</span>的二次齐次函数 <span class="math display">\[
f(x_1,x_2,...,x_n)=a11x_1^2+a22x_2^2+\cdots+a_{nn}x_n^2
\]</span> 称为二次型。取<span class="math inline">\(a_{ij}=a_{ji}\)</span>，则有<span class="math inline">\(2a_{ij}x_ix_j=a_{ij}x_ix_j+a_{ji}x_jx_i\)</span>，上式可表示为<span class="math inline">\(f(x)=\sum_{i,j=1}^{n}a_{ij}x_ix_j\)</span>。矩阵表示为<span class="math inline">\(f=x^TAx\)</span></p>
<span id="more"></span>
<h2 id="二次规划quadratic-programming-qp">二次规划(Quadratic Programming, <a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92"><code>QP</code></a>)</h2>
<p>当目标函数<span class="math inline">\(f\)</span>为二次型，且约束为线性约束时，该优化问题就是二次规划问题，一般形式表述如下： <span class="math display">\[
\underset {x}{min}f(x)=\frac{x^TQx}{2}+q^Tx
\]</span> <span class="math display">\[
s.t.Ax=b
\]</span> <span class="math display">\[
Gx\leq h
\]</span></p>
<p>二次规划是一类凸优化问题，目前有很多商业或者开源的求解器来求解这类问题。</p>
<h1 id="多项式轨迹">多项式轨迹</h1>
<p>使用路径规划可以得到一系列的路径点，但这些路径点是不带时间<span class="math inline">\(t\)</span>的，轨迹函数是以自变量为时间<span class="math inline">\(t\)</span>的函数，一般用<span class="math inline">\(n\)</span>阶多项式表示 <span class="math display">\[
p(t)=p_0t^0+p_1t^1+p_2t^2+\cdots+p_nt^n=\sum_{i=0}^{n}p_it^i
\]</span> 向量形式 <span class="math display">\[
p(t)=\left[\begin{matrix}
1&amp;t&amp;\cdots&amp;t^n 
\end{matrix}\right]
\left[\begin{matrix}
p_0\\p_1\\\vdots\\p_n 
\end{matrix}\right]
\]</span> 其中<span class="math inline">\(p_0,p_1,\cdots,p_n\)</span>是轨迹参数(n次多项式，有n+1个参数)，也是我们的优化参数。</p>
<p>对轨迹函数进行求导，可以写出它的速度<span class="math inline">\(v\)</span>、加速度<span class="math inline">\(a\)</span>、jerk、snap等参数随时间变化的函数 <span class="math display">\[
v(t)=p^{1}(t)=\left[\begin{matrix}
0&amp;1&amp;2t&amp;3t^2&amp;4t^3\cdots&amp;\frac{n!}{(n-1)!}t^{n-1} 
\end{matrix}\right]\cdot p
\]</span></p>
<p><span class="math display">\[
a(t)=p^{(2)}(t)=\left[\begin{matrix}
0&amp;0&amp;2&amp;6t&amp;12t^2&amp;\cdots&amp;\frac{n!}{(n-2)!}t^{n-2} 
\end{matrix}\right]\cdot p
\]</span></p>
<p><span class="math display">\[
jerk(t)=p^{(3)}(t)=\left[\begin{matrix}
0&amp;0&amp;0&amp;6&amp;24t&amp;\cdots&amp;\frac{n!}{(n-3)!}t^{n-3} 
\end{matrix}\right]\cdot p
\]</span></p>
<p><span class="math display">\[
snap(t)=p^{(4)}(t)=\left[\begin{matrix}
0&amp;0&amp;0&amp;0&amp;24&amp;\cdots&amp;\frac{n!}{(n-4)!}t^{n-4} 
\end{matrix}\right]\cdot p
\]</span></p>
<p>其中<span class="math inline">\(p=\left[\begin{matrix} p_0&amp;p_1&amp;\cdots&amp;p_n \end{matrix}\right]^T\)</span>，轨迹函数<span class="math inline">\(p(t)\)</span>的导数通式为 <span class="math display">\[
p^{(k)}(t)=\left[\begin{matrix}
\overset{k}{\overbrace{0\cdots0}}&amp;\overset{n-k+1}{\overbrace{\frac{(k+0)!}{(0)!}t^{0}\quad
\frac{(k+1)!}{(1)!}t^{1}\quad\cdots\quad
\frac{n!}{(n-k)!}t^{n-k}
}} 
\end{matrix}\right]\cdot p
\]</span> 我们将一段复杂的轨迹按时间划分成<span class="math inline">\(m\)</span>段，<span class="math inline">\(p_i=[p_{i_0},p_{i_1},\cdots,p_{i_n}]^T\)</span>为第<span class="math inline">\(i\)</span>段轨迹的参数向量。</p>
<p><span class="math display">\[
\begin{equation}
p(t) = 
\begin{cases}
[1,t,t^2,...,t^n]\cdot p_1~~~t_0\leq t&lt;t_1\\
[1,t,t^2,...,t^n]\cdot p_2~~~t_1\leq t&lt;t_2\\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\vdots\\
[1,t,t^2,...,t^n]\cdot p_m~~~t_{m-1}\leq t&lt;t_m\\
\end{cases}
\end{equation}
\]</span></p>
<h1 id="minimum-snap轨迹规划">Minimum Snap轨迹规划</h1>
<p>轨迹规划的目的：求轨迹的多项式参数<span class="math inline">\(p_1,\cdots,p_m\)</span></p>
<h2 id="约束条件">约束条件</h2>
<p>基本要求：</p>
<ol type="1">
<li>两段轨迹之间连续</li>
<li>轨迹经过固定点</li>
<li>轨迹无碰撞</li>
</ol>
<p>高级要求： 轨迹最顺滑、能量最优等</p>
<h2 id="构建优化函数">构建优化函数</h2>
<p>通常满足约束条件的轨迹有无数条，而实际问题中，往往只需要特定的一条轨迹，所以还需要构建一个最优函数，方便在可行的轨迹中找出最优的轨迹。</p>
<p>这是一个约束优化问题，形如： <span class="math display">\[
\min f(p)
\]</span></p>
<p><span class="math display">\[
s.t.~~A_{eq}p = b_{eq},
\]</span></p>
<p><span class="math display">\[
A_{ieq}p \leq b_{ieq}
\]</span></p>
<p><code>Minimum Snap</code>顾名思义，最小化目标函数是<span class="math inline">\(Snap\)</span>，当然也可以最小化Acceleration(加速度)或者Jerk，一般不会最小化速度。 <span class="math display">\[
minimum~snap:~\min f(p)=\min (p^{(4)}(t))^2
\]</span></p>
<p><span class="math display">\[
minimum~jerk:~\min f(p)=\min (p^{(3)}(t))^2
\]</span></p>
<p><span class="math display">\[
minimum~a:~\min f(p)=\min (p^{(2)}(t))^2 \\
\]</span></p>
<p><strong>Minimum Snap的优化函数为</strong> <span class="math display">\[
\min \int _0^T(p^{(4)}(t))^2 {\rm d}t
\]</span></p>
<p><span class="math display">\[
=\min \sum_{i=1}^m \int _{t_{i-1}}^{t_i}(p^{(4)}(t))^2 {\rm d}t
\]</span></p>
<p><span class="math display">\[
=\min \sum_{i=1}^m \int _{t_{i-1}}^{t_i}   ([0,0,0,0,24,\cdots,\frac{n!}{(n-4!)}t^{n-4}]\cdot p)^T[0,0,0,0,24,\cdots,\frac{n!}{(n-4!)}t^{n-4}]\cdot p~{\rm d}t
\]</span></p>
<p><span class="math display">\[
=\min \sum_{i=1}^m p^T\int _{t_{i-1}}^{t_i}[0,0,0,0,24,\cdots,\frac{n!}{(n-4!)}t^{n-4}]^T[0,0,0,0,24,\cdots,\frac{n!}{(n-4!)}t^{n-4}]~{\rm d}t~p
\]</span></p>
<p><span class="math display">\[
=\min \sum_{i=1}^m p^TQ_ip
\]</span></p>
<p><span class="math display">\[
=\min  p^TQp
\]</span></p>
<p><span class="math display">\[
Q_i = \int _{t_{i-1}}^{t_i}[0,0,0,0,24,\cdots,\frac{n!}{(n-4!)}t^{n-4}]^T[0,0,0,0,24,\cdots,\frac{n!}{(n-4!)}t^{n-4}]~{\rm d}t
\]</span></p>
<p><span class="math display">\[
=\left[\begin{matrix}
0_{4\times 4} &amp; 0_{4\times (n-3)}\\
0_{(n-3) \times 4} &amp; \frac{r!}{(r-4)!}\frac{c!}{(c-4)!}\frac{1}{(r-4)+(c-4)+1}(t_{i}^{(r+c-7)}-t_{i-1}^{(r+c-7)})
\end{matrix}\right]
\]</span></p>
<p><strong>注意：r,c为矩阵的行索引和列索引， 索引从0开始，即第一行r=0。这个Q<sub>i</sub>矩阵计算可太厉害了</strong> <span class="math display">\[
Q = \left[\begin{matrix}
        Q_1 &amp;&amp;&amp;\\
        &amp;Q_2&amp;&amp;\\
        &amp;&amp;\ddots &amp;\\
        &amp;&amp;&amp;Q_m
    \end{matrix}\right]
\]</span></p>
<h2 id="构建等式约束方程">构建等式约束方程</h2>
<p>1、设定某一个点的位置、速度、加速度为一个特定的值,可以构成一个等式约束。</p>
<p>位置约束： <span class="math inline">\([1,t_0,t_0^2,\cdots,t_0^n,\underbrace{0\cdots0}_{(m-1)(n+1)}]\cdot p = p_0\)</span></p>
<p>速度约束： <span class="math inline">\([0,1,2t_0,\cdots,nt_0^{n-1},\underbrace{0\cdots0}_{(m-1)(n+1)}]\cdot p = v_0\)</span></p>
<p>加速度约束：<span class="math inline">\([0,0,2,\cdots,n(n-1)t_0^{n-2},\underbrace{0\cdots0}_{(m-1)(n+1)}]\cdot p = a_0\)</span></p>
<p>2、相邻段之间的位置、速度、加速度连续可以构成一个等式约束。对于有m+1个路径点的轨迹，一共有m段多项式轨迹，</p>
<p>连续性约束：<span class="math inline">\([\underbrace{0\cdots0}_{(i-1)(n+1)},1,t_i,t_i^2,\cdots,t_i^n,-1,-t_i,-t_i^2,\cdots,-t_i^n,\underbrace{0\cdots0}_{(m-i-1)(n+1)}]\cdot p=0\)</span></p>
<p>3、合并所有等式约束， <span class="math display">\[
\begin{equation}
\left[\begin{matrix}
1,t_0,t_0^2,\cdots,t_0^n,\underbrace{0\cdots0}_{(m-1)(n+1)}\\
0,1,2t_0,\cdots,nt_0^{n-1},\underbrace{0\cdots0}_{(m-1)(n+1)}\\
0,0,2,\cdots,n(n-1)t_0^{n-2},\underbrace{0\cdots0}_{(m-1)(n+1)}\\
\vdots\\
\underbrace{0\cdots0}_{(i-1)(n+1)} ,1,t_i,t_i^2,\cdots,t_i^n,\underbrace{0\cdots0}_{(m-i)(n+1)}\\
\vdots\\
\underbrace{0\cdots0}_{(m-1)(n+1)},1,t_m,t_m^2,\cdots,t_m^n\\
\underbrace{0\cdots0}_{(m-1)(n+1)},0,1,2t_m,\cdots,nt_m^{n-1}\\
\underbrace{0\cdots0}_{(m-1)(n+1)},0,0,2,\cdots,n(n-1)t_m^{n-2}\\
\underbrace{0\cdots0}_{(i-1)(n+1)} ,1,t_i,t_i^2,\cdots,t_i^n,-1,-t_i,-t_i^2,\cdots,-t_i^n,\underbrace{0\cdots0}_{(m-i-1)(n+1)}\\
\underbrace{0\cdots0}_{(i-1)(n+1)} ,0,1,2t_i,\cdots,nt_i^{n-1},-0,-1,-2t_i,\cdots,-nt_i^{n-1},\underbrace{0\cdots0}_{(m-i-1)(n+1)}\\
\underbrace{0\cdots0}_{(i-1)(n+1)} ,0,0,2,\cdots,\frac{n!}{(n-2)!}t_i^{n-2},-0,-0,-2,\cdots,-\frac{n!}{(n-2)!}t_i^{n-2},\underbrace{0\cdots0}_{(m-i-1)(n+1)}\\
\end{matrix}\right]_{(4m+2)\times (n+1)m}
\end{equation}p
\]</span></p>
<p><span class="math display">\[
=
\left[\begin{matrix}
p_0\\
v_0\\
a_0\\
\vdots\\
p_i\\
\vdots\\
p_m\\
v_m\\
a_m\\
0\\
\vdots\\
0
\end{matrix}\right]
\]</span></p>
<p><strong>等式约束个数=3{起点p<sub>0</sub>、v<sub>0</sub>、a<sub>0</sub>}+m-1{中间点的p<sub>i</sub>}+3{目标点p<sub>m</sub>、v<sub>m</sub>、a<sub>m</sub>}+3(m-1){中间点p<sub>i</sub>、v<sub>i</sub>、a<sub>i</sub>连续=0}=4m+2</strong></p>
<h1 id="代码实现">代码实现</h1>
<p>生成x、y两个维度的轨迹，合并后如下图所示。包含起始终止共7个点，用6段多项式轨迹来描述，中间点也就是多项式轨迹之间的交界点。</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230515212657627.png"  style="zoom:80%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230515212839998.png"  style="zoom:80%;" /></p>
<h1 id="参考">参考</h1>
<p>Mellinger D, Kumar V. Minimum snap trajectory generation and control for quadrotors[C]//2011 IEEE international conference on robotics and automation. IEEE, 2011: 2520-2525.</p>
<p><a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?p=10&amp;vd_source=fe8e916be2bd597efffd8dfd95249141"><code>机器人路径规划、轨迹优化系列课程</code></a></p>
<p><a href="https://blog.csdn.net/q597967420/article/details/76099491"><code>Minimum Snap轨迹规划详解（1）轨迹规划入门</code></a></p>
]]></content>
      <categories>
        <category>轨迹优化</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>基于智能算法的路径规划</title>
    <url>/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<h2 id="遗传算法">遗传算法</h2>
<p>遗传算法(Genetic Algorithm,<a href="https://zh.wikipedia.org/wiki/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95"><code>GA</code></a>)是一种智能优化算法，主要用来解决优化问题，其主要步骤为种群初始化、适应度函数计算、选择、交叉和变异。应用于移动机器人路径规划时其主要步骤相同。</p>
<span id="more"></span>
<h2 id="算法步骤">算法步骤</h2>
<p>选择初始生命种群</p>
<ol type="1">
<li>每行选择一个栅格</li>
<li>判断相邻栅格是否连续</li>
<li>不连续时选择栅格进行插入，直到连续</li>
</ol>
<p>循环</p>
<ul>
<li><p>评价种群中的个体适应度fitness</p></li>
<li><p>以比例原则(分数高的挑中几率也较高)选择产生下一个种群(轮盘法、竞争法及等级轮盘法)。</p>
<p><strong>选择</strong></p>
<p>是按照轮盘法来选择的个体 <span class="math display">\[
d =\sum_{i=1}^{end-1}{\sqrt{(x_{i+1}-x{i})^{2}+(y_{i+1}-y_{i})^{2}}}
\]</span></p>
<p><span class="math display">\[
fit_1=1/d
\]</span></p>
<p><span class="math display">\[
fit_2=acrccos(\frac{(b^2+c^2-a^2)}{2bc})
\]</span></p>
<p><span class="math display">\[
fit=fit_1+fit_2
\]</span></p>
<p><span class="math display">\[
p_i=\frac{fit_i}{\sum_{i=1}^{end}fit_i}
\]</span></p></li>
<li><p>改变该种群(选择、交叉和变异)</p>
<p><strong>交叉</strong></p>
<p>如下图所示，当两个个体{0|6|7|13|19|24}和{0|1|2|3|8|13|18|24}在栅格13处交叉，经过交叉操作后会生成新的个体{0|6|7|13|18|24}和{0|1|2|3|8|13|19|24}</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230515103232016.png"  style="zoom:80%;" /></p>
<p><strong>变异</strong></p>
<p>如下图所示，当个体{0|1|2|3|8|13|18|24}经过变异操作后会随机生成新的个体{0|1|7|13|18|24}</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230515103809856.png"  style="zoom:80%;" /></p></li>
<li><p>直到停止循环的条件满足</p></li>
</ul>
<h1 id="代码实现">代码实现</h1>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230515104419609.png"  style="zoom:80%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?p=8&amp;vd_source=fe8e916be2bd597efffd8dfd95249141"><code>机器人路径规划、轨迹优化课程</code></a></p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>基于采样的路径规划</title>
    <url>/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E9%87%87%E6%A0%B7%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<p>虽然<code>基于图搜索的路径规划算法</code>能够给出一个<strong>全局范围内的最优解</strong>，但是当地图过大，空间维度过高时，它的搜索效率就会变得很慢。主要用于低维空间的路径规划问题。</p>
<span id="more"></span>
<h2 id="概率路图算法probabilistic-road-map-prm">概率路图算法(Probabilistic Road Map, <a href="https://en.wikipedia.org/wiki/Probabilistic_roadmap"><code>PRM</code></a>)</h2>
<p><code>PRM</code>算法首先使用随机采样的方式在环境中建立路径网络图，将连续的空间转换为离散的空间，然后在路径网络图上进行路径规划，解决在高维空间中搜索效率低的问题</p>
<p>算法流程</p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/prm.png"  style="zoom: 80%;" /></p>
<p><strong>采样点的数量</strong>和<strong>采样点间存在通道的最大距离</strong>是关键参数，具体的</p>
<p>采样点的数量太少，可能会导致路径规划失败，因为生成的概率路线少了。</p>
<p>随着采样点数量增加，结果会越来越接近最短路径，但同时搜索效率会降低</p>
<h2 id="快速扩展随机树rapidly-exploring-random-tree-rrt算法">快速扩展随机树(Rapidly-exploring Random Tree, <a href="https://en.wikipedia.org/wiki/Rapidly-exploring_random_tree"><code>RRT</code></a>)算法</h2>
<p><code>RRT</code>算法是一种单查询(single-query)算法，搜索过程就像一棵树不断向周围扩展生长。它的复杂度不受地图的离散程度影响，在高维空间中具有很高的搜索效率。</p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/RRT.png"  style="zoom:80%;" /></p>
<p>缺点：只管尽快地找到可行路径，所以最终路径并不是最优的，甚至会非常“绕”。</p>
<h2 id="双向快速扩展随机树rrt-connect算法">双向快速扩展随机树(<a href="https://ieeexplore.ieee.org/document/844730"><code>RRT-Connect</code></a>)算法</h2>
<p>在<code>RRT</code>的基础上引入了双向扩展环节，分别以起点和目标点为根节点生成两棵树进行双向扩展，<strong>加快了搜索速度</strong>，当两棵树建立连接时被认为路径规划成功。</p>
<p>缺点：但是<code>RRT-Connect</code>和<code>RRT</code>一样，都是单查询算法，最终路径并不是最优的。</p>
<h2 id="rrt算法"><a href="https://arxiv.org/abs/1105.1186"><code>RRT*</code></a>算法</h2>
<p><code>RRT*</code>算法是一种渐近最优算法。在<code>RRT</code>算法的基础上，增加了将<span class="math inline">\(X_{rand}\)</span>加入搜索树 T 时<strong>父节点的选择策略</strong>。</p>
<p><code>RRT*</code>算法在选择父节点时会有一个<strong>重连(Rewire)</strong>过程，也就是在以<span class="math inline">\(X_{rand}\)</span>为圆心、半径为<span class="math inline">\(r\)</span>的邻域内，找到与<span class="math inline">\(X_{new}\)</span>连接后移动代价(从起点移动到<span class="math inline">\(X_{new}\)</span>的路径长度)最小的节点，并重新选择<span class="math inline">\(X_{min}\)</span>作为<span class="math inline">\(X_{new}\)</span>的父节点，而不是<span class="math inline">\(X_{near}\)</span>。</p>
<p>简单理解就是<span class="math inline">\(Xnear\)</span>产生了<span class="math inline">\(Xnew\)</span>,然而<span class="math inline">\(Xnew\)</span>抛弃了<span class="math inline">\(Xnear\)</span>，选择了移动代价最小的<span class="math inline">\(Xmin\)</span>作为父节点。</p>
<p><img src="/imgs/$%7Bfiilename%7D/v2-1b532a8161587f211b6a7a3c9e239589_720w.webp"  style="zoom: 67%;" /></p>
<p>缺点：<code>RRT*</code>*是对自由空间进行均匀采样，搜索树上会生成很多冗余的分支，所以<code>RRT*</code>的收敛速度很慢。</p>
<h2 id="informed-rrt算法"><a href="https://arxiv.org/abs/1404.2334"><code>Informed-RRT*</code></a>算法</h2>
<p>对<code>RRT*</code>的改进策略：采用椭圆采样来代替全局均匀采样</p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230514175249529.png"  style="zoom: 50%;" /></p>
<p>以起点 <span class="math inline">\(X_{start}\)</span>和终点<span class="math inline">\(X_{goal}\)</span>作为椭圆的焦点，令<span class="math inline">\(a\)</span>等于初始路径长度<span class="math inline">\(c_{best}\)</span>的一半，即<span class="math inline">\(a=\frac{c_{best}}{2}\)</span>，则$ c=<span class="math inline">\(，\)</span>b=$，这样就可以得到椭圆方程的所有参数。</p>
<p>在之后的迭代中，如果没找到更短的路径，就用<span class="math inline">\(c_{min}\)</span>作为新的<span class="math inline">\(c_{best}\)</span>，然后在新的椭圆区域进行采样。</p>
<h1 id="代码实现">代码实现</h1>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230514234320378.png"  style="zoom:80%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230514234432119.png"  style="zoom:80%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230514234602917.png"  style="zoom:80%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230514234911888.png"  style="zoom:80%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/349074802"><code>路径规划 | 随机采样算法：PRM、RRT、RRT-Connect、RRT*</code></a></p>
<p><a href="https://zhuanlan.zhihu.com/p/372315811"><code>路径规划 | 随机采样算法：Informed-RRT*</code></a></p>
<p><a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?p=5"><code>机器人路径规划、轨迹优化系列课程</code></a></p>
<p>[1] Lavalle S M . Rapidly-Exploring Random Trees: A New Tool for Path Planning[J]. Research Report, 1999.</p>
<p>[2] Jr J , Lavalle S M . RRT-Connect: An Efficient Approach to Single-Query Path Planning[C]// Proceedings of the 2000 IEEE International Conference on Robotics and Automation, ICRA 2000, April 24-28, 2000, San Francisco, CA, USA. IEEE, 2000.</p>
<p>[3] Karaman S , Frazzoli E . Sampling-based Algorithms for Optimal Motion Planning[J]. The International Journal of Robotics Research, 2011, 30(7):846-894.</p>
<p>[4] Gammell J D , Srinivasa S S , Barfoot T D . Informed RRT*: Optimal Sampling-based Path Planning Focused via Direct Sampling of an Admissible Ellipsoidal Heuristic[J]. IEEE, 2014.</p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>基于搜索的路径规划</title>
    <url>/%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/%E5%9F%BA%E4%BA%8E%E6%90%9C%E7%B4%A2%E7%9A%84%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="基础知识">基础知识</h1>
<p><strong>图搜索法</strong>是通过利用已有的环境地图和障碍物等数据信息，建立由起点至目标点的可行路线。</p>
<p><strong>配置空间(Configuration Space)</strong> 在实际环境，要将工作空间转换到配置空间中，即将机器人转化为一个<strong>质点</strong>，同时将障碍物按照机器人的体积进行膨胀</p>
<span id="more"></span>
<h2 id="基本流程">基本流程</h2>
<ul>
<li>在容器<code>open list</code>中存放将要访问的节点</li>
<li>将起点加入容器</li>
<li>While True：</li>
<li>弹出：从容器中取出一个节点</li>
<li>扩展：将该节点周围的其他节点放入<code>open list</code></li>
</ul>
<h2 id="深度优先搜索depth-first-search-dfs-算法">深度优先搜索(Depth First Search, <a href="https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><code>DFS</code></a> )算法</h2>
<ul>
<li>优先扩展搜索深度较大的节点，从起点开始，按照某个顺序一条路走下去，直至不能再继续为止，然后回到上一节点，再换另一条路走下去；</li>
<li>深度优先搜索的过程是一条路走到底后，最后访问的节点最先拿来处理，整个过程可以用<code>栈(stack)</code>来表示——<strong>后进先出</strong>。</li>
<li>深度优先算法优先扩展搜索深度较大的节点，因此能够更迅速的获得下一个可行路径，不过深度优先算法获取的第一个路径通常是比较长的路径。</li>
</ul>
<p>在<strong>无权图</strong>中找到从节点<code>a</code>到节点<code>j</code>的路径为例</p>
<p><img src="/imgs/$%7Bfiilename%7D/dfs.png"  style="zoom:80%;" /></p>
<p>按照<code>DFS</code>的基本流程搜索<code>a</code>到<code>j</code>的路径：</p>
<p><img src="/imgs/$%7Bfiilename%7D/dfs-1683872034517-4.png"  style="zoom:80%;" /></p>
<p>从目标点开始回溯：<code>a-&gt;b-&gt;f-&gt;j</code></p>
<h2 id="广度优先搜索breadth-first-search-bfs算法">广度优先搜索(Breadth First Search, <a href="https://zh.wikipedia.org/zh-hans/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><code>BFS</code></a>)算法</h2>
<ul>
<li><p>每一步都扩展同一层的所有可能节点，一层一层扩展下去，直到某一层搜索到终点为止。</p></li>
<li><p>广度优先搜索的过程是一层中先访问的节点拿来处理，可以用<code>队列(queue)</code>来表示——<strong>先进先出</strong>。</p></li>
<li><p>广度优先算法优先扩展深入较小的节点，呈<strong>波状推进</strong>的形式搜索。因此广度优先算法检索到的第一个路径通常是最短路径。</p>
<p><img src="/imgs/$%7Bfiilename%7D/bfs.png"   style="zoom:80%;" /></p></li>
</ul>
<h2 id="贪婪最佳优先搜索greedy-best-first-searchgbfs-算法">贪婪最佳优先搜索(Greedy Best First Search,<a href="https://www.codecademy.com/resources/docs/ai/search-algorithms/greedy-best-first-search"><code>GBFS</code></a> )算法</h2>
<p>使用的是<strong>优先队列(Priority Queue)</strong>，普通队列是一种<strong>先进先出</strong>的数据结构，而在优先队列中元素被赋予了优先级，最高优先级元素优先删除，也就是<code>first in</code>, <code>largest out</code></p>
<p>在图搜索算法中，优先级判断的标准是代价函数 <span class="math inline">\(f(n)\)</span> ， <span class="math inline">\(f(n)\)</span> 越小，优先级越高。</p>
<p><span class="math display">\[
f(n)=h(n)
\]</span></p>
<p><span class="math inline">\(h(n)\)</span>是启发式函数，为节点<span class="math inline">\(n\)</span>到目标节点之间所形成路径的最小代价值。一般为<a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB"><code>欧氏距离</code></a>或者<a href="https://zh.wikipedia.org/wiki/%E6%9B%BC%E5%93%88%E9%A0%93%E8%B7%9D%E9%9B%A2"><code>曼哈顿距离</code></a></p>
<p>遇到障碍物时，它很容易陷入局部最优的陷阱。</p>
<h1 id="dijkstra算法"><a href="https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><code>Dijkstra</code></a>算法</h1>
<p>Dijkstra算法是从一个顶点到其余各顶点的最短路径算法，其流程仍然与上述算法基本一致，它也是用优先队列作为<code>open list</code>的数据结构，它和<code>GBFS</code>的区别在于代价函数 <span class="math inline">\(f(n)\)</span>的定义:</p>
<p><span class="math display">\[
f(n)=g(n)
\]</span> <span class="math inline">\(g(n)\)</span>表示从起始节点到当前节点<span class="math inline">\(n\)</span>的移动代价函数。</p>
<p>计算起点<code>v1</code>到终点<code>v6</code>的最短路径，箭头上的数值表示<strong>两个节点间的距离</strong></p>
<ol type="1">
<li><p>首先扩展第一个节点，计算其余邻近节点与第一个节点的距离，从未扩展的节点中选择代价函数最小的节点进行扩展，并更新其余节点的代价函数</p></li>
<li><p>重复进行上面的步骤，直到所有节点都已扩展。</p></li>
<li><p>最后标出起点到终点的最短路径</p>
<p>找到一条从<code>1</code>到<code>6</code>的最短路径</p></li>
</ol>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230512205640371.png"  style="zoom:80%;" /></p>
<p><code>open list</code>: 4(1) 2(2) # 存储已经被搜索过但没有被访问过的节点，并对其进行排序</p>
<p><code>closed list</code>:1(0) # 存储已经被访问过的节点</p>
<p>从<code>open list</code>中的节点中选择距离最小的节点作为扩展节点，显然是节点4。</p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230512210430685.png"  style="zoom:80%;" /></p>
<p><code>open list</code>: 2(2) 3(3) 7(5) 6(9) # 遍历邻接节点，更新距离</p>
<p><code>closed list</code>: 1(0) 4(1)</p>
<p>重复上述操作。选择新的扩展节点，即节点2</p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230512211350445.png" style="zoom:80%;" /></p>
<p><code>open list</code>: 3(3) 7(5) <strong>6(9)</strong> 5(13)</p>
<p><code>closed list</code>: 1(0) 4(1) 2(2)</p>
<p>选择新的扩展节点，即节点3</p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230512212316556.png" style="zoom:80%;" /></p>
<p><code>open list</code>: 7(5) <strong>6(8)</strong> 5(13) # 注意这里访问节点3，对它的领接节点6的距离进行了更新</p>
<p><code>closed list</code>: 1(0) 4(1) 2(2) 3(3)</p>
<p>选择新的扩展节点，即节点7</p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230512213110030.png"  style="zoom:80%;" /></p>
<p><code>open list</code>: <strong>6(6)</strong> 5(13) # 注意这里访问节点7，对它的领接节点6的距离进行了更新</p>
<p><code>closed list</code>: 1(0) 4(1) 2(2) 3(3) 7(5)</p>
<p>​ <img src="/imgs/$%7Bfiilename%7D/image-20230512214147752.png"  style="zoom:80%;" /></p>
<p><code>closed list</code>: 1(0) 4(1) 2(2) 3(3) 7(5) 6(6)</p>
<h1 id="a搜索a-search算法"><code>A*</code>搜索(<a href="https://zh.wikipedia.org/wiki/A*%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95"><code>A* search</code></a>)算法</h1>
<p><code>GBFS</code>用节点到目标点的距离作为代价函数，将搜索方向引向目标点，搜索效率高。</p>
<p><code>Dijkstra</code>算法采用起点到当前扩展节点的移动代价作为代价函数，能够确保路径最优。</p>
<p><code>A*</code>搜索算法在<code>Dijkstra</code>算法的基础上增加启发式函数<span class="math inline">\(h(n)\)</span>，规定其代价函数为 <span class="math display">\[
f(n)=g(n)+h(n)
\]</span></p>
<h1 id="代码实现">代码实现</h1>
<p><img src="/imgs/$%7Bfiilename%7D/Astart.png" alt="Astart" style="zoom:80%;" /></p>
<p><img src="/imgs/$%7Bfiilename%7D/dijkstra.png" alt="dijkstra" style="zoom:80%;" /></p>
<h1 id="参考">参考</h1>
<p><a href="https://zhuanlan.zhihu.com/p/346666812"><code>路径规划 | 图搜索算法：DFS、BFS、GBFS、Dijkstra、A*</code></a></p>
<p><a href="https://www.bilibili.com/video/BV1yT4y1T7Eb?p=2">机器人路径规划、轨迹优化系列课程</a></p>
]]></content>
      <categories>
        <category>路径规划</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>NexT主题添加鼠标特效</title>
    <url>/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/NexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E9%BC%A0%E6%A0%87%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<p>最近在b站无意间刷到搭建个人网站的视频，通过github+hexo的方式，期间踩得一些坑，因为现在NexT主题更新版本了，有许多美化主题的方法有所改动。</p>
<h2 id="效果图">效果图</h2>
<p><img src="/imgs/$%7Bfiilename%7D/image-20230511210128035.png"  style="zoom:80%;" /></p>
<span id="more"></span>
<h2 id="创建_databody-end.swig文件">1、创建<code>_data/body-end.swig</code>文件</h2>
<p>然后将下面的代码放入其中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 鼠标点击特效 #</span><br><span class="line">&#123;% if theme.cursor_effect == &quot;fireworks&quot; %&#125;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/fireworks.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == &quot;text&quot; %&#125;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/text.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == &quot;cherry&quot; %&#125;</span><br><span class="line">  &lt;script src=&quot;/js/cursor/cherry.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == &quot;explosion&quot; %&#125;</span><br><span class="line">  &lt;canvas class=&quot;fireworks&quot; style=&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;/canvas&gt;</span><br><span class="line">  &lt;script src=&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/explosion.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% elseif theme.cursor_effect == &quot;love&quot; %&#125;</span><br><span class="line">  &lt;script async src=&quot;/js/cursor/love.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建eblogsourcejscursor文件夹">2、创建<code>E:\blog\source\js\cursor</code>文件夹</h2>
<p>在这个文件夹下分别存放<code>.js</code>文件</p>
<h3 id="创建cherry.js">创建<code>cherry.js</code></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function cherry() &#123;</span><br><span class="line">    var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;]</span><br><span class="line">    var width = window.innerWidth;</span><br><span class="line">    var height = window.innerHeight;</span><br><span class="line">    var cursor = &#123;x: width/2, y: width/2&#125;;</span><br><span class="line">    var particles = [];</span><br><span class="line">    </span><br><span class="line">    function init() &#123;</span><br><span class="line">      bindEvents();</span><br><span class="line">      loop();</span><br><span class="line">    &#125;  </span><br><span class="line">    // Bind events that are needed</span><br><span class="line">    function bindEvents() &#123;</span><br><span class="line">      document.addEventListener(&#x27;mousemove&#x27;, onMouseMove);</span><br><span class="line">      document.addEventListener(&#x27;touchmove&#x27;, onTouchMove);</span><br><span class="line">      document.addEventListener(&#x27;touchstart&#x27;, onTouchMove);</span><br><span class="line">      </span><br><span class="line">      window.addEventListener(&#x27;resize&#x27;, onWindowResize);</span><br><span class="line">    &#125;  </span><br><span class="line">    function onWindowResize(e) &#123;</span><br><span class="line">      width = window.innerWidth;</span><br><span class="line">      height = window.innerHeight;</span><br><span class="line">    &#125; </span><br><span class="line">    function onTouchMove(e) &#123;</span><br><span class="line">      if( e.touches.length &gt; 0 ) &#123;</span><br><span class="line">        for( var i = 0; i &lt; e.touches.length; i++ ) &#123;</span><br><span class="line">          addParticle( e.touches[i].clientX, e.touches[i].clientY, possibleColors[Math.floor(Math.random()*possibleColors.length)]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function onMouseMove(e) &#123;    </span><br><span class="line">      cursor.x = e.clientX;</span><br><span class="line">      cursor.y = e.clientY;</span><br><span class="line">      </span><br><span class="line">      addParticle( cursor.x, cursor.y, possibleColors[Math.floor(Math.random()*possibleColors.length)]);</span><br><span class="line">    &#125;</span><br><span class="line">    function addParticle(x, y, color) &#123;</span><br><span class="line">      var particle = new Particle();</span><br><span class="line">      particle.init(x, y, color);</span><br><span class="line">      particles.push(particle);</span><br><span class="line">    &#125;</span><br><span class="line">    function updateParticles() &#123;</span><br><span class="line">      for( var i = 0; i &lt; particles.length; i++ ) &#123;</span><br><span class="line">        particles[i].update();</span><br><span class="line">      &#125;</span><br><span class="line">      for( var i = particles.length -1; i &gt;= 0; i-- ) &#123;</span><br><span class="line">        if( particles[i].lifeSpan &lt; 0 ) &#123;</span><br><span class="line">          particles[i].die();</span><br><span class="line">          particles.splice(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function loop() &#123;</span><br><span class="line">      requestAnimationFrame(loop);</span><br><span class="line">      updateParticles();</span><br><span class="line">    &#125;</span><br><span class="line">    function Particle() &#123;</span><br><span class="line">      this.character = &quot;*&quot;;</span><br><span class="line">      this.lifeSpan = 120; //ms</span><br><span class="line">      this.initialStyles =&#123;</span><br><span class="line">        &quot;position&quot;: &quot;fixed&quot;,</span><br><span class="line">        &quot;top&quot;: &quot;0&quot;, //必须加</span><br><span class="line">        &quot;display&quot;: &quot;block&quot;,</span><br><span class="line">        &quot;pointerEvents&quot;: &quot;none&quot;,</span><br><span class="line">        &quot;z-index&quot;: &quot;10000000&quot;,</span><br><span class="line">        &quot;fontSize&quot;: &quot;20px&quot;,</span><br><span class="line">        &quot;will-change&quot;: &quot;transform&quot;</span><br><span class="line">      &#125;;</span><br><span class="line">      this.init = function(x, y, color) &#123;</span><br><span class="line">        this.velocity = &#123;</span><br><span class="line">          x:  (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2),</span><br><span class="line">          y: 1</span><br><span class="line">        &#125;;</span><br><span class="line">        this.position = &#123;x: x - 10, y: y - 20&#125;;</span><br><span class="line">        this.initialStyles.color = color;</span><br><span class="line">        console.log(color);</span><br><span class="line">  </span><br><span class="line">        this.element = document.createElement(&#x27;span&#x27;);</span><br><span class="line">        this.element.innerHTML = this.character;</span><br><span class="line">        applyProperties(this.element, this.initialStyles);</span><br><span class="line">        this.update();</span><br><span class="line">        </span><br><span class="line">        document.body.appendChild(this.element);</span><br><span class="line">      &#125;;</span><br><span class="line">      this.update = function() &#123;</span><br><span class="line">        this.position.x += this.velocity.x;</span><br><span class="line">        this.position.y += this.velocity.y;</span><br><span class="line">        this.lifeSpan--;</span><br><span class="line">        this.element.style.transform = &quot;translate3d(&quot; + this.position.x + &quot;px,&quot; + this.position.y + &quot;px,0) scale(&quot; + (this.lifeSpan / 120) + &quot;)&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      this.die = function() &#123;</span><br><span class="line">        this.element.parentNode.removeChild(this.element);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    function applyProperties( target, properties ) &#123;</span><br><span class="line">      for( var key in properties ) &#123;</span><br><span class="line">        target.style[ key ] = properties[ key ];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">  &#125;)();</span><br></pre></td></tr></table></figure>
<h3 id="创建explosion.min.js">创建<code>explosion.min.js</code></h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function updateCoords(e) &#123;</span><br><span class="line">    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top</span><br><span class="line">&#125;</span><br><span class="line">function setParticuleDirection(e) &#123;</span><br><span class="line">    var t = anime.random(0, 360) * Math.PI / 180,</span><br><span class="line">        a = anime.random(50, 180),</span><br><span class="line">        n = [-1, 1][anime.random(0, 1)] * a;</span><br><span class="line">    return &#123;</span><br><span class="line">        x: e.x + n * Math.cos(t),</span><br><span class="line">        y: e.y + n * Math.sin(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function createParticule(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() &#123;</span><br><span class="line">        ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill()</span><br><span class="line">    &#125;, a</span><br><span class="line">&#125;</span><br><span class="line">function createCircle(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() &#123;</span><br><span class="line">        ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1</span><br><span class="line">    &#125;, a</span><br><span class="line">&#125;</span><br><span class="line">function renderParticule(e) &#123;</span><br><span class="line">    for (var t = 0; t &lt; e.animatables.length; t++) &#123;</span><br><span class="line">        e.animatables[t].target.draw()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function animateParticules(e, t) &#123;</span><br><span class="line">    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;</span><br><span class="line">        n.push(createParticule(e, t))</span><br><span class="line">    &#125;</span><br><span class="line">    anime.timeline().add(&#123;</span><br><span class="line">        targets: n,</span><br><span class="line">        x: function(e) &#123;</span><br><span class="line">            return e.endPos.x</span><br><span class="line">        &#125;,</span><br><span class="line">        y: function(e) &#123;</span><br><span class="line">            return e.endPos.y</span><br><span class="line">        &#125;,</span><br><span class="line">        radius: 0.1,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule</span><br><span class="line">    &#125;).add(&#123;</span><br><span class="line">        targets: a,</span><br><span class="line">        radius: anime.random(80, 160),</span><br><span class="line">        lineWidth: 0,</span><br><span class="line">        alpha: &#123;</span><br><span class="line">            value: 0,</span><br><span class="line">            easing: &quot;linear&quot;,</span><br><span class="line">            duration: anime.random(600, 800)</span><br><span class="line">        &#125;,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule,</span><br><span class="line">        offset: 0</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function debounce(e, t) &#123;</span><br><span class="line">    var a;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var n = this,</span><br><span class="line">            i = arguments;</span><br><span class="line">        clearTimeout(a), a = setTimeout(function() &#123;</span><br><span class="line">            e.apply(n, i)</span><br><span class="line">        &#125;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var canvasEl = document.querySelector(&quot;.fireworks&quot;);</span><br><span class="line">if (canvasEl) &#123;</span><br><span class="line">    var ctx = canvasEl.getContext(&quot;2d&quot;),</span><br><span class="line">        numberOfParticules = 30,</span><br><span class="line">        pointerX = 0,</span><br><span class="line">        pointerY = 0,</span><br><span class="line">        tap = &quot;mousedown&quot;,</span><br><span class="line">        colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;],</span><br><span class="line">        setCanvasSize = debounce(function() &#123;</span><br><span class="line">            canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(&quot;2d&quot;).scale(2, 2)</span><br><span class="line">        &#125;, 500),</span><br><span class="line">        render = anime(&#123;</span><br><span class="line">            duration: 1 / 0,</span><br><span class="line">            update: function() &#123;</span><br><span class="line">                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    document.addEventListener(tap, function(e) &#123;</span><br><span class="line">        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))</span><br><span class="line">    &#125;, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)</span><br><span class="line">&#125;</span><br><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">function updateCoords(e) &#123;</span><br><span class="line">    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top</span><br><span class="line">&#125;</span><br><span class="line">function setParticuleDirection(e) &#123;</span><br><span class="line">    var t = anime.random(0, 360) * Math.PI / 180,</span><br><span class="line">        a = anime.random(50, 180),</span><br><span class="line">        n = [-1, 1][anime.random(0, 1)] * a;</span><br><span class="line">    return &#123;</span><br><span class="line">        x: e.x + n * Math.cos(t),</span><br><span class="line">        y: e.y + n * Math.sin(t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function createParticule(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() &#123;</span><br><span class="line">        ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill()</span><br><span class="line">    &#125;, a</span><br><span class="line">&#125;</span><br><span class="line">function createCircle(e, t) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    return a.x = e, a.y = t, a.color = &quot;#F00&quot;, a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() &#123;</span><br><span class="line">        ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1</span><br><span class="line">    &#125;, a</span><br><span class="line">&#125;</span><br><span class="line">function renderParticule(e) &#123;</span><br><span class="line">    for (var t = 0; t &lt; e.animatables.length; t++) &#123;</span><br><span class="line">        e.animatables[t].target.draw()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function animateParticules(e, t) &#123;</span><br><span class="line">    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;</span><br><span class="line">        n.push(createParticule(e, t))</span><br><span class="line">    &#125;</span><br><span class="line">    anime.timeline().add(&#123;</span><br><span class="line">        targets: n,</span><br><span class="line">        x: function(e) &#123;</span><br><span class="line">            return e.endPos.x</span><br><span class="line">        &#125;,</span><br><span class="line">        y: function(e) &#123;</span><br><span class="line">            return e.endPos.y</span><br><span class="line">        &#125;,</span><br><span class="line">        radius: 0.1,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule</span><br><span class="line">    &#125;).add(&#123;</span><br><span class="line">        targets: a,</span><br><span class="line">        radius: anime.random(80, 160),</span><br><span class="line">        lineWidth: 0,</span><br><span class="line">        alpha: &#123;</span><br><span class="line">            value: 0,</span><br><span class="line">            easing: &quot;linear&quot;,</span><br><span class="line">            duration: anime.random(600, 800)</span><br><span class="line">        &#125;,</span><br><span class="line">        duration: anime.random(1200, 1800),</span><br><span class="line">        easing: &quot;easeOutExpo&quot;,</span><br><span class="line">        update: renderParticule,</span><br><span class="line">        offset: 0</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function debounce(e, t) &#123;</span><br><span class="line">    var a;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var n = this,</span><br><span class="line">            i = arguments;</span><br><span class="line">        clearTimeout(a), a = setTimeout(function() &#123;</span><br><span class="line">            e.apply(n, i)</span><br><span class="line">        &#125;, t)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var canvasEl = document.querySelector(&quot;.fireworks&quot;);</span><br><span class="line">if (canvasEl) &#123;</span><br><span class="line">    var ctx = canvasEl.getContext(&quot;2d&quot;),</span><br><span class="line">        numberOfParticules = 30,</span><br><span class="line">        pointerX = 0,</span><br><span class="line">        pointerY = 0,</span><br><span class="line">        tap = &quot;mousedown&quot;,</span><br><span class="line">        colors = [&quot;#FF1461&quot;, &quot;#18FF92&quot;, &quot;#5A87FF&quot;, &quot;#FBF38C&quot;],</span><br><span class="line">        setCanvasSize = debounce(function() &#123;</span><br><span class="line">            canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + &quot;px&quot;, canvasEl.style.height = window.innerHeight + &quot;px&quot;, canvasEl.getContext(&quot;2d&quot;).scale(2, 2)</span><br><span class="line">        &#125;, 500),</span><br><span class="line">        render = anime(&#123;</span><br><span class="line">            duration: 1 / 0,</span><br><span class="line">            update: function() &#123;</span><br><span class="line">                ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    document.addEventListener(tap, function(e) &#123;</span><br><span class="line">        &quot;sidebar&quot; !== e.target.id &amp;&amp; &quot;toggle-sidebar&quot; !== e.target.id &amp;&amp; &quot;A&quot; !== e.target.nodeName &amp;&amp; &quot;IMG&quot; !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))</span><br><span class="line">    &#125;, !1), setCanvasSize(), window.addEventListener(&quot;resize&quot;, setCanvasSize, !1)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="创建love.js文件">创建<code>love.js</code>文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!</span><br><span class="line">function(e, t, a) &#123;</span><br><span class="line">    function n() &#123;</span><br><span class="line">        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function r() &#123;</span><br><span class="line">        for (var e = 0; e &lt; d.length; e++) d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y--, d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);</span><br><span class="line">        requestAnimationFrame(r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function o() &#123;</span><br><span class="line">        var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;</span><br><span class="line">        e.onclick = function(e) &#123;</span><br><span class="line">            t &amp;&amp; t(), i(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function i(e) &#123;</span><br><span class="line">        var a = t.createElement(&quot;div&quot;);</span><br><span class="line">        a.className = &quot;heart&quot;, d.push(&#123;</span><br><span class="line">            el: a,</span><br><span class="line">            x: e.clientX - 5,</span><br><span class="line">            y: e.clientY - 5,</span><br><span class="line">            scale: 1,</span><br><span class="line">            alpha: 1,</span><br><span class="line">            color: s()</span><br><span class="line">        &#125;), t.body.appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function c(e) &#123;</span><br><span class="line">        var a = t.createElement(&quot;style&quot;);</span><br><span class="line">        a.type = &quot;text/css&quot;;</span><br><span class="line">        try &#123;</span><br><span class="line">            a.appendChild(t.createTextNode(e))</span><br><span class="line">        &#125; catch (t) &#123;</span><br><span class="line">            a.styleSheet.cssText = e</span><br><span class="line">        &#125;</span><br><span class="line">        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function s() &#123;</span><br><span class="line">        return &quot;rgb(&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    var d = [];</span><br><span class="line">    e.requestAnimationFrame = function() &#123;</span><br><span class="line">        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame ||</span><br><span class="line">        function(e) &#123;</span><br><span class="line">            setTimeout(e, 1e3 / 60)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(), n()</span><br><span class="line">&#125;(window, document);</span><br></pre></td></tr></table></figure>
<h3 id="创建text.js文件">创建<code>text.js</code>文件</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a_idx = 0;</span><br><span class="line">jQuery(document).ready(function($) &#123;</span><br><span class="line">  $(&quot;body&quot;).click(function(e) &#123;</span><br><span class="line">    var a = new Array(&quot;富强&quot;, &quot;民主&quot;,&quot;文明&quot;,&quot;和谐&quot;,&quot;自由&quot;,&quot;平等&quot;,&quot;公正&quot;,&quot;法治&quot;,&quot;爱国&quot;,&quot;敬业&quot;,&quot;诚信&quot;,&quot;友善&quot;);</span><br><span class="line">    var $i = $(&quot;&lt;span/&gt;&quot;).text(a[a_idx]);</span><br><span class="line">    var x = e.pageX,</span><br><span class="line">    y = e.pageY;</span><br><span class="line">    $i.css(&#123;</span><br><span class="line">      &quot;z-index&quot;: 99999,</span><br><span class="line">      &quot;top&quot;: y - 28,</span><br><span class="line">      &quot;left&quot;: x - a[a_idx].length * 8,</span><br><span class="line">      &quot;position&quot;: &quot;absolute&quot;,</span><br><span class="line">      &quot;color&quot;: s()</span><br><span class="line">    &#125;);</span><br><span class="line">    $(&quot;body&quot;).append($i);</span><br><span class="line">    $i.animate(&#123;</span><br><span class="line">      &quot;top&quot;: y - 180,</span><br><span class="line">      &quot;opacity&quot;: 0</span><br><span class="line">    &#125;, 1500, function() &#123;</span><br><span class="line">      $i.remove();</span><br><span class="line">    &#125;);</span><br><span class="line">    a_idx = (a_idx + 1) % a.length;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function s() &#123;</span><br><span class="line">  return &quot;rgb(&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;,&quot; + ~~ (255 * Math.random()) + &quot;)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打开-eblogthemesnext_config.yml-文件">3、打开 <code>E:\blog\themes\next\_config.yml</code> 文件</h2>
<p>然后取消 <code>post-body-end.swig</code> 的注释</p>
<p><img src="./imgs/$%7Bfiilename%7D/image-20230511205003639.png"  style="zoom:80%;" /></p>
<h2 id="打开主题配置文件eblogthemesnext_config.yml">4、打开主题配置文件<code>E:\blog\themes\next\_config.yml</code></h2>
<p>在文件中合适的位置添加下面的代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 鼠标点击特效</span><br><span class="line"># mouse click effect: | cherry | explosion | fireworks | love | text </span><br><span class="line">cursor_effect:  explosion</span><br></pre></td></tr></table></figure>
<h2 id="启动服务就可以看到特效了">5、启动服务就可以看到特效了</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo--数学公式渲染</title>
    <url>/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/Hexo-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<h1 id="pandoc-进行数学公式渲染">Pandoc 进行数学公式渲染</h1>
<p>主题是选择的NexT,下面是使用对应的Hexo渲染器在博客中显示出数学公式。</p>
<span id="more"></span>
<h2 id="步骤">步骤</h2>
<h3 id="在next_config.yml文件中将enable选项改为true">1、在<code>next/_config.yml</code>文件中将enable选项改为true</h3>
<p><img src="/imgs/$%7Bfiilename%7D/1683703455213.jpg" style="zoom:80%;" /></p>
<h3 id="使用-hexo-renderer-pandoc-作为-hexo-的-markdown-渲染器">2、使用 <a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a> 作为 Hexo 的 Markdown 渲染器。</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked  #卸载原有的渲染器</span><br><span class="line">npm install hexo-renderer-pandoc  # 安装pandoc渲染器</span><br></pre></td></tr></table></figure>
<h3 id="执行-hexo-生成部署">3、执行 Hexo 生成，部署</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g -d</span><br></pre></td></tr></table></figure>
<h2 id="注意">注意</h2>
<p>a: 执行最后一步后出现如下的问题：</p>
<p><code>ERROR:pandoc exited with code 9: pandoc: Unknown extension: smart</code></p>
<p>解决办法:</p>
<p>将<code>node_modules\hexo-renderer-pandoc\index.js</code>文件中的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var args = [ &#x27;-f&#x27;, &#x27;markdown-smart&#x27;+extensions, &#x27;-t&#x27;, &#x27;html-smart&#x27;, math]</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var args = [ &#x27;-f&#x27;, &#x27;markdown&#x27;+extensions, &#x27;-t&#x27;, &#x27;html&#x27;, math]</span><br></pre></td></tr></table></figure>
<p>b: 正常的文字后面如果跟的是 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fadam-p%2Fmarkdown-here%2Fwiki%2FMarkdown-Cheatsheet%23lists"><code>list</code></a>, <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fadam-p%2Fmarkdown-here%2Fwiki%2FMarkdown-Cheatsheet%23tables"><code>table</code></a> 或者 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fadam-p%2Fmarkdown-here%2Fwiki%2FMarkdown-Cheatsheet%23blockquotes"><code>quotation</code></a>，文字后面需要空一行，如果不空行，这些环境将不能被 Pandoc renderer 正常渲染。</p>
<h2 id="参考">参考</h2>
<p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/MATH.md">数学公式</a></p>
<p><a href="https://github.com/hexojs/hexo-renderer-pandoc/issues/36">pandoc/issues</a></p>
<p><a href="https://www.jianshu.com/p/c9beedaf08e4">Hexo 搭建个人博客指南</a></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora添加数学公式</title>
    <url>/%E5%B7%A5%E5%85%B7%E9%80%9F%E6%9F%A5/Typora%E6%B7%BB%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>Typora是一款支持Markdown的编辑器，亲测非常好用，在此总结了常用的公式编辑方法，旨在文章更加的美观规范。</strong></p>
<span id="more"></span>
<h1 id="补充">补充</h1>
<h2 id="公式内部添加大括号">公式内部添加大括号</h2>
<p><span class="math display">\[
\begin{cases}
q=kx_1+y_1\\
q=kx_2+y_2
\end{cases}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\begin&#123;cases&#125;</span><br><span class="line">q=kx_1+y_1\\</span><br><span class="line">q=kx_2+y_2</span><br><span class="line">\end&#123;cases&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字母上方添加横线">字母上方添加横线</h2>
<p><span class="math display">\[
\overline{F}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\overline&#123;F&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字母上方添加尖号">字母上方添加尖号</h2>
<p><span class="math display">\[
\hat{f}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\hat&#123;f&#125;</span><br></pre></td></tr></table></figure> <span class="math display">\[
\widehat{F}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\widehat&#123;F&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字母上方添加点">字母上方添加点</h2>
<p><span class="math display">\[
\dot{f}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\dot&#123;f&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字母上方添加点点">字母上方添加点点</h2>
<p><span class="math display">\[
\ddot{f}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\ddot&#123;f&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字母上方添加波浪号">字母上方添加波浪号</h2>
<p><span class="math display">\[
\tilde{f}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\tilde&#123;f&#125;</span><br></pre></td></tr></table></figure> <span class="math display">\[
\widetilde{F}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\widetilde&#123;f&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字母正上下方插入下标">字母正上/下方插入下标</h2>
<p><span class="math display">\[
\overset {*}{x}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\overset &#123;*&#125;&#123;x&#125;</span><br></pre></td></tr></table></figure> <span class="math display">\[
\underset {x}{min}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\underset &#123;x&#125;&#123;min&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="字母正上下方插入大括号">字母正上/下方插入大括号</h2>
<p><span class="math display">\[
\overbrace{}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\overbrace&#123;&#125;</span><br></pre></td></tr></table></figure> <span class="math display">\[
\underbrace{}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\underbrace&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矩阵">矩阵</h2>
<p><span class="math display">\[
\left[\begin{matrix}
1&amp;2&amp;3\\
4&amp;5&amp;6
\end{matrix}\right]
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\left[\begin&#123;matrix&#125;</span><br><span class="line">1&amp;2&amp;3\\</span><br><span class="line">4&amp;5&amp;6</span><br><span class="line">\end&#123;matrix&#125;\right]</span><br></pre></td></tr></table></figure></p>
<h1 id="常用公式的代码">常用公式的代码</h1>
<h2 id="梯度">梯度</h2>
<p><span class="math display">\[
\nabla
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\nabla</span><br></pre></td></tr></table></figure></p>
<h2 id="度数的圆圈">度数的圆圈</h2>
<p><span class="math display">\[
90^\circ
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">90^\circ</span><br></pre></td></tr></table></figure></p>
<h2 id="分式">分式</h2>
<p><span class="math display">\[
1/2
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1/2</span><br></pre></td></tr></table></figure> <span class="math display">\[
\frac{1}{2}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\frac&#123;1&#125;&#123;2&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="水平省略号">水平省略号</h2>
<p><span class="math display">\[
...
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\cdots</span><br></pre></td></tr></table></figure></p>
<h2 id="垂直省略号">垂直省略号</h2>
<p><span class="math display">\[
\vdots
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\vdots</span><br></pre></td></tr></table></figure></p>
<h2 id="开根号">开根号</h2>
<p><span class="math display">\[
\sqrt{2}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\sqrt&#123;2&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="矢量">矢量</h2>
<p><span class="math display">\[
\vec{a}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\vec&#123;a&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="积分">积分</h2>
<p><span class="math display">\[
\int{x}dx
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\int&#123;x&#125;dx</span><br></pre></td></tr></table></figure> <span class="math display">\[
\int_{1}^{2}{x}dx
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\int_&#123;1&#125;^&#123;2&#125;&#123;x&#125;dx</span><br></pre></td></tr></table></figure></p>
<h2 id="微分">微分</h2>
<p><span class="math display">\[
\partial
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\partial</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\frac{\partial x}{\partial y}
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\frac&#123;\partial x&#125;&#123;\partial y&#125;</span><br></pre></td></tr></table></figure>
<h2 id="极限">极限</h2>
<p><span class="math display">\[
\lim{a+b}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\lim&#123;a+b&#125;</span><br></pre></td></tr></table></figure> <span class="math display">\[
\lim_{n\rightarrow+\infty}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\lim_&#123;n\rightarrow+\infty&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="累加">累加</h2>
<p><span class="math display">\[
\sum{a}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\sum&#123;a&#125;</span><br></pre></td></tr></table></figure> <span class="math display">\[
\sum_{n=1}^{100}{a_n}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\sum_&#123;n=1&#125;^&#123;100&#125;&#123;a_n&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="累乘">累乘</h2>
<p><span class="math display">\[
\prod{x}
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\prod_&#123;n=1&#125;^&#123;99&#125;&#123;x_n&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="空格">空格</h2>
<p><span class="math display">\[
a\quad b
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a\quad b</span><br></pre></td></tr></table></figure></p>
<h2 id="希腊字母">希腊字母</h2>
<p><span class="math display">\[
\alpha
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\alpha</span><br></pre></td></tr></table></figure> <span class="math display">\[
\beta
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\beta</span><br></pre></td></tr></table></figure> <span class="math display">\[
\gamma
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\gamma</span><br></pre></td></tr></table></figure> <span class="math display">\[
\Delta
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\Delta</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\delta
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\delta</span><br></pre></td></tr></table></figure> <span class="math display">\[
\varepsilon
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\varepsilon</span><br></pre></td></tr></table></figure> <span class="math display">\[
\epsilon
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\epsilon</span><br></pre></td></tr></table></figure> <span class="math display">\[
\zeta
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\zeta</span><br></pre></td></tr></table></figure> <span class="math display">\[
\eta
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\eta</span><br></pre></td></tr></table></figure> <span class="math display">\[
\theta
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\theta</span><br></pre></td></tr></table></figure> <span class="math display">\[
\lambda
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\lambda</span><br></pre></td></tr></table></figure> <span class="math display">\[
\mu
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\mu</span><br></pre></td></tr></table></figure> <span class="math display">\[
\nu
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\nu</span><br></pre></td></tr></table></figure> <span class="math display">\[
\pi
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\pi</span><br></pre></td></tr></table></figure> <span class="math display">\[
\rho
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\rho</span><br></pre></td></tr></table></figure> <span class="math display">\[
\sigma
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\sigma</span><br></pre></td></tr></table></figure> <span class="math display">\[
\tau
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\tau</span><br></pre></td></tr></table></figure> <span class="math display">\[
\varphi
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\varphi</span><br></pre></td></tr></table></figure> <span class="math display">\[
\omega
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\omega</span><br></pre></td></tr></table></figure></p>
<p>三角函数 <span class="math display">\[
\sin
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\sin</span><br></pre></td></tr></table></figure></p>
<h2 id="对数函数">对数函数</h2>
<p><span class="math display">\[
\ln2
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\ln2</span><br></pre></td></tr></table></figure> <span class="math display">\[
log_28
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\log_28</span><br></pre></td></tr></table></figure> <span class="math display">\[
lg10
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\lg10</span><br></pre></td></tr></table></figure></p>
<h2 id="关系运算符">关系运算符</h2>
<p><span class="math display">\[
\pm
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\pm</span><br></pre></td></tr></table></figure> <span class="math display">\[
\times
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\times</span><br></pre></td></tr></table></figure> <span class="math display">\[
\cdot
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\cdot</span><br></pre></td></tr></table></figure> <span class="math display">\[
\div
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\div</span><br></pre></td></tr></table></figure> <span class="math display">\[
\approx
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\approx</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\neq
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\neq</span><br></pre></td></tr></table></figure> <span class="math display">\[
\leq
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\leq</span><br></pre></td></tr></table></figure> <span class="math display">\[
 \geq 
\]</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\geq</span><br></pre></td></tr></table></figure></p>
<p><span class="math display">\[
\in
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\in</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\cap
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\cap</span><br></pre></td></tr></table></figure>
<p><span class="math display">\[
\cup
\]</span></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\cup</span><br></pre></td></tr></table></figure>
<h1 id="参考">参考</h1>
<p>使用Typora添加数学公式：https://www.typora.net/1109.html</p>
]]></content>
      <categories>
        <category>工具速查</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
</search>
